<script>
let idb = null
let store = null
let r
const basicBitchServerUrl = "http://localhost:3000"
let user
let userText = localStorage.getItem("user")
let usingLocalStore = true
let startFn = () => gotoNoHistory("dailyNotes")
let dataLoaded = false
let scriptsLoaded = false
const setDataLoaded = () => {
if (scriptsLoaded)
start()
dataLoaded = true
}
const start = () => {
user.graphName = store.graphName
saveUser()
startFn()
debouncedSaveStore()
}
const invalidateLocal = () => {
const r = indexedDB.deleteDatabase("microroam")
console.error(`Local replica invalid. Resetting from server`)
user.settings.commitId = undefined
user.settings.syncCommitId = undefined
localStorage.setItem("user",JSON.stringify(user))
localStorage.removeItem('store')
window.location.href = window.location.href
}
if (userText) {
user = JSON.parse(userText)
if (user.passwordHash) {
const headers = new Headers()
headers.set('passwordhash',user.passwordHash)
if (user.settings.commitId) headers.set('commitid',user.settings.commitId)
let reqUrl = `${basicBitchServerUrl}/startup/${user.settings.graphName}`
fetch(reqUrl,{ method: 'POST',headers: headers }).then(async (res) => {
if (res.status === 304) {
console.log(`already up to date`)
return
}
if (res.status !== 200) {
console.log(`STORE NOT ON SERVER`)
return
}
usingLocalStore = false
res.json().then(blox => {
console.log('got blox')
hydrateFromBlox(user.settings.graphName,blox)
setTimeout(generateInnerOuterRefs,160)
start() // todo catch code loading after this
debouncedSaveStore()
})
})
}
const lsStore = localStorage.getItem('store')
if (lsStore) {
try {
store = JSON.parse(lsStore)
setDataLoaded()
} catch (e) {
invalidateLocal()
}
r = indexedDB.open("microroam",5)
r.onsuccess = (e1) => idb = e1.target.result
} else {
r = indexedDB.open("microroam",5)
r.onsuccess = (e1) => {
console.log("normal success")
idb = e1.target.result
if (usingLocalStore === true) {
try {
idb.transaction(["stores"],"readonly").objectStore("stores").get(user.graphName).onsuccess = (e) => {
if (usingLocalStore === true) {
if (e.target.result) {
try {
store = JSON.parse(e.target.result.store)
setDataLoaded()
} catch (e) {
invalidateLocal()
}
} else {
console.log("adding default graph")
}
}
}
} catch (e) {
}
}
}
}
} else {
user = { settings: { graphName: "default",theme: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? "dark" : "light",topBar: "visible",logging: false,spellcheck: false } }
fetch("./default-store.json").then(text => {
text.json().then(json => {
store = json
startFn = () => gotoNoHistory("pageTitle","Welcome to Micro Roam")
setDataLoaded()
})
})
r = indexedDB.open("microroam",5)
r.onsuccess = (e1) => idb = e1.target.result
}
r.onupgradeneeded = (event) => {
console.log("upgradeneeded")
const db = r.result
const stores = Array.from(db.objectStoreNames)
if (!stores.includes("stores")) {
db.createObjectStore("stores",{ keyPath: "graphName" })
} else {
console.log(event)
console.log(db)
r.onsuccess = () => {
console.log("new success")
idb = event.target.result
const storeStore = db.transaction(["stores"],"readonly").objectStore("stores")
storeStore.get(user.graphName).onsuccess = (e) => {
store = e.target.result.store
const roamJSON = oldStoreToRoamJSON[db.version](store)
roamJsonToStore(user.graphName,roamJSON)
saveStore()
setDataLoaded()
}
}
}
}
r.onerror = (e) => {
console.log("error")
console.log(e)
alert(`In order to save your notes between sessions, Micro Roam needs access to IndexedDB. 
You can allow access by exiting "private browsing" mode, or by using a newer browser, or by changing browser settings`)
}
</script>
<body class="dark">
<div id="app">
<div id="top-bar" style="margin-top:-43px">
<a id="report-issue-button" target="_blank" href="mailto:taoroalin@gmail.com?subject=You Made Micro Roam Wrong"
tabindex="-1">
Report Issue
</a>
<button id="help-button" tabindex="-1">
Help
</button>
<button id="daily-notes-button" tabindex="-1">
Daily Notes
</button>
<input id="search-input" placeholder="search" tabindex="-1">
<button id="upload-button" tabindex="-1">
<input style="display:none" type="file" id="upload-input">
Upload
</button>
<a id="download-button" tabindex="-1">
Download
</a>
<button id="signup-button" tabindex="-1">
Sign up
</button>
</div>
<div id="top-bar-hidden-hitbox" style="position:fixed;height:20px;width:100%;display:none;"></div>
<script>
document.body.className = user.settings.theme
const topBar = document.getElementById("top-bar")
const topBarHiddenHitbox = document.getElementById("top-bar-hidden-hitbox")
if (user.settings.topBar === 'visible') {
topBar.style.marginTop = "0px"
topBarHiddenHitbox.style.display = "none"
}
setTimeout(() => topBar.className = "top-bar-transition",200)
</script>
<div id="terminal" contenteditable="true" style="display:none"></div>
<div id="page-frame-outer">
<div id="page-frame">
</div>
</div>
<div id="autocomplete-list" style="display:none"></div>
<!-- inline styles on this site are all edited directly by js -->
<div id="search-result-list" style="display:none"></div>
<div id="template-list" style="display:none"></div>
<div id="login" style="display:none">
<p>Login</p>
<form id="login-form">
<input type="email" id="login-email" placeholder="email">
<input type="password" id="login-password" placeholder="password">
<input type="submit" style="height:0px" tabindex="-1">
</form>
<button id="switch-to-signup">Sign up</button>
<button class="exit-to-main">Back</button>
</div>
<div id="signup" style="display:none">
<p>Sign up</p>
<form id="signup-form">
<input type="email" id="signup-email" placeholder="email">
<input type="text" id="signup-username" placeholder="username">
<input type="password" id="signup-password" placeholder="password">
<input type="submit" style="height:0px" tabindex="-1">
</form>
<button id="switch-to-login">Login</button>
<button class="exit-to-main">Back</button>
</div>
</div>
<title>Micro Roam</title>
<style>
/* global styles ----------------------------------------------------------------------------- */
* {
outline: none;
scrollbar-width: none;
/* --pop: #c2c2c2;
--placeholder: #919191; */
}
.dark {
--background: #161616;
--click: rgb(100, 100, 100);
--text: rgb(246, 246, 246);
--link: #3f84c0;
--brackets: #a7b6c2;
--block-ref: rgb(63, 63, 63);
--bullet: #758897;
--border: #afbeca;
--break: #838e97;
--highlight: rgb(110, 93, 16);
--page-ref: #2bcc5b;
--shadow: rgb(98, 98, 98);
--notification: #2e4736;
--selected: #2d4a66;
}
.light {
--background: white;
--click: rgb(197, 197, 197);
--text: black;
--link: rgb(54, 123, 184);
--brackets: #a7b6c2;
--block-ref: lightgrey;
--bullet: #394b59;
--border: #585e64;
--shadow: #585e64;
--break: #a8b4be;
--highlight: rgb(255, 239, 146);
--page-ref: rgb(73, 197, 91);
--notification: #a4d1b1;
--selected: #abcdeb;
}
input,
button,
a {
font-family: "Inter", Verdana;
}
input {
border: none;
}
button {
appearance: none;
border: none;
box-shadow: none;
cursor: pointer;
background-color: inherit;
color: inherit;
font-size: inherit;
}
span {
margin: 0;
padding: 0;
}
::-webkit-scrollbar {
width: 0%;
height: 0%;
}
::selection {
background-color: #85b7e8;
color: var(--text);
}
body {
scrollbar-width: 0px;
font-family: "Inter", Verdana, Arial;
font-weight: normal;
margin: 0;
color: var(--text);
background-color: var(--background);
}
a {
color: var(--link);
}
a:visited {
color: var(--link);
}
.notification {
text-align: center;
min-width: 300px;
position: fixed;
left: 50%;
transform: translateX(-50%);
top: -40px; /* transitions to more px */
margin-top: 0px;
opacity: 1;
transition: top 0.25s ease-out, opacity 0.2s linear;
padding: 20px;
background-color: var(--notification);
border-radius: 8px;
}
/* singular element styles --------------------------------------------------------------------------------------- */
#app {
height: 100%;
width: 100%;
display: flex;
flex-direction: column;
}
#page-frame-outer {
width: 100%;
overflow-y: scroll;
}
#page-frame {
margin: 0 auto 30px;
max-width: min(900px, 100%);
}
#top-bar {
width: 100%;
display: flex;
flex-direction: row;
align-content: space-between;
background-color: var(--background);
}
.top-bar-transition{
transition: margin-top 0.1s;
}
/* these have different paddings, but look the same because weird stuff. todo investigate */
#top-bar a {
padding: 14px 10px 10px;
font-size: 0.9em;
color: var(--text);
display: block;
cursor: pointer;
text-decoration: none;
}
#top-bar button {
padding: 14px 10px 10px;
font-size: 0.9em;
}
#search-input {
background-color: var(--background);
color: var(--text);
padding: 3px 13px;
margin: 7px 5px 5px;
display: block;
font-size: 1.2em;
box-shadow: 0 0 2px var(--shadow);
border-radius: 100px;
flex-grow: 1;
}
#autocomplete-list,
#template-list {
position: absolute;
display: flex;
flex-direction: column;
background-color: var(--background);
font-size: 1.3em;
border-radius: 5px;
box-shadow: 0 0 8px var(--shadow);
}
.autocomplete__suggestion[data-selected="true"],
.template__suggestion[data-selected="true"] {
background-color: var(--click);
}
.autocomplete__suggestion,
.template__suggestion {
padding: 7px;
cursor: pointer;
border-radius: 5px;
}
#search-result-list {
position: absolute;
display: flex;
flex-direction: column;
background-color: var(--background);
font-size: 1.3em;
border-radius: 5px;
box-shadow: 0 0 8px var(--shadow);
}
.search-result[data-selected="true"] {
background-color: var(--click);
}
.search-result {
padding: 7px;
cursor: pointer;
border-radius: 5px;
}
/* Login / Signup styles ------------------------------------------------------------------------*/
#login,
#signup {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-color: var(--background);
text-align: center;
}
#login-form,
#signup-form {
position: fixed;
top: 28%;
left: 50%;
transform: translateX(-50%);
padding: 13px 20px 20px;
border-radius: 12px;
display: flex;
flex-direction: column;
justify-content: space-between;
}
#login input,
#signup input {
background-color: var(--background);
color: var(--text);
font-size: 1.4em;
border-radius: 3px;
display: block;
padding: 4px;
/* border:1px solid var(--border); */
margin-bottom: 13px;
}
#login button,
#signup button {
position: fixed;
bottom: 19%;
left: 50%;
transform: translateX(-50%);
display: block;
padding: 4px;
border-radius: 3px;
background-color: var(--background);
color: var(--placeholder);
}
#login button:focus,
#signup button:focus {
font-weight: bold;
}
#login p,
#signup p {
left: 50%;
font-size: 1.7em;
color: var(--placeholder);
padding: 4px;
margin-bottom: 20px;
margin-top: 65px;
}
#login .exit-to-main, #signup .exit-to-main{
bottom:9%;
}
/* Page styles --------------------------------------------------------------------------------------------------- */
.page {
margin-right: 30px;
margin-left: 30px;
position: relative;
}
.page__title {
font-size: 32px;
margin: 35px 0 20px 0;
}
.page__body,
.backref-frame__body {
margin-left: 20px;
}
.backref-list__body {
margin-left: 10px;
}
.backref-list__title {
font-size: 1.3em;
font-weight: bold;
padding: 20px 0 0;
}
.page-break {
height: 0px;
margin: 50px 25px;
border: 1px solid var(--break);
border-width: 1px 0 0 0;
}
.block {
position: relative;
border-radius: 5px;
}
.block[data-selected="true"] {
background-color: var(--selected);
}
.block__body {
padding: 5px 0;
}
.block__bullet {
cursor: pointer;
position: absolute;
left: -21px;
top: 4px;
}
.block__children {
margin-left: 25px;
}
.block-focus-frame {
margin: 60px 0;
}
.breadcrumb-page {
cursor: pointer;
}
.breadcrumb-block {
cursor: pointer;
}
.backref-frame__breadcrumb {
margin: 15px 0 5px 0;
font-size: 1.2em;
}
.block-focus-frame__breadcrumb {
margin: 15px 0 5px 0;
font-size: 1.2em;
}
/* Parsed block styles -------------------------------------------------------------------------------------- */
.page-ref {
position: relative;
}
.page-ref__brackets {
font-weight: lighter;
color: var(--brackets);
}
.page-ref__body {
color: var(--page-ref);
font-weight: 800;
}
.page-ref:hover {
cursor: pointer;
}
.page-ref:hover > .page-ref__body {
text-decoration: underline;
}
.tag {
color: var(--page-ref);
font-weight: 800;
position: relative;
}
.tag:hover {
text-decoration: underline;
cursor: pointer;
}
.block-ref {
background-color: var(--block-ref);
}
.block-ref:hover {
text-decoration: underline;
cursor: pointer;
}
.bold {
font-weight: bold;
}
.italic {
font-style: italic;
}
.highlight {
background-color: var(--highlight);
border-radius: 2px;
padding: 1px;
}
.block-focus-frame {
margin: 35px 0 0 60px;
}
.url {
color: var(--link);
text-decoration: underline;
cursor: pointer;
}
.literal {
font-family: "Inconsolata";
font-size: 1.15em;
}
.code-block {
font-family: "Inconsolata";
font-size: 1.15em;
/* display: block; */
}
.attribute {
font-weight: bold;
}
.attribute:hover {
cursor: pointer;
}
#terminal {
font-family: "Inconsolata";
width: 100%;
padding: 8px;
background-color: black;
color: white;
}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata">
<template id="page">
<div class="page">
<h1 class="page__title" contenteditable="true" tabindex="-1" spellcheck="false"></h1>
<div class="page__body">
</div>
<div class="page__backlinks">
</div>
</div>
</template>
<template id="block">
<div class="block">
<svg class="block__bullet" width="20" height="20">
<circle cx="10" cy="10.5" r="3" fill="var(--bullet)" />
</svg>
<div class="block__body" contenteditable="true" tabindex="-1" spellcheck="false">
</div>
<div class="block__children">
</div>
</div>
</template>
<template id="backref-list">
<div class="backref-list">
<div class="backref-list__title">Linked References</div>
<div class="backref-list__body"></div>
</div>
</template>
<template id="page-break">
<div class="page-break"></div>
</template>
<template id="block-focus-frame">
<div class="block-focus-frame">
<div class="block-focus-frame__breadcrumb"></div>
<div class="block-focus-frame__body"></div>
<div class="block-focus-frame__backlinks"></div>
</div>
</template>
<template id="backref-frame">
<div class="backref-frame">
<div class="backref-frame__breadcrumb"></div>
<div class="backref-frame__body"></div>
</div>
</template>
<template id="page-ref">
<span class="page-ref"><span class="page-ref__brackets"></span><span class="page-ref__body"></span><span
class="page-ref__brackets"></span></span>
</template>
<template id="autocomplete__suggestion">
<div class="autocomplete__suggestion"></div>
</template>
<template id="template__suggestion">
<div class="template__suggestion"></div>
</template>
<template id="search-result">
<div class="search-result"></div>
</template>
<template id="breadcrumb-block">
<span class="breadcrumb-block"><span class="breadcrumb-block__arrow">-></span><span
class="breadcrumb-block__body"></span></span>
</template>
<template id="breadcrumb-page">
<span class="breadcrumb-page"></span>
</template>
<template id="notification">
<div class="notification"></div>
</template>
<script>
let editingTemplateExpander = null
let editingLink = null
let editingTitle = null
let focusNode = null
let focusOffset = null
let focusBlock = null
let focusSuggestion = null
let focusSearchResult = null
let sessionState = { pageFrame: "dailyNotes",focusId: null,scroll: 0,position: null }
let dragSelectStartBlock = null
let dragSelect = null
let clipboardData = null
const SEARCH_RESULT_LENGTH = 12
// Singleton elements
const pageFrame = document.getElementById("page-frame")
const pageFrameOuter = document.getElementById("page-frame-outer")
const searchInput = document.getElementById("search-input")
const downloadButton = document.getElementById("download-button")
const terminalElement = document.getElementById("terminal")
const searchResultList = document.getElementById("search-result-list")
searchResultList.dataset.templateName = "search-result"
const autocompleteList = document.getElementById("autocomplete-list")
autocompleteList.dataset.templateName = "autocomplete__suggestion"
const templateList = document.getElementById("template-list")
templateList.dataset.templateName = "template__suggestion"
const switchToLogin = document.getElementById("switch-to-login")
const switchToSignup = document.getElementById("switch-to-signup")
const signupElement = document.getElementById("signup")
const signupButton = document.getElementById("signup-button")
const loginElement = document.getElementById("login")
const getTemp = (str) => document.getElementById(str).content.firstElementChild
// Templates
const pageTemplate = getTemp("page")
const blockTemplate = getTemp("block")
const backrefListTemplate = getTemp("backref-list")
const blockFocusFrameTemplate = getTemp("block-focus-frame")
const pageBreakTemplate = getTemp("page-break")
const suggestionTemplate = getTemp("autocomplete__suggestion")
const searchResultTemplate = getTemp("search-result")
const templateSuggestionTemplate = getTemp("template__suggestion")
const breadcrumbBlockTemplate = getTemp("breadcrumb-block")
const breadcrumbPageTemplate = getTemp("breadcrumb-page")
const backrefFrameTemplate = getTemp("backref-frame")
const notificationTemplate = getTemp("notification")
// Block parsing Templates
const pageRefTemplate = getTemp("page-ref")
// login/signup
const loginForm = document.getElementById("login-form")
const loginEmailElement = document.getElementById("login-email")
const loginPasswordElement = document.getElementById("login-password")
const signupForm = document.getElementById("signup-form")
const signupUsernameElement = document.getElementById("signup-username")
const signupEmailElement = document.getElementById("signup-email")
const signupPasswordElement = document.getElementById("signup-password")
// de-OOP-ing apis
const textEncoder = new TextEncoder()
const BTREE_FAN_BITS = 6
const examplebtree = [{ k: 6,l: [{ k: 3,v: "value" },{}] }]
const makeSortedMap = () => []
const updateSortedMap = () => {
}
const deleteSortedMap = () => {
}
const testSortedMap = () => {
}
const bisect = (arr,val) => {
let len = arr.length
let top = arr[len - 1]
let bottom = arr[0]
while (top > bottom) {
const mid = (top + bottom) / 2
}
}
const linsearch = (arr,val) => {
for (let i = 0; i < arr.length; i++) {
const v = arr[i]
if (val >= v) {
return v
}
}
}
const rands = [...Array(1000000)].map(x => Math.random())
const sorted64 = [...Array(128).keys()]
const zstime = performance.now()
for (let i = 0; i < 1000000; i++) {
sorted64.indexOf(Math.floor(rands[i] * 128))
}
console.log(`indexof took ${performance.now() - zstime}`)
// deepcopy for JSON-ifiables, but faster than JSON.parse . JSON.stringify
const cpy = (x) => {
if (typeof x === "object") {
if (x instanceof Array) {
return x.map(cpy)
} else {
const result = {}
for (let key in x) {
result[key] = cpy(x[key])
}
return result
}
} else return x
}
const monthNames = [
"January",
"February",
"March",
"April",
"May",
"June",
"July",
"August",
"September",
"October",
"November",
"December",
]
const getOrdinal = (i) => {
const j = i % 10,
k = i % 100
if (j == 1 && k != 11) return i + "st"
if (j == 2 && k != 12) return i + "nd"
if (j == 3 && k != 13) return i + "rd"
return i + "th"
}
const formatDate = (date) =>
`${monthNames[date.getMonth()]} ${getOrdinal(
date.getDate()
)}, ${date.getFullYear()}`
const unFormatDate = (string) => {
const match = string.match(/([a-zA-Z]+) ([0-9]{1,2})(?:st|nd|rd|th), ([0-9]{4})/)
if (match && monthNames.includes(match[1])) {
return new Date()
}
}
// const formatDateId = (date) => `${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`
const formatDateYMD = (date) => `${date.getFullYear()}-${formatInt(date.getMonth() + 1,2)}-${formatInt(date.getDate(),2)}`
const truncateElipsis = (text,limit = 40) => {
if (text.length > limit) {
return text.substring(0,limit - 3) + "..."
}
return text
}
const formatInt = (int,digits) => {
const raw = int.toString()
return ("0".repeat(digits - raw.length) + raw)
}
const clamp = (x,min,max) => Math.max(min,Math.min(x,max))
/*
Paralel difs are too much work. Switching to simpler single command buffer
I feel like I had a specification for diffs, but I seem to have lost it.
{d:string,i:string,s:number}
d: string to delete backwards (keep string instead of length so it's reversible)
i: string to insert forwards
s: position. defaults to end of string
["cr"|"dl"|"df"|"mv", ]
*/
const applyDif = (string,dif) => {
// not using dif.s||result.length because dif.s could be 0
let end = string.length
if (dif.s !== undefined) end = dif.s
const start = end - (((dif.d !== undefined) && dif.d.length) || 0)
return string.substring(0,start) + (dif.i || "") + string.substring(end)
}
const unapplyDif = (string,dif) => {
const dLen = (((dif.d !== undefined) && dif.d.length) || 0)
const iLen = (((dif.i !== undefined) && dif.i.length) || 0)
if (dif.s !== undefined) {
const start = dif.s - dLen
const end = start + iLen
return string.substring(0,start) + (dif.d || "") + string.substring(end)
} else {
const start = string.length - dLen - iLen
return string.substring(0,start) + (dif.d || "")
}
}
const diff = (string,oldString) => { // todo real diff
return { d: oldString,i: string }
}
let edits = []
let editsSessionStates = []
let activeEdits = []
const undoEdit = () => {
const time = Date.now()
const commit = edits.pop()
sessionState = editsSessionStates.pop()
print(commit)
// console.log(edit)
for (let i = commit.edits.length - 1; i >= 0; i--) {
const edit = commit.edits[i]
const [op,id,p1,p2,p3,p4] = edit
switch (op) {
case "cr":
const parent = store.blox[id].p
if (parent) {
store.blox[parent].k = store.blox[parent].k.filter(x => x !== id)
}
delete store.blox[id]
break
case "dl":
store.blox[id] = p1
const parentId = p1.p,idx = p2
if (parentId) {
if (!store.blox[parentId].k) store.blox[parentId].k = []
if (idx) {
store.blox[parentId].k.splice(idx,0,id)
} else {
store.blox[parentId].k.push(id)
}
}
break
case "mv":
const oldParent = p1,oidx = p2,newParent = p3,nidx = p4
const block = store.blox[id]
store.blox[oldParent].k = store.blox[oldParent].k.filter(x => x != id)
block.p = newParent
if (!store.blox[newParent].k) store.blox[newParent].k = []
store.blox[newParent].k.splice(nidx,0,id)
break
case "df":
const df = p1
const bloc = store.blox[id]
bloc.et = time
if (!bloc.p) delete store.titles[bloc.s]
bloc.s = unapplyDif(bloc.s,df)
if (!bloc.p) store.titles[bloc.s] = id
break
}
}
}
const doEditCacheStuff = (edit) => {
const [op,id,p1,p2,p3,p4] = edit
switch (op) {
case 'dl':
if (!p1.p) {
delete store.titles[p1.s]
}
const refsOut = store.forwardRefs[id]
if (refsOut) {
for (let ref of refsOut) {
const backRefs = store.refs[ref]
if (backRefs.length === 1) {
delete store.refs[ref]
} else {
store.refs[ref] = backRefs.filter(x => x != id)
}
}
}
const refsIn = store.refs[id]
if (refsIn) {
// todo turn refs to dead pages into plaintext
}
break
case 'df':
setLinks(id)
break
}
}
const doEditBlox = (edit,time) => {
const [op,id,p1,p2,p3,p4] = edit
switch (op) {
case "dl":
const parent = store.blox[id].p
if (parent) {
store.blox[parent].k = store.blox[parent].k.filter(x => x !== id)
}
delete store.blox[id]
break
case "cr":
store.blox[id] = {
ct: time,
s: ""
}
const parentId = p1,idx = p2
if (parentId) {
store.blox[id].p = parentId
if (!store.blox[parentId].k) store.blox[parentId].k = []
if (idx) {
store.blox[parentId].k.splice(idx,0,id)
} else {
store.blox[parentId].k.push(id)
}
}
break
case "mv":
const newParent = p1,nidx = p2,oldParent = p3
const block = store.blox[id]
store.blox[oldParent].k = store.blox[oldParent].k.filter(x => x != id)
block.p = newParent
if (!store.blox[newParent].k) store.blox[newParent].k = []
store.blox[newParent].k.splice(nidx,0,id)
break
case "df":
const df = p1
const bloc = store.blox[id]
bloc.et = time
if (!bloc.p) delete store.titles[bloc.s] // todo move this to cacheStuff, but need access to before & after there
bloc.s = applyDif(bloc.s,df)
if (!bloc.p) store.titles[bloc.s] = id
break
}
}
const doEdit = (...edit) => {
const time = Date.now()
activeEdits.push(edit)
print(edit)
// console.log(edit)
doEditBlox(edit,time)
doEditCacheStuff(edit)
}
const commit = () => {
const newId = newUUID()
edits.push({ id: newId,t: Date.now(),edits: activeEdits })
editsSessionStates.push(cpy(sessionState))
store.commitId = newId
user.settings.commitId = newId
activeEdits = []
setTimeout(() => {
debouncedSaveStore()
saveUser()
},0)
}
const commitEdit = (...edit) => {
doEdit(...edit)
commit()
}
const LOCAL_STORAGE_MAX = 4500000
const saveStore = () => {
// stringify blox, then stringify rest of store and insert blox string to avoid re-stringifying blox
const blox = store.blox
const bloxText = JSON.stringify(blox)
let fullString = "{"
for (let key in store) {
if (key !== 'blox' && store[key] !== undefined)
fullString += '"' + key + '":' + JSON.stringify(store[key]) + ","
}
fullString += '"blox":' + bloxText + '}'
saveStoreToBasicBitchServer(bloxText)
try {
localStorage.setItem('store',fullString)
} catch (e) {
// mainly catch localstorage size limit
localStorage.removeItem('store')
}
const transaction = idb.transaction(["stores"],"readwrite")
const storeStore = transaction.objectStore("stores")
const req = storeStore.put({
graphName: store.graphName,
store: fullString
})
req.onsuccess = () => {
console.log("saved")
}
req.onerror = (event) => {
console.log("save error")
console.log(event)
}
}
let saveStoreTimeout = null
const debouncedSaveStore = () => {
if (user.settings.commitId !== user.settings.syncCommitId) {
clearTimeout(saveStoreTimeout)
saveStoreTimeout = setTimeout(saveStore,300)
}
}
const print = (text) => {
if (user.logging) {
console.log(text)
}
}
const CHARS_64 = "-_0123456789abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ"
const CHARS_16 = "0123456789ABCDEF"
const newUid = () => {
let values = new Uint8Array(9)
let result
do {
crypto.getRandomValues(values)
result = ""
for (let i = 0; i < 9; i++) {
result += CHARS_64[values[i] % 64]
}
} while (store.blox[result] !== undefined)
return result
}
// I'm using base64 126 bit UUIDs instead because they're less length in JSON and they are more ergonomic to write in markup like ((uuid)) if I ever want to do that
const newUUID = () => { // this is 126 bits, 21xbase64
let values = new Uint8Array(21)
crypto.getRandomValues(values)
let result = ""
for (let i = 0; i < 21; i++) {
result += CHARS_64[values[i] % 64]
}
return result
}
const macros = {}
macros.nocommit = {
copyBlock: (oldId,parentId,idx) => {
// todo make this stop infinite looping when you copy a block into its own children using snapshots when I get those
const copyBlock = (oldId,parentId,idx) => {
const newId = newUid()
const block = store.blox[oldId]
console.log(`copying block ${block.s}`)
doEdit("cr",newId,parentId,idx)
doEdit("df",newId,diff(block.s,""))
if (block.k) {
for (let i = 0; i < block.k.length; i++) {
const kidId = block.k[i]
copyBlock(kidId,newId,i)
}
}
return newId
}
return copyBlock(oldId,parentId,idx)
},
delete: (id) => {
const bloc = store.blox[id]
let idx = undefined
if (bloc.p) idx = store.blox[bloc.p].k.indexOf(id)
doEdit("dl",id,cpy(bloc),idx)
},
write: (id,string) => {
doEdit("df",id,diff(string,store.blox[id].s))
},
createPage: (title) => {
const id = newUid()
doEdit("cr",id)
doEdit("df",id,diff(title,""))
return id
},
move: (id,parentId,idx) => {
const bloc = store.blox[id]
doEdit("mv",id,parentId,idx,bloc.p,store.blox[bloc.p].k.indexOf(id))
}
}
for (let k in macros.nocommit) {
macros[k] = (...args) => {
const result = macros.nocommit[k](...args)
commit()
return result
}
}
// blox or bloc means either block or page. they're almost the same, just one has a parent and the other doesn't, and linking syntax is different
const blankStore = () => ({
blox: {},
titles: {},
refs: {},
innerRefs: {},
outerRefs: {},
roamProps: {},
ownerRoamId: undefined,
graphName: undefined,
})
const bloxProps = [
"s",  // string
"p",  // parent
"i",  // child idx
"ct", // create time
"et", // edit time
"cu", // create user
"eu"  // edit user
]
const roamBloxProps = {
children: "k",
string: "s",
title: "s",
"create-time": "ct",
"edit-time": "et",
":create/user": "cu",
":edit/user": "eu",
"uid": "uid",
"refs": "",
":block/refs": "",
}
const roamJsonToStore = (graphName,text) => {
console.log("roamJsontostore")
const stime = performance.now()
const now = Date.now()
const obj = JSON.parse(text)
store = blankStore()
store.graphName = graphName
// todo interface with roam user ids well
if (obj[0][":edit/user"]) store.ownerRoamId = obj[0][":edit/user"][":user/uid"]
ownerRoamId = store.ownerRoamId
const addBlock = (block,parent) => {
const newBlock = {
s: block.string,
p: parent,
ct: now,
}
store.blox[block.uid] = newBlock
// discard edit/user if it's the same as create/user to save space
if (block[":create/user"] && block[":create/user"][":user/uid"] !== ownerRoamId)
newBlock.cu = block[":create/user"][":user/uid"]
else delete newBlock.cu
if (block[":edit/user"] && block[":edit/user"][":user/uid"] !== ownerRoamId)
newBlock.eu = block[":edit/user"][":user/uid"]
else delete newBlock.eu
if (block.children) {
newBlock.k = block.children.map(child => child.uid)
block.children.forEach((child) => addBlock(child,block.uid))
}
for (let prop in block) {
if (prop in roamBloxProps) { } else {
if (!store.roamProps[block.uid]) store.roamProps[block.uid] = {}
store.roamProps[block.uid][prop] = block[prop]
}
}
}
for (let page of obj) {
store.titles[page.title] = page.uid
const newPage = {
s: page.title,
ct: now,
}
store.blox[page.uid] = newPage
for (let prop in page) {
if (prop in roamBloxProps) { } else {
if (!store.roamProps[page.uid]) store.roamProps[page.uid] = {}
store.roamProps[page.uid][prop] = page[prop]
}
}
if (page[":create/user"] && page[":create/user"][":user/uid"] !== ownerRoamId)
newPage.cu = page[":create/user"][":user/uid"]
else {
delete newPage.cu
}
if (page[":edit/user"] && page[":edit/user"][":user/uid"] !== ownerRoamId) {
newPage.eu = page[":edit/user"][":user/uid"]
} else {
delete newPage.eu
}
if (page.children !== undefined) {
const kids = []
newPage.k = kids
for (let i = 0; i < page.children.length; i++) {
const child = page.children[i]
kids.push(child.uid)
addBlock(child,page.uid)
}
}
}
generateRefs()
store.commitId = "MYVERYFIRSTCOMMITEVER"
user.settings.commitId = store.commitId
console.log(`roamJsonToStore took ${performance.now() - stime}`)
console.log(store)
return store
}
const gcPage = (pageId) => {
const page = store.blox[pageId]
const refs = store.refs[pageId]
if ((page.k === undefined || page.k.length === 0) && (refs === undefined || refs.length === 0)) {
macros.nocommit.delete(pageId)
}
}
// 1             2              3   4         5         6       7
// page-ref-open page-ref-close tag block-ref attribute literal code-block
const parseRegexJustLinks = /(\[\[)|(\]\])|#([\/a-zA-Z0-9_-]+)|\(\(([a-zA-Z0-9\-_]+)\)\)|(^[\/a-zA-Z0-9_-]+)::|`([^`]+)`|```/g
const setLinks = (blocId) => {
for (let ref of store.forwardRefs[blocId] || []) {
store.refs[ref] = store.refs[ref].filter(x => x !== blocId)
gcPage(ref)
}
const forwardRefs = []
store.forwardRefs[blocId] = forwardRefs
const doRef = (ref) => {
if (ref in store.refs) store.refs[ref].push(blocId)
else store.refs[ref] = [blocId]
forwardRefs.push(ref)
}
const doTitle = (title) => {
let ref = store.titles[title]
if (ref === undefined) {
ref = macros.nocommit.createPage(title) // todo manage the commit on this one. Need some standard for when to commit / when to do
}
doRef(ref)
}
const bloc = store.blox[blocId]
const text = bloc.s
const matches = text.matchAll(parseRegexJustLinks)
// Roam allows like whatevs in the tags and attributes. I only allow a few select chars.
let idx = 0
let stackTop = undefined // s is string, t is type
let stack = []
for (let match of matches) {
if (stack.length === 0 || stackTop.t === "cb") {
if (match[1]) {
const pageRefElement = { t: "pr",s: "" }
stack.push(pageRefElement)
stackTop = stack[stack.length - 1]
} else if (match[3]) {
doTitle(match[3])
} else if (match[5]) {
doTitle(match[5])
} else if (match[4]) {
doRef(match[4])
} else if (match[7]) {
if (stackTop && stackTop.t === "cb") {
stack.pop()
} else {
const codeBlockElement = { t: 'cb',s: "" }
stack.push(codeBlockElement)
stackTop = stack[stack.length - 1]
}
}
} else {
stackTop.s = stackTop.s + text.substring(idx,match.index)
idx = match.index
if (match[1]) {
const pageRefElement = { t: "pr",s: "" }
stackTop.s = stackTop.s + "[["
stack.push(pageRefElement)
stackTop = stack[stack.length - 1]
} else if (match[2]) {
let s = "]]"
if (stackTop.t === "pr") {
s = stackTop.s + "]]"
doTitle([stackTop.s])
stack.pop()
stackTop = stack[stack.length - 1]
}
if (stackTop !== undefined) stackTop.s = stackTop.s + s
} else if (match[3]) {
doTitle(match[3])
stackTop.s = stackTop.s + match[0]
} else if (match[5]) {
stackTop.s = stackTop.s + match[0]
const ref = store.titles[match[5]]
doTitle(match[5])
} else if (match[4]) {
doRef(match[4])
stackTop.s = stackTop.s + match[0]
} else if (match[7]) {
if (stackTop && stackTop.t === "cb") {
stack.pop()
} else {
const codeBlockElement = { t: 'cb',s: "" }
stack.push(codeBlockElement)
stackTop = stack[stack.length - 1]
}
} else {
stackTop.s = stackTop.s + match[0]
}
}
idx = match.index + match[0].length
}
if (forwardRefs.length === 0) delete store.forwardRefs[blocId]
}
const generateRefs = () => {
const stime = performance.now()
if (store.refs === undefined) store.refs = {}
if (store.forwardRefs === undefined) store.forwardRefs = {}
for (let blocId in store.blox) {
setLinks(blocId)
}
console.log(`gen refs took ${performance.now() - stime}`)
return store
}
const mergeLists = (list1,list2) => {
for (let x of list2) {
if (!list1.includes(x)) list1.push(x)
}
}
// inner refs are refs in a page/block and any pages/blocks within it
const generateInnerRefs = () => {
// algorithm: for each ref anywhere, add it to each of its parent's uprefs
const stime = performance.now()
store.innerRefs = {}
for (let blocId in store.forwardRefs) {
const refs = store.forwardRefs[blocId]
let id = blocId
while (id) {
if (!store.innerRefs[id]) store.innerRefs[id] = []
mergeLists(store.innerRefs[id],refs)
id = store.blox[id].p
}
}
console.log(`innerrefs took ${performance.now() - stime}`)
}
// outer refs are refs in a block / page and each block/page in its ancestry
const generateOuterRefs = () => {
const stime = performance.now()
store.outerRefs = {}
for (let blocId in store.forwardRefs) {
const refs = store.forwardRefs[blocId]
const fn = (id) => {
if (!store.outerRefs[id]) store.outerRefs[id] = []
mergeLists(store.outerRefs[id],refs)
for (let cid of store.blox[id].k || []) {
fn(cid)
}
}
fn(blocId)
}
console.log(`outerrefs took ${performance.now() - stime}`)
}
const generateInnerOuterRefs = () => {
generateInnerRefs()
generateOuterRefs()
}
const mergeStore = (otherStore) => {
// merge pages by title, adding all blocks to the end
// if the new store has a block with the same id, give it a new id
const idTranslation = {}
for (let blocId in otherStore.blox) {
const bloc = otherStore.blox[blocId]
if (!store.titles[bloc.s]) {
idTranslation[blocId] = store.titles[bloc.s]
} else if (store.blox[blocId]) {
idTranslation[blocId] = newUid()
}
}
const transferBlock = (blockId,parentId) => {
const newBlockId = idTranslation[blockId] || blockId
const block = otherStore.blox[blockId]
const newBlock = {
...block
}
store.blox[newBlockId] = newBlock
newBlock.p = parentId
if (block.k) {
newBlock.k = []
for (let childId of block.k) {
let newChildId = idTranslation[childId] || childId
transferBlock(childId,newBlockId)
newBlock.k.push(newChildId)
}
}
}
for (let title in otherStore.titles) {
const pageId = otherStore.titles[title]
const page = otherStore.blox[pageId]
if (store.titles[page.s] === undefined) {
const newPageId = idTranslation(pageId) || pageId
const newPage = {
...page
}
store.blox[newPageId] = newPage
store.titles[page.s] = newPageId
if (page.k) {
newPage.k = []
for (let blockId of kids) {
const newBlockId = getNewId(blockId)
transferBlock(blockId,newPageId)
newPage.k.push(newBlockId)
}
}
} else if (page.k) {
const newPageId = store.titles[page.s]
const existingPage = store.blox[newPageId]
if (!existingPage.k) {
existingPage.k = []
}
for (let childId of page.k) {
const newChildId = idTranslation[childId] || childId
transferBlock(childId,newPageId)
existingPage.k.push(newChildId)
}
}
}
}
// search
const escapeRegex = (string) => string.replaceAll(/([\[\]\(\)])/g,"\\$1").replaceAll("\\\\","")
const searchRefCountWeight = 0.05
const pageOverBlockWeight = 1
let titleExactFullTextSearchCache = []
const titleExactFullTextSearch = (string) => {
const regex = new RegExp(escapeRegex(string),"i")
titleExactFullTextSearchCache = []
for (let title in store.titles) {
const id = store.titles[title]
const page = store.blox[id]
const match = title.match(regex)
if (match) {
titleExactFullTextSearchCache.push({
title,
id,
idx: match.index - (store.refs[id] ? store.refs[id].length : 0) * searchRefCountWeight
})
}
}
titleExactFullTextSearchCache.sort((a,b) => a.idx - b.idx)
return titleExactFullTextSearchCache
}
let exactFullTextSearchCache = []
const exactFullTextSearch = (string) => {
const regex = new RegExp(escapeRegex(string),"i")
exactFullTextSearchCache = []
for (let id in store.blox) {
const bloc = store.blox[id]
const string = bloc.s
const match = string.match(regex)
if (match) {
const matchObj = {
id,
idx: match.index - (store.refs[id] ? store.refs[id].length : 0) * searchRefCountWeight - (bloc.p === undefined) * pageOverBlockWeight
}
if (bloc.p) matchObj.string = bloc.s
else matchObj.title = bloc.s
exactFullTextSearchCache.push(matchObj)
}
}
exactFullTextSearchCache.sort((a,b) => a.idx - b.idx)
return exactFullTextSearchCache
}
let templateSearchCache = []
const searchTemplates = (string) => {
const templatePageId = store.titles["roam/templates"]
const templatePage = store.blox[templatePageId]
templateSearchCache = []
if (templatePage) {
const fn = (blockId) => {
const block = store.blox[blockId]
console.log(block.s)
const match = block.s.match(/^([^ \r\n]+)/)
console.log(match)
if (match) {
if (match[1].length >= string.length && match[1].substring(0,string.length).toLowerCase() === string.toLowerCase()) {
templateSearchCache.push({
id: blockId,
string: match[1]
})
}
}
}
if (store.refs[templatePageId]) {
for (let backref of store.refs[templatePageId])
fn(backref)
}
if (store.blox[templatePageId].k) {
for (let blockId of store.blox[templatePageId].k)
fn(blockId)
}
}
return templateSearchCache
}
const hydrateFromBlox = (graphName,blox) => {
store = blankStore()
store.blox = blox
store.graphName = graphName
for (let id in blox) {
const bloc = blox[id]
if (bloc.p === undefined) store.titles[bloc.s] = id
}
generateRefs()
}
const storeToRoamJSON = (store) => {
const roamJSON = []
const blockIdToJSON = (blockId) => {
const block = store.blox[blockId]
const result = { uid: blockId,string: block.s,"create-time": block.ct,"edit-time": block.et }
const roamProps = store.roamProps[blockId]
if (roamProps) Object.assign(result,roamProps)
if (block.k) result.children = block.k.map(blockIdToJSON)
result[":create/user"] = { ":user/uid": store.ownerRoamId }
result[":edit/user"] = { ":user/uid": store.ownerRoamId }
if (block.cu)
result[":create/user"] = { ":user/uid": block.cu }
if (block.eu)
result[":edit/user"] = { ":user/uid": block.eu }
return result
}
for (let title in store.titles) {
const pageId = store.titles[title]
const page = store.blox[pageId]
const roamProps = store.roamProps[pageId]
const jsonPage = { uid: pageId,title: page.s,"edit-time": page.et,"create-time": page.ct }
roamJSON.push(jsonPage)
Object.assign(jsonPage,roamProps)
if (page.k) {
jsonPage.children = page.k.map(blockIdToJSON)
}
jsonPage[":create/user"] = { ":user/uid": store.ownerRoamId }
jsonPage[":edit/user"] = { ":user/uid": store.ownerRoamId }
if (page[":create/user"])
jsonPage[":create/user"] = { ":user/uid": page[":create/user"] }
if (page[":edit/user"])
jsonPage[":edit/user"] = { ":user/uid": page[":edit/user"] }
}
console.log(roamJSON)
return JSON.stringify(roamJSON)
}
const oldStoreToRoamJSON = {
4: (store) => {
const roamJSON = []
const blockIdToJSON = (blockId) => {
const result = { uid: blockId }
const block = store.blocks[blockId]
Object.assign(result,block)
if (block.children) result.children = block.children.map(blockIdToJSON)
result[":create/user"] = { ":user/uid": store.ownerRoamId }
result[":edit/user"] = { ":user/uid": store.ownerRoamId }
if (block[":create/user"])
result[":create/user"] = { ":user/uid": block[":create/user"] }
if (block[":edit/user"])
result[":edit/user"] = { ":user/uid": block[":edit/user"] }
if (block.refs) result.refs = block.refs.map(x => ({ uid: x }))
if (block[":block/refs"]) result[":block/refs"] = block[":block/refs"].map(x => ({ ":block/uid": x }))
delete result.backRefs
delete result.parent
return result
}
for (let pageId in store.pages) {
const page = store.pages[pageId]
const jsonPage = { uid: pageId }
roamJSON.push(jsonPage)
Object.assign(jsonPage,page)
delete jsonPage.backRefs
if (page.children) {
jsonPage.children = page.children.map(blockIdToJSON)
}
jsonPage[":create/user"] = { ":user/uid": store.ownerRoamId }
jsonPage[":edit/user"] = { ":user/uid": store.ownerRoamId }
if (page[":create/user"])
jsonPage[":create/user"] = { ":user/uid": page[":create/user"] }
if (page[":edit/user"])
jsonPage[":edit/user"] = { ":user/uid": page[":edit/user"] }
}
console.log(roamJSON)
return JSON.stringify(roamJSON)
}
}
const renderPage = (parentNode,uid) => {
const page = store.blox[uid]
const element = pageTemplate.cloneNode(true)
const title = element.firstElementChild
const body = element.children[1]
body.dataset.id = uid
element.dataset.id = uid
if (page.s === undefined) {
throw new Error(`error with page id ${uid}`)
}
title.innerText = page.s
let children = page.k
if (!children || children.length === 0) { // todo set standards for when lists can be empty to reduce ambiguity
const newId = newUid()
commitEdit("cr",newId,uid,0)
children = page.k
}
for (let child of children) {
renderBlock(body,child)
}
const refs = store.refs[uid]
if (refs && refs.length > 0) {
const backrefsListElement = backrefListTemplate.cloneNode(true)
element.children[2].appendChild(backrefsListElement)
refs.sort((a,b) => store.blox[b].et - store.blox[a].et)
for (let backref of refs) {
const backrefFrame = backrefFrameTemplate.cloneNode(true)
renderBreadcrumb(backrefFrame.children[0],backref)
renderBlock(backrefFrame.children[1],backref)
backrefsListElement.children[1].appendChild(backrefFrame)
}
}
parentNode.appendChild(element)
return element
}
const renderBlock = (parentNode,uid,idx) => {
const element = blockTemplate.cloneNode(true)
const body = element.children[1]
const childrenContainer = element.children[2]
element.dataset.id = uid
childrenContainer.dataset.id = uid
body.dataset.id = uid
const string = store.blox[uid].s
renderBlockBody(body,string)
const children = store.blox[uid].k
for (let child of children || []) {
renderBlock(childrenContainer,child)
}
if (idx !== undefined && parentNode.children.length >= idx) {
parentNode.insertBefore(element,parentNode.children[idx])
} else {
parentNode.appendChild(element)
}
return element
}
const renderBreadcrumb = (parent,blockId) => {
const list = []
if (store.blox[blockId].p) {
while (true) {
blockId = store.blox[blockId].p
if (store.blox[blockId].p) {
list.push({ string: store.blox[blockId].s,id: blockId })
} else {
list.push({ title: store.blox[blockId].s,id: blockId })
break
}
}
const node = breadcrumbPageTemplate.cloneNode(true)
const title = list[list.length - 1].title
renderBlockBody(node,title)
node.dataset.title = title
parent.appendChild(node)
for (let i = list.length - 2; i >= 0; i--) {
const node = breadcrumbBlockTemplate.cloneNode(true)
const nodeBody = node.children[1]
renderBlockBody(nodeBody,list[i].string,true)
node.dataset.id = list[i].id
parent.appendChild(node)
}
}
}
const renderResultSet = (parent,resultSet,resultFrame,startIdx = 0) => {
const resultTemplate = getTemp(resultFrame.dataset.templateName)
if (resultSet.length > 0) {
resultFrame.innerHTML = ""
resultFrame.style.display = "block"
const rect = parent.getBoundingClientRect()
resultFrame.style.top = rect.bottom
resultFrame.style.left = rect.left
resultFrame.dataset.resultStartIdx = startIdx
const resultLength = Math.min(resultSet.length,startIdx + SEARCH_RESULT_LENGTH)
for (let i = startIdx; i < resultLength; i++) {
matchingTitle = resultSet[i]
const suggestion = resultTemplate.cloneNode(true)
if (i == startIdx) suggestion.dataset.selected = "true"
suggestion.dataset.id = matchingTitle.id
if (matchingTitle.title) {
suggestion.dataset.title = matchingTitle.title
suggestion.innerText = truncateElipsis(matchingTitle.title,50)
} else {
suggestion.dataset.string = matchingTitle.string
suggestion.innerText = truncateElipsis(matchingTitle.string,50)
}
resultFrame.appendChild(suggestion)
}
}
}
const notifyText = (text,duration) => {
const el = notificationTemplate.cloneNode(true)
el.innerText = text
document.getElementById("app").appendChild(el)
setTimeout(() => el.style.top = "60px",50)
const dur = (duration && duration * 1000) || 5000
setTimeout(() => el.style.opacity = "0",dur)
setTimeout(() => {
el.remove()
},dur + 300)
}
// 1             2              3   4         5    6         7      8    9       10                11        12
// page-ref-open page-ref-close tag block-ref bold highlight italic link literal template-expander attribute code-block
const parseRegex = /(\[\[)|(\]\])|#([\/a-zA-Z0-9_-]+)|\(\(([a-zA-Z0-9\-_]+)\)\)|(\*\*)|(\^\^)|(__)|((?:https?\:\/\/)(?:[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*))|`([^`]+)`|;;([^ \n\r]+)|(^[\/a-zA-Z0-9_-]+)::|(```)/g
const renderBlockBody = (parent,text,disableSpace = false) => {
if (!disableSpace) {
if (text[text.length - 1] !== " ") text += " " // add space because of getSelection.collapse() weirdness with end of contenteditable
}
const stack = [parent]
const matches = text.matchAll(parseRegex)
// Roam allows like whatevs in the tags and attributes. I only allow a few select chars.
let idx = 0
let stackTop = parent
const newTextNode = (string) => {
const result = document.createTextNode(string)
result.startIdx = idx
result.endIdx = idx + string.length
return result
}
const refTitles = []
for (let match of matches) {
stackTop.appendChild(newTextNode(text.substring(idx,match.index)))
idx = match.index
if (match[1]) {
const pageRefElement = pageRefTemplate.cloneNode(true)
stackTop.appendChild(pageRefElement)
pageRefElement.children[0].appendChild(newTextNode("[["))
stack.push(pageRefElement.children[1])
stackTop = stack[stack.length - 1]
} else if (match[2]) {
if (stackTop.className === "page-ref__body") {
stackTop.parentNode.children[2].appendChild(newTextNode("]]"))
refTitles.push(stackTop.s)
stack.pop()
stackTop = stack[stack.length - 1]
} else {
const el = document.createElement("span")
el.className = "page-ref-close-missing-open"
el.appendChild(newTextNode("]]"))
stackTop.appendChild(el)
}
} else if (match[3]) {
refTitles.push(match[3])
const tagElement = document.createElement('span')
tagElement.className = "tag"
tagElement.appendChild(newTextNode(match[0]))
stackTop.appendChild(tagElement)
} else if (match[4]) {
const blockId = match[4]
const block = store.blox[blockId]
if (block) {
const blockRefElement = document.createElement('span')
blockRefElement.className = 'block-ref'
blockRefElement.innerText = block.s
blockRefElement.dataset.id = blockId
stackTop.appendChild(blockRefElement)
} else {
stackTop.appendChild(newTextNode(match[0]))
}
} else if (match[5]) {
if (stackTop.className === "bold") {
stackTop.appendChild(newTextNode("**"))
stack.pop()
stackTop = stack[stack.length - 1]
} else {
const boldElement = document.createElement('span')
boldElement.className = 'bold'
stackTop.appendChild(boldElement)
boldElement.appendChild(newTextNode("**"))
stack.push(boldElement)
stackTop = boldElement
}
} else if (match[6]) {
if (stackTop.className === "highlight") {
stackTop.appendChild(newTextNode("^^"))
stack.pop()
stackTop = stack[stack.length - 1]
} else {
const highlightElement = document.createElement('span')
highlightElement.className = 'highlight'
stackTop.appendChild(highlightElement)
highlightElement.appendChild(newTextNode("^^"))
stack.push(highlightElement)
stackTop = highlightElement
}
} else if (match[7]) {
if (stackTop.className === "italic") {
stackTop.appendChild(newTextNode("__"))
stack.pop()
stackTop = stack[stack.length - 1]
} else {
const italicElement = document.createElement('span')
italicElement.className = 'italic'
stackTop.appendChild(italicElement)
italicElement.appendChild(newTextNode("__"))
stack.push(italicElement)
stackTop = italicElement
}
} else if (match[8]) {
const urlElement = document.createElement('span')
urlElement.className = 'url'
urlElement.appendChild(newTextNode(match[0]))
urlElement.href = match[8]
stackTop.appendChild(urlElement)
} else if (match[9]) {
const literalElement = document.createElement('span')
literalElement.className = 'literal'
literalElement.appendChild(newTextNode(match[0]))
stackTop.appendChild(literalElement)
} else if (match[10]) {
const templateExpanderElement = document.createElement('span')
templateExpanderElement.className = 'template-expander'
templateExpanderElement.appendChild(newTextNode(match[0]))
stackTop.appendChild(templateExpanderElement)
} else if (match[11]) {
const attributeElement = document.createElement('span')
attributeElement.className = 'attribute'
attributeElement.appendChild(newTextNode(match[0]))
stackTop.appendChild(attributeElement)
} else if (match[12]) {
if (stackTop.className === "code-block") {
stackTop.appendChild(newTextNode(match[0]))
stack.pop()
stackTop = stack[stack.length - 1]
} else {
const codeBlockElement = document.createElement('div')
codeBlockElement.className = 'code-block'
codeBlockElement.appendChild(newTextNode(match[0]))
stackTop.appendChild(codeBlockElement)
stack.push(codeBlockElement)
stackTop = codeBlockElement
}
}
idx = match.index + match[0].length
}
stack[stack.length - 1].appendChild(newTextNode(text.substring(idx)))
/**
* PARSING REVELATION!!!!
* Instead of backtracking and deleting when a block doesn't close, I can just erase the className of the block. Then it's still part of the tree but looks like it's gone! much less performance cost than backtracking!!
*/
while (stackTop !== parent) {
if (stackTop.className === "page-ref")
stackTop.children[0].className = stackTop.children[0].className + "-incomplete"
stackTop.className = stackTop.className + "-incomplete"
stackTop = stackTop.parentNode
}
return refTitles
}
// API knowingly does not follow REST spec for CORS simplicity reasons
const saveStoreToBasicBitchServer = async (blox) => {
const putSentTime = performance.now()
const headers = new Headers()
headers.set('passwordhash',user.passwordHash)
const syncCommitId = user.settings.commitId
headers.set('commitid',syncCommitId)
headers.set('synccommitid',user.settings.syncCommitId)
const response = await fetch(`${basicBitchServerUrl}/put/${store.graphName}`,
{
method: "POST",body: blox,
headers
})
if (response.status === 200 || response.status === 304) {
user.settings.syncCommitId = syncCommitId
store.syncCommitId = syncCommitId
console.log(`save confirmed in ${performance.now() - putSentTime}`)
} else {
console.warn(`failed to save to server`)
}
}
const getStoreFromBasicBitchServer = async (graphName) => {
const getSentTime = performance.now()
const response = await fetch(`${basicBitchServerUrl}/get/${graphName}`,
{ headers: { passwordHash: user.passwordHash } })
switch (reponse.status) {
case 200:
const blox = await response.json()
hydrateFromBlox(graphName,blox)
console.log(`got in ${performance.now() - getSentTime}`)
break
default:
console.warn(`failed to get store`)
}
}
const saveSettingsToBasicBitchServer = async () => {
const headers = new Headers()
headers.set('passwordhash',user.passwordHash)
headers.set('body',JSON.stringify(user.settings))
const response = await fetch(`${basicBitchServerUrl}/settings`,
{ headers })
if (response.status !== 200) {
console.log("failed to save settings")
}
}
const middlePepper = "76pCgT0lW6ES9yjt01MeH"
const beginPepper = "CeoPPOv9rIq6O7YiYlSFX"
const endPepper = "Rzw1dagomQGpoo2s7iGE3lYL2yruaJDGrUk6bFCvz"
const hashPassword = async (password,email) => {
const saltAndPeppered = `${beginPepper}${password}${middlePepper}${email}${endPepper}`
const buffer = TextEncoder.encode(saltAndPeppered)
const hashed = await crypto.subtle.digest("SHA-512",buffer)
const passwordHashBuffer = new Uint8Array(hashed)
let passwordHash = ""
for (let i = 0; i < passwordHashBuffer.length; i++) {
passwordHash += String.fromCharCode(passwordHashBuffer[i])
}
passwordHash = btoa(passwordHash)
passwordHash = passwordHash.replaceAll("/","-").replaceAll("+","_").replaceAll("=","")
return passwordHash
}
loginForm.addEventListener("submit",async (event) => {
event.preventDefault()
const email = loginEmailElement.value
loginEmailElement.value = ""
const password = loginPasswordElement.value
loginPasswordElement.value = ""
const passwordHash = await hashPassword(password,email)
const response = await fetch(`${basicBitchServerUrl}/auth`,{ method: "POST",headers: { passwordHash: passwordHash } })
if (response.status === 200) {
user = await response.json()
saveUser()
invalidateLocal()
console.log(user)
} else {
notifyText("Don't know that username + password.")
}
})
signupForm.addEventListener("submit",async (event) => {
event.preventDefault()
const email = signupEmailElement.value
signupEmailElement.value = ""
const username = signupUsernameElement.value
signupUsernameElement.value = ""
const password = signupPasswordElement.value
signupPasswordElement.value = ""
const passwordHash = await hashPassword(password,email)
const jsonBody = JSON.stringify({ passwordHash,username,email,settings: user.settings })
console.log(jsonBody)
const headers = new Headers()
headers.set('body',jsonBody)
const response = await fetch(`${basicBitchServerUrl}/signup`,{ method: "POST",headers })
if (response.status === 200) {
console.log(response)
user = await response.json()
saveUser()
invalidateLocal()
console.log(`signed up`)
} else {
const responseText = await response.json()
notifyText(responseText)
}
})
const addGraph = async () => {
const headers = new Headers()
headers.set('passwordhash',user.passwordHash)
headers.set('commitid',user.settings.commitId)
const syncCommitId = user.settings.commitId
const response = await fetch(`${basicBitchServerUrl}/creategraph/${store.graphName}`,{ headers,method: 'POST',body: JSON.stringify(store.blox) })
if (!response.ok) {
notifyText("failed to add graph")
return
}
user.settings.syncCommitId = syncCommitId
store.syncCommitId = syncCommitId
}
// Event Listener Helpers -----------------------------------------------------------------------------------------------
const focusBlockEnd = (blockNode) => {
const body = blockNode.children[1]
const temp = document.createTextNode(" ")
body.appendChild(temp)
getSelection().collapse(temp,0)
temp.remove()
}
const focusBlockStart = (blockNode) => {
const body = blockNode.children[1]
const temp = document.createTextNode(" ")
body.insertBefore(temp,body.firstChild)
getSelection().collapse(temp,0)
temp.remove()
}
const focusBlockVerticalOffset = (offset,block = focusBlock,start = false) => { // this closure feels weird, maybe shoudn't use this language feature?
const blocks = Array.from(document.querySelectorAll(".block"))
const newActiveBlock = blocks[blocks.indexOf(block) + offset]
if (newActiveBlock) {
if (!start) {
focusBlockEnd(newActiveBlock)
} else {
focusBlockStart(newActiveBlock)
}
}
}
const getChildren = (node) => {
return node.className === "block" ? node.children[2].children : node.children[1].children
}
const downloadHandler = () => {
console.log("download")
const json = storeToRoamJSON(store)
const data = new Blob([json],{ type: 'text/json' })
const url = URL.createObjectURL(data)
downloadButton.setAttribute('href',url)
downloadButton.setAttribute('download',`${store.graphName}-${formatDateYMD(new Date(Date.now()))}.json`)
}
const downloadMd = () => {
console.log("download md")
const data = storeToMdZip()
const url = URL.createObjectURL(data)
const anchor = document.createElement("a")
anchor.setAttribute('href',url)
anchor.setAttribute('download',`${store.graphName}-md-${formatDateYMD(new Date(Date.now()))}.zip`)
anchor.click()
}
const expandTemplate = () => {
const id = focusSuggestion.dataset.id
const block = store.blox[sessionState.focusId]
if (block.children === undefined || block.children.length === 0) {
const parentId = store.blox[sessionState.focusId].p
const childIds = store.blox[id].k
const currentIdx = store.blox[parentId].k.indexOf(sessionState.focusId)
macros.nocommit.delete(sessionState.focusId,false)
const parentNode = focusBlock.parentNode
focusBlock.remove()
for (let i = 0; i < childIds.length; i++) {
const childId = childIds[i]
const idx = currentIdx + i
const newId = macros.nocommit.copyBlock(childId,parentId,idx)
const e = renderBlock(parentNode,newId,idx)
if (i === 0) {
focusBlockEnd(e)
}
}
commit()
} else
notifyText("can't use a template inside a block that has children")
templateList.style.display = "none"
}
const pasteBlocks = () => {
const block = store.blox[sessionState.focusId]
const parentId = block.p
let currentIdx = store.blox[parentId].k.indexOf(sessionState.focusId)
const parentNode = focusBlock.parentNode
if (focusBlockBody.innerText === "") {
macros.nocommit.delete(sessionState.focusId)
focusBlock.remove()
} else {
currentIdx += 1
}
if (clipboardData.dragSelect.rooted) {
const newId = macros.nocommit.copyBlock(clipboardData.dragSelect.root,parentId,currentIdx)
const e = renderBlock(parentNode,newId,currentIdx)
focusBlockEnd(e)
} else {
let lastNode = null
for (let i = 0; i < clipboardData.dragSelect.endIdx + 1 - clipboardData.dragSelect.startIdx; i++) {
const blockId = store.blox[clipboardData.dragSelect.root].k[i + clipboardData.dragSelect.startIdx]
const newId = macros.nocommit.copyBlock(blockId,parentId,i + currentIdx)
const e = renderBlock(parentNode,newId,i + currentIdx)
lastNode = e
}
focusBlockEnd(lastNode)
}
commit()
}
const autocomplete = () => {
const origString = store.blox[sessionState.focusId].s
if (editingLink.className === "tag") {
const textNode = editingLink.childNodes[0]
// check for the exact inverse of tag regex to see if this would be a valid tag, otherwise make it a ref  
if (/[^\/a-zA-Z0-9_-]/.test(focusSuggestion.dataset.title)) {
const string = origString.slice(0,textNode.startIdx) + "[[" + focusSuggestion.dataset.title + "]]" + origString.slice(textNode.endIdx)
sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 4
setFocusedBlockString(string)
} else {
const string = origString.slice(0,textNode.startIdx) + "#" + focusSuggestion.dataset.title + origString.slice(textNode.endIdx)
sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 1
setFocusedBlockString(string)
}
} else {
const textNode = editingLink.children[1].childNodes[0]
const string = origString.slice(0,textNode.startIdx) + focusSuggestion.dataset.title + origString.slice(textNode.endIdx)
console.log(string)
sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 2
setFocusedBlockString(string)
}
autocompleteList.style.display = "none"
}
const indentFocusedBlock = () => {
const bid = sessionState.focusId
const olderSibling = focusBlock.previousElementSibling
if (olderSibling && olderSibling.dataset && olderSibling.dataset.id) {
const newParentId = olderSibling.dataset.id
console.log(newParentId)
const idx = (store.blox[newParentId].k && store.blox[newParentId].k.length) || 0
macros.move(bid,newParentId,idx)
olderSibling.children[2].appendChild(focusBlock)
getSelection().collapse(focusNode,focusOffset)
}
}
const dedentFocusedBlock = () => {
const bid = sessionState.focusId
const parentId = store.blox[bid].p
const parentBlock = store.blox[parentId]
if (parentBlock) {
const grandparentId = parentBlock.p
const idx = store.blox[grandparentId].k.indexOf(parentId)
macros.move(bid,grandparentId,idx + 1)
const parentNode = focusBlock.parentNode.parentNode
const grandparentChildren = parentNode.parentNode
const cousin = parentNode.nextElementSibling
if (cousin) {
grandparentChildren.insertBefore(focusBlock,cousin)
} else {
grandparentChildren.appendChild(focusBlock)
}
getSelection().collapse(focusNode,focusOffset)
} else {
// notifyText("can't dedent from page root", 2) // don't need error message here?
}
}
// Event listners --------------------------------------------------------------------------------------------------------
document.addEventListener("input",(event) => {
updateCursorInfo()
autocompleteList.style.display = "none"
templateList.style.display = "none"
if (sessionState.isFocused) {
if (focusBlockBody.innerText === " " || focusBlockBody.innerText === "") {
macros.write(sessionState.focusId,"")
return
}
// reparse block and insert cursor into correct position while typing
let string = focusBlockBody.innerText
let wasInputPlain = event.data !== null && event.data.length === 1 && event.inputType === "insertText"
if (event.data !== null) {
if (event.data === "[") {
const pageRefClosesMissingOpens = event.target.querySelectorAll(".page-ref-close-missing-open")
let broke = false
for (let x of pageRefClosesMissingOpens) {
console.log(x)
if (x.childNodes[0].startIdx > sessionState.position) {
broke = true
break
}
}
if (!broke) {
string = string.substring(0,sessionState.position) + "]" + string.substring(sessionState.position)
wasInputPlain = false
}
} else if (event.data === "]") {
if (string[sessionState.position] === "]") {
string = string.substring(0,sessionState.position - 1) + string.substring(sessionState.position)
wasInputPlain = false
}
}
}
let diff = { d: store.blox[sessionState.focusId].s,i: string }
if (wasInputPlain) {
if (sessionState.position === string.length)
diff = { i: event.data }
else diff = { i: event.data,s: sessionState.position - 1 }
}
setFocusedBlockString(string,diff)
if (editingTitle) {
const matchingTitles = titleExactFullTextSearch(editingTitle)
renderResultSet(editingLink,matchingTitles,autocompleteList,0)
}
if (editingTemplateExpander) {
console.log("editingTemplateExpander")
const editingTemplateText = editingTemplateExpander.innerText.substring(2)
const matchingTemplates = searchTemplates(editingTemplateText)
renderResultSet(editingTemplateExpander,matchingTemplates,templateList,0)
}
} else if (event.target.id === "search-input") {
const matchingTitles = exactFullTextSearch(event.target.value)
renderResultSet(searchInput,matchingTitles,searchResultList,0)
} else if (event.target.className === "page__title") {
console.log("edit title")
const pageId = event.target.parentNode.dataset.id
macros.write(pageId,event.target.innerText)
}
})
const globalHotkeys = {
"hide top bar": {
key: "b",
control: true,
fn: () => {
if (topBar.style.marginTop === "0px") user.topBar = "hidden"
else user.topBar = "visible"
saveUser()
}
},
"escape": {
key: "Escape",fn: () => {
autocompleteList.style.display = "none"
templateList.style.display = "none"
}
},
"upload": {
key: "d",control: true,fn: () => {
document.getElementById("upload-input").click()
}
},
"download": { key: "s",control: true,shift: true,fn: downloadHandler },
"save": { key: "s",control: true,fn: debouncedSaveStore },
"toggle color theme": {
key: "m",control: true,fn: () => {
if (document.body.className === "light") {
user.settings.theme = "dark"
saveUser()
} else {
user.settings.theme = "light"
saveUser()
}
}
},
"search": {
key: "u",control: true,fn: () => {
if (topBar.style.marginTop !== "0px") topBar.style.marginTop = "0px"
searchInput.focus()
}
},
"open": {
key: "o",control: true,fn: (event) => {
if (editingTitle) goto("pageTitle",editingTitle)
else if (editingUrlElement) editingUrlElement.click()
}
},
"daily notes": {
key: "d",alt: true,fn: () => {
goto("dailyNotes")
}
},"undo": {
key: "z",control: true,fn: () => {
if (edits.length > 0) {
undoEdit()
renderSessionState()
}
}
},
"terminal": {
key: "i",control: true,alt: true,fn: () => {
if (terminalElement.style.display === "none") {
terminalElement.style.display = "block"
terminalElement.focus()
} else {
terminalElement.style.display = "none"
}
}
}
}
document.addEventListener("keydown",(event) => {
updateCursorInfo()
for (let hotkeyName in globalHotkeys) {
const hotkey = globalHotkeys[hotkeyName]
if (event.key === hotkey.key &&
event.shiftKey === !!hotkey.shift &&
event.ctrlKey === !!hotkey.control &&
event.altKey === !!hotkey.alt) {
hotkey.fn(event)
event.preventDefault()
return
}
}
if (dragSelect) {
let did = false
if ((event.key === "c" || event.key === "x") && event.ctrlKey) {
let text = ""
console.log("copy blocks")
const id = dragSelect.root.dataset.id
if (dragSelect.rooted) {
text = blocToMd(id)
} else {
const kids = store.blox[id].k
for (let i = dragSelect.startIdx; i < dragSelect.endIdx + 1; i++) {
text += blocToMd(kids[i])
}
}
clipboardData = {
dragSelect: {
root: id,
startIdx: dragSelect.startIdx,
endIdx: dragSelect.endIdx,
rooted: dragSelect.rooted
},
text
}
console.log(clipboardData)
navigator.clipboard.writeText(text)
did = true
}
if (event.key === "Backspace" || event.key === "Delete" || (event.key === "x" && event.ctrlKey)) {
console.log(dragSelect)
if (dragSelect.rooted) {
focusBlockVerticalOffset(-1,dragSelect.root)
macros.nocommit.delete(dragSelect.root.dataset.id)
document.querySelectorAll(`.block[data-id="${dragSelect.root.dataset.id}"]`).forEach(x => x.remove())
} else {
const childNodes = getChildren(dragSelect.root)
focusBlockVerticalOffset(-1,childNodes[dragSelect.startIdx])
console.log(`cnl ${childNodes.length} start ${dragSelect.startIdx} end ${dragSelect.endIdx}`)
// iterate backwards so the idxs don't shift underneath you
for (let i = dragSelect.endIdx; i >= dragSelect.startIdx; i--) {
const node = childNodes[i]
macros.nocommit.delete(node.dataset.id)
document.querySelectorAll(`.block[data-id="${node.dataset.id}"]`).forEach(x => x.remove())
}
commit()
}
dragSelect = null
did = true
}
if (did) event.preventDefault()
} else if (autocompleteList.style.display !== "none") {
if (event.key === "Enter") {
autocomplete()
event.preventDefault()
}
if (updownythingey(editingLink,autocompleteList,titleExactFullTextSearchCache,focusSuggestion)) event.preventDefault()
} else if (templateList.style.display !== "none") {
if (event.key === "Tab" || event.key === "Enter") {
expandTemplate()
event.preventDefault()
}
if (updownythingey(editingTemplateExpander,templateList,templateSearchCache,focusSuggestion)) event.preventDefault()
} else if (sessionState.isFocused) {
let blocks
let newActiveBlock
switch (event.key) {
case "Enter":
if (!event.shiftKey) {
let idx = store.blox[store.blox[sessionState.focusId].p].k.indexOf(sessionState.focusId)
if (!event.ctrlKey) {
idx += 1
}
console.log(idx)
const newBlockUid = newUid()
commitEdit("cr",newBlockUid,store.blox[sessionState.focusId].p,idx)
const newBlockElement = renderBlock(focusBlock.parentNode,newBlockUid,idx)
newBlockElement.children[1].focus()
event.preventDefault()
}
break
case "Tab":
if (event.shiftKey)
dedentFocusedBlock()
else
indentFocusedBlock()
event.preventDefault()
break
case "Backspace":
if (sessionState.position === 0) {
const parent = store.blox[store.blox[sessionState.focusId].p]
console.log(parent.k)
if (!(parent.p === undefined && parent.k.length === 1)) {
blocks = Array.from(document.querySelectorAll(".block"))
newActiveBlock = blocks[blocks.indexOf(focusBlock) - 1]
focusBlock.remove()
focusBlockEnd(newActiveBlock)
macros.delete(sessionState.focusId)
event.preventDefault()
}
}
break
case "ArrowDown":
if (event.altKey && event.shiftKey) {
const parentId = store.blox[sessionState.focusId].p
const parentElement = focusBlock.parentNode
const currentIdx = store.blox[parentId].children.indexOf(sessionState.focusId)
if (focusBlock.nextElementSibling) {
macros.move(sessionState.focusId,parentId,currentIdx + 1)
if (focusBlock.nextElementSibling.nextElementSibling) {
parentElement.insertBefore(focusBlock,focusBlock.nextElementSibling.nextElementSibling)
} else parentElement.appendChild(focusBlock)
getSelection().collapse(focusNode,focusOffset)
event.preventDefault()
}
} else if (!event.shiftKey && !event.altKey) {
focusBlockVerticalOffset(1)
event.preventDefault()
}
break
case "ArrowUp":
if (event.altKey && event.shiftKey) {
const parentId = store.blox[sessionState.focusId].p
const parentElement = focusBlock.parentNode
const currentIdx = store.blox[parentId].children.indexOf(sessionState.focusId)
if (focusBlock.previousElementSibling) {
macros.move(sessionState.focusId,parentId,currentIdx - 1)
parentElement.insertBefore(focusBlock,focusBlock.previousElementSibling)
getSelection().collapse(focusNode,focusOffset)
event.preventDefault()
}
} else if (!event.shiftKey && !event.altKey) {
focusBlockVerticalOffset(-1)
event.preventDefault()
}
break
case "ArrowLeft":
if (event.shiftKey && event.altKey) {
dedentFocusedBlock()
} else if (sessionState.position === 0) {
focusBlockVerticalOffset(-1)
event.preventDefault()
}
break
case "ArrowRight":
if (event.shiftKey && event.altKey) {
indentFocusedBlock()
} else if (sessionState.position === focusBlockBody.innerText.length) {
focusBlockVerticalOffset(1,focusBlock,true)
event.preventDefault()
}
break
case "c":
if (event.ctrlKey) { // LEGITTODO copy md text and check paste text against, 
clipboardData = null
}
break
}
}
if (
document.activeElement &&
document.activeElement.id === "search-input"
&& focusSearchResult
) {
if (event.key === "Enter" && !event.ctrlKey) {
if (focusSearchResult) {
if (focusSearchResult.dataset.title) {
goto("pageTitle",focusSearchResult.dataset.title)
} else {
goto("block",focusSearchResult.dataset.id)
}
event.preventDefault()
return
}
} else if (event.key === "Enter" && event.ctrlKey) {
goto("pageTitle",event.target.value)
event.preventDefault()
return
}
const didUpDowny = updownythingey(searchInput,searchResultList,exactFullTextSearchCache,focusSearchResult)
if (didUpDowny) event.preventDefault()
}
if (terminalElement.style.display !== "none") {
if (event.key === "Enter" && !event.ctrlKey && !event.shiftKey && !event.altKey) {
const tc = terminalCommands[event.target.innerText]
if (tc) {
tc()
event.preventDefault()
terminalElement.style.display = "none"
terminalElement.innerHTML = ""
}
else {
try {
eval(event.target.innerText)
if (!event.ctrlKey) {
terminalElement.style.display = "none"
terminalElement.innerHTML = ""
}
} catch (error) {
console.log(error)
event.preventDefault()
}
}
}
}
})
document.addEventListener('paste',(event) => {
console.log(event)
if (clipboardData) {
const clipboardText = event.clipboardData.getData('text')
console.log(clipboardText)
console.log(clipboardData.text)
if (clipboardText.replaceAll(/\r/g,"") == clipboardData.text) {
pasteBlocks()
event.preventDefault()
} else clipboardData = undefined
}
})
const updownythingey = (parent,list,cache,focused) => {
// todo factor this so the same logic works on search all, block, title, and template
const moveDirection = ((event.key === "ArrowUp" || (event.key === "Tab" && event.shiftKey)) && -1) ||
((event.key === "ArrowDown" || event.key === "Tab") && 1)
if (moveDirection) {
const siblingToMoveTo = moveDirection === -1 ? focused.previousElementSibling : focused.nextElementSibling
if (siblingToMoveTo) {
siblingToMoveTo.dataset.selected = "true"
delete focused.dataset.selected
} else {
const oldIdx = parseInt(list.dataset.resultStartIdx)
const newIdx = clamp(oldIdx + moveDirection * SEARCH_RESULT_LENGTH,0,cache.length - SEARCH_RESULT_LENGTH)
renderResultSet(parent,cache,list,newIdx)
if (moveDirection === -1) {
delete list.firstElementChild.dataset.selected
list.lastElementChild.dataset.selected = true
}
}
return true
}
}
const getPageTitleOfNode = (node) => {
const tag = node.closest(".tag")
if (tag) return tag.innerText.substring(1)
const attribute = node.closest(".attribute")
if (attribute) return attribute.innerText.substring(0,attribute.innerText.length - 2)
const pageRef = node.closest(".page-ref")
if (pageRef) return pageRef.children[1].innerText
return undefined
}
// The single event handler model has some problems. The cases need to appear in the same order they are nested in the DOM
document.addEventListener("click",(event) => {
const clickedPageTitle = getPageTitleOfNode(event.target)
if (clickedPageTitle) {
goto("pageTitle",clickedPageTitle)
return
}
const closestBullet = event.target.closest(".block__bullet")
if (event.target.className === "search-result") {
if (event.target.dataset.title) {
goto("pageTitle",event.target.dataset.title)
} else {
goto("block",event.target.dataset.id)
}
return
} else if (event.target.id !== "search-input") {
searchResultList.style.display = "none"
}
const closestBreadcrumbPage = event.target.closest(".breadcrumb-page")
const closestBreadcrumbBlock = event.target.closest(".breadcrumb-block")
// markup
if (closestBullet) {
goto("block",closestBullet.parentNode.dataset.id)
} else if (event.target.className === "block-ref") {
goto("block",event.target.dataset.id)
} else if (event.target.className === "url") { // using spans with event handlers as links because they play nice with contenteditable
const link = document.createElement("a")
link.target = "_blank"
link.href = event.target.innerText
link.click()
// everything else, so none of it triggers when user clicks markup
} else if (event.target.id === "download-button") {
downloadHandler()
} else if (event.target.className === "template__suggestion") {
if (focusSuggestion) focusSuggestion.dataset.selected = false
event.target.dataset.selected = true
focusSuggestion = event.target
expandTemplate()
} else if (event.target.id === "upload-button") {
document.getElementById("upload-input").click()
} else if (event.target.id === "daily-notes-button") {
goto("dailyNotes")
} else if (event.target.id === "options-button") {
notifyText("Options coming soon")
} else if (event.target.className === "autocomplete__suggestion") {
if (focusSuggestion) focusSuggestion.dataset.selected = false
event.target.dataset.selected = true
autocomplete()
} else if (event.target.id === "help-button") {
goto("pageTitle","Welcome to Micro Roam")
} else if (closestBreadcrumbPage) {
goto("pageTitle",closestBreadcrumbPage.dataset.title)
} else if (closestBreadcrumbBlock) {
goto("block",closestBreadcrumbBlock.dataset.id)
} else if (event.target.className == "exit-to-main") {
signupElement.style.display = "none"
loginElement.style.display = "none"
}
// this is at the bottom so that autocomplete suggestion click handler still knows where the link is. 
// todo have better tracking of active block
updateCursorInfo()
})
const commonAncestorNode = (a,b) => {
const aList = []
while (a.dataset.id !== undefined) {
aList.push(a.dataset.id)
a = a.parentNode.parentNode
}
const bList = []
while (b.dataset.id !== undefined) {
bList.push(b.dataset.id)
if (aList.indexOf(b.dataset.id) !== -1) {
const caid = aList[aList.indexOf(b.dataset.id) - 1]
const cbid = bList[bList.length - 2]
const parentChildIds = store.blox[b.dataset.id].k
const bidx = parentChildIds ? parentChildIds.indexOf(cbid) : -1
const aidx = parentChildIds ? parentChildIds.indexOf(caid) : -1
const e = Math.max(aidx,bidx)
return { root: b,startIdx: Math.max(Math.min(aidx,bidx),0),endIdx: e === -1 ? parentChildIds.length : e,rooted: bidx === -1 || aidx === -1 }
}
b = b.parentNode.parentNode
}
}
const setDragSelected = (bool) => {
if (dragSelect) {
if (dragSelect.rooted) {
dragSelect.root.dataset.selected = bool
} else {
const children = getChildren(dragSelect.root)
for (let i = dragSelect.startIdx; i < dragSelect.endIdx + 1; i++) {
children[i].dataset.selected = bool
}
}
}
}
const mouseMoveListener = (event) => {
setDragSelected(false)
const blockNode = event.target.closest(".block")
if (blockNode && blockNode !== dragSelectStartBlock) {
getSelection().empty()
const can = commonAncestorNode(dragSelectStartBlock,blockNode)
if (can) {
dragSelect = can
setDragSelected(true)
}
} else {
dragSelect = null
}
}
document.addEventListener("mousedown",(event) => {
updateCursorInfo()
setDragSelected(false)
dragSelect = null
if (event.target.closest(".block")) {
document.addEventListener("mousemove",mouseMoveListener)
dragSelectStartBlock = event.target.closest(".block")
}
})
document.addEventListener("mouseup",(event) => {
if (dragSelectStartBlock !== null) {
document.removeEventListener("mousemove",mouseMoveListener)
dragSelectStartBlock = null
}
})
const showTopBarFn = () => {
user.topBar = "visible"
saveUser()
}
let showTopBarTimeout = null
topBarHiddenHitbox.addEventListener("mouseover",() => {
clearTimeout(showTopBarTimeout)
showTopBarTimeout = setTimeout(showTopBarFn,700)
})
topBarHiddenHitbox.addEventListener("mouseout",() => {
clearTimeout(showTopBarTimeout)
showTopBarTimeout = null
})
document.getElementById('upload-input').addEventListener('change',(event) => {
const file = event.target.files[0]
console.log(file)
const { name,ext: extension } = splitFileName(file.name)
console.log(`name ${name} extension ${extension}`)
if (extension === "zip") {
file.arrayBuffer().then((buffer) => {
const files = zipToFiles(buffer)
console.log(files)
if (files.length === 1 && files[0].ext === "json") {
store = roamJsonToStore(files[0].name,files[0].text)
preprocessNewStore()
} else {
notifyText("Markdown import doesn't work yet. Upload a .json file, or a .zip file containing a .json file instead.",12)
throw new Error("md import doesn't work")
const mds = []
for (let file of files) {
if (file.ext === "md") {
mds.push(file)
} else {
console.log(`That zip file contained ${file.fullName}, but Micro Roam expected a .json file or multiple .md files`)
}
}
console.log("parsing markdown")
mdToStore(mds)
}
})
} else if (extension === "json") {
file.text().then((text) => {
user.graphName = name
store = roamJsonToStore(name,text)
preprocessNewStore()
})
} else {
notifyText("Micro Roam only accepts a .json file or .zip file containing 1 .json file") // add "md" once that works
}
})
const preprocessNewStore = () => {
startFn = () => gotoNoHistory("dailyNotes")
fetch("./default-store.json").then(text => text.json().then(json => {
mergeStore(json)
start()
}))
}
signupButton.addEventListener('click',(event) => {
focusSignup()
event.stopPropagation()
event.preventDefault()
})
const focusSignup = () => {
signupElement.style.display = "block"
loginElement.style.display = "none"
signupEmailElement.focus()
}
const focusLogin = () => {
loginElement.style.display = "block"
signupElement.style.display = "none"
loginEmailElement.focus()
}
switchToSignup.addEventListener('click',focusSignup)
switchToLogin.addEventListener('click',focusLogin)
/**
example query string
?title=Micro Roam&scroll=100&focus=fS4vHpM2_&position=10
*/
const initialDailyNotes = 5
const renderSessionState = () => {
// clear screen
searchResultList.style.display = "none"
pageFrameOuter.removeEventListener("scroll",dailyNotesInfiniteScrollListener)
pageFrame.innerHTML = ""
searchInput.value = ""
// render state
switch (sessionState.pageFrame) {
case "pageTitle":
let existingPage = store.titles[sessionState.page]
if (existingPage === undefined) {
existingPage = macros.createPage(sessionState.page)
}
renderPage(pageFrame,existingPage)
break
case "block":
const blockFocusFrame = blockFocusFrameTemplate.cloneNode(true)
pageFrame.appendChild(blockFocusFrame)
renderBreadcrumb(blockFocusFrame.children[0],sessionState.block)
renderBlock(blockFocusFrame.children[1],sessionState.block)
const backRefs = store.refs[sessionState.block]
if (backRefs) {
backRefs.sort((a,b) => store.blox[b].et - store.blox[a].et)
const backrefsListElement = backrefListTemplate.cloneNode(true)
blockFocusFrame.children[2].appendChild(backrefsListElement)
for (let backref of backRefs) {
renderBlock(backrefsListElement.children[1],backref)
}
}
break
case "dailyNotes":
pageFrameOuter.addEventListener("scroll",dailyNotesInfiniteScrollListener)
sessionState.oldestDate = new Date(Date.now())
let numNotesLoaded = 0
if (store.titles[formatDate(sessionState.oldestDate)] === undefined) {
macros.createPage(formatDate(sessionState.oldestDate))
}
for (let i = 0; i < 1000; i++) {
const daysNotes = store.titles[formatDate(sessionState.oldestDate)]
if (daysNotes) {
renderPage(pageFrame,daysNotes)
pageFrame.appendChild(pageBreakTemplate.cloneNode(true))
numNotesLoaded += 1
if (numNotesLoaded >= initialDailyNotes) {
break
}
}
sessionState.oldestDate.setDate(
sessionState.oldestDate.getDate() - 1
)
}
if (numNotesLoaded < initialDailyNotes) pageFrame.lastChild.remove()
break
}
if (sessionState.isFocused) {
focusIdPosition()
} else {
focusBlockStart(document.querySelector(".block"))
}
pageFrameOuter.scrollTop = sessionState.scroll || 0
}
const gotoNoHistory = (commandName,...command) => {
switch (commandName) {
case "dailyNotes":
sessionState.pageFrame = "dailyNotes"
break
case "pageTitle":
sessionState.pageFrame = "pageTitle"
sessionState.page = command[0]
break
case "block":
sessionState.pageFrame = "block"
sessionState.block = command[0]
break
}
renderSessionState()
}
const goto = (...command) => {
sessionState.scroll = pageFrameOuter.scrollTop // used to have updatecursorinfo here, think I don't need it?
const oldSessionState = JSON.parse(JSON.stringify(sessionState))
sessionState.isFocused = false
sessionState.scroll = 0
gotoNoHistory(...command)
setTimeout(() => {
history.replaceState(oldSessionState,"Micro Roam")
// todo use page title, in more places than just this because apparently here's not often supported
history.pushState(sessionState,"Micro Roam")
},0)
}
const gotoReplaceHistory = (...command) => {
gotoNoHistory(...command)
history.replaceState(sessionState,"Micro Roam")
}
window.addEventListener("popstate",(event) => {
console.log(event.state)
if (event.state) {
sessionState = event.state
renderSessionState()
}
})
const focusIdPosition = () => {
focusBlockBody = document.querySelector(`.block[data-id="${sessionState.focusId}"]>.block__body`) // todo this looks wrong
const scanElement = (element) => {
for (let el of element.childNodes) {
if (el.nodeName === "#text") {
if (el.textContent && sessionState.position >= el.startIdx && sessionState.position < el.startIdx + el.textContent.length) {
scanResult = el
try {
// this does the thing correctly, but then throws an error, which I catch? todo investigate
getSelection().collapse(el,sessionState.position - el.startIdx)
return el
} catch (error) {
return el
}
}
} else {
const z = scanElement(el)
if (z) return z
}
}
}
scanElement(focusBlockBody)
}
const setFocusedBlockString = (string,diff) => {
focusBlockBody.innerHTML = ""
const fragment = document.createDocumentFragment()
const refTitles = renderBlockBody(fragment,string)
focusBlockBody.appendChild(fragment)
focusIdPosition()
updateCursorInfo()
if (diff !== undefined) {
commitEdit('df',sessionState.focusId,diff)
} else {
macros.write(sessionState.focusId,string)
}
}
const getEditingSimpleSpan = (className) => {
const elements = focusBlockBody.querySelectorAll("." + className)
for (let temp of elements) {
if (temp.childNodes[0].endIdx >= sessionState.position && temp.childNodes[0].startIdx < sessionState.position) {
return temp
}
}
}
// todo call this less. right now it's called twice as much as necessary, costing 0.3ms per keystroke and making code ugly
// todo also get rid of this entirely. it's a complete mess
const updateCursorInfo = () => {
focusNode = getSelection().focusNode
focusOffset = getSelection().focusOffset
focusSuggestion = autocompleteList.querySelector(`.autocomplete__suggestion[data-selected="true"]`) || templateList.querySelector(`.template__suggestion[data-selected="true"]`)
focusSearchResult = searchResultList.querySelector(`.search-result[data-selected="true"]`)
if (focusNode) {
focusBlock = focusNode.parentNode.closest(".block")
if (focusBlock) {
sessionState.isFocused = true
sessionState.focusId = focusBlock.dataset.id
if (focusNode.className === "block__body") {
sessionState.position = focusBlock.innerText.length * (focusOffset !== 0) // todo make this less jank
} else {
sessionState.position = focusOffset
if (focusNode.startIdx) sessionState.position += focusNode.startIdx
}
focusBlockBody = focusBlock.children[1]
editingLink = undefined
const pageRefs = focusBlockBody.querySelectorAll(".page-ref")
const tags = focusBlockBody.querySelectorAll(".tag")
for (let tag of tags) {
if (tag.childNodes[0].endIdx >= sessionState.position && tag.childNodes[0].startIdx < sessionState.position) {
editingLink = tag
}
}
for (let ref of pageRefs) {
if (ref.children[1].childNodes[0].endIdx >= sessionState.position && ref.children[1].childNodes[0].startIdx < sessionState.position) {
editingLink = ref
}
}
editingTitle = editingLink && ((editingLink.className === "tag" && editingLink.innerText.substring(1)) || (editingLink.className === "page-ref" && editingLink.children[1].innerText))
editingTemplateExpander = getEditingSimpleSpan("template-expander")
editingUrlElement = getEditingSimpleSpan("url")
} else
sessionState.isFocused = false
} else
sessionState.isFocused = false
}
const dailyNotesInfiniteScrollListener = () => {
const fromBottom =
pageFrame.getBoundingClientRect().bottom - innerHeight
if (fromBottom < 700) {
for (let i = 0; i < 100; i++) {
sessionState.oldestDate.setDate(sessionState.oldestDate.getDate() - 1)
const daysNotes = store.titles[formatDate(sessionState.oldestDate)]
if (daysNotes) {
renderPage(pageFrame,daysNotes)
pageFrame.appendChild(pageBreakTemplate.cloneNode(true))
break
}
}
}
}
const parseStackTrace = (string) => {
const result = []
const matches = string.matchAll(/([^ ]+) \(([^\)]+):([0-9]+):([0-9]+)\)(?:\n|$)/g)
for (let match of matches) {
result.push({ function: match[1],file: match[2],line: match[3],column: match[4] })
}
return result
}
const logError = (message,url,lineNumber,columnNumber,error) => {
const errorInfo = { line: lineNumber,file: url,stack: parseStackTrace(error.stack),message,column: columnNumber }
const existingErrors = localStorage.getItem("error_log")
if (existingErrors) {
const z = JSON.parse(existingErrors)
z.push(errorInfo)
localStorage.setItem("error_log",JSON.stringify(z))
} else {
localStorage.setItem("error_log",JSON.stringify([errorInfo]))
}
// todo send error to server at this point
return false // we don't actually "catch" the error, we just report that it happened. The error is still an error
}
window.onerror = logError
const showTopBar = () => {
topBar.style.marginTop = "0px"
topBarHiddenHitbox.style.display = "none"
}
const hideTopBar = () => {
topBar.style.marginTop = "-43px"
topBarHiddenHitbox.style.display = "block"
}
const saveUser = () => {
document.body.className = user.settings.theme
if (user.topBar === "visible") showTopBar()
else hideTopBar()
localStorage.setItem("user",JSON.stringify(user))
saveSettingsToBasicBitchServer()
}
// Finally starting the program after everything's compiled
if (dataLoaded) start()
scriptsLoaded = true
const ptest = () => {
const t = performance.now()
for (let i = 0; i < 100; i++) {
hydrateFromBlox('testgraph',store.blox)
}
console.log(`took ${performance.now() - t}`)
}
// ptest()
</script>
<!-- now rendering is done, loading interactive scripts-->
<script async>
const LOCAL_FILE_SIGNATURE = 0x04034b50
const LOCAL_FILE_HEADER_LENGTH = 30
const END_CENTRAL_DIR_SIGNATURE = 0x06054b50
const END_CENTRAL_DIR_HEADER_LENGTH = 46
const CENTRAL_FILE_SIGNATURE = 0x02014b50
const ARCHIVE_EXTRA_RECORD_SIGNATURE = 0x08064b50
const CRC_32_MAGIC = 0xab045452
const splitFileName = (fileName) => {
const match = fileName.match(/\.([a-z]+)$/)
return { name: fileName.substring(0,match.index),ext: match[1] }
}
const zipToFiles = (buffer) => {
const bufferU8 = new Uint8Array(buffer)
let idx = 0
const result = []
while (idx < bufferU8.length) {
// I have to copy header u32s into new arrays because they might not be aligned :(
const sigBuf = new ArrayBuffer(4)
const sigInt8 = new Uint8Array(sigBuf)
for (let i = 0; i < 4; i++) {
sigInt8[i] = bufferU8[idx + i]
}
const sigInt = (new Uint32Array(sigBuf))[0]
if (sigInt === LOCAL_FILE_SIGNATURE) {
const compressionMethod = (new Uint16Array(buffer,8,1))[0]
if (compressionMethod === 0) {
const dumbArray = new ArrayBuffer(12)
const dumbu8 = new Uint8Array(dumbArray)
for (let i = 0; i < 12; i++) {
dumbu8[i] = bufferU8[i + 18 + idx]
}
const dumbu32 = new Uint32Array(dumbArray)
const compressedSize = dumbu32[0]
const rawSize = dumbu32[1]
const fileNameSize = dumbu32[2]
if (fileNameSize >= 1441805) {
break
}
const decoder = new TextDecoder()
const fullName = decoder.decode(new Uint8Array(buffer,idx + 30,fileNameSize))
const { name,ext } = splitFileName(fullName)
const text = decoder.decode(new Uint8Array(buffer,idx + 30 + fileNameSize,rawSize))
result.push({ name,ext,text,fullName })
idx += 30 + fileNameSize + rawSize
} else {
console.log(compressionMethod)
notifyText("Micro Roam can't handle .zip files that are actually compressed. use a .json file or an uncompressed .zip file, like ones exported by Roam Research or Micro Roam",10)
return
}
} else if (sigInt === END_CENTRAL_DIR_SIGNATURE) {
console.log(`got end central dir signature`)
break
} else {
console.log(`got signature ${sigInt}`)
break
}
}
return result
}
// crc32 copied from stackoverflow
let crcTable = null
const makeCRCTable = () => {
let c
crcTable = []
for (let n = 0; n < 256; n++) {
c = n
for (let k = 0; k < 8; k++) {
// original seed was 0xEDB88320
c = ((c & 1) ? (0xdebb20e3 ^ (c >>> 1)) : (c >>> 1))
}
crcTable[n] = c
}
}
function crc32(buf,start,end) {
if (crcTable === null) makeCRCTable()
let crc = -1
for (let i = start; i < end; i++) {
crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xFF]
}
return (crc ^ (-1)) >>> 0
};
const dateUnixToMsDosFormat = (date) => {
const dateObj = new Date(date)
const day = dateObj.getDate()
const month = dateObj.getMonth() + 1
const year = dateObj.getFullYear() - 1980
let result = day + (month << 5) + (year << 9)
console.log(result)
console.log(result.toString(2))
return result
}
const writeU16ToU8Array = (u8,idx,number) => {
// apparently the bit shifts are << and >>>, NOT >> because that one converts to signed after *facepalm*
u8[idx] = number << 24 >>> 24
u8[idx + 1] = number << 16 >>> 24
}
const writeIntToU8Array = (u8,idx,int) => {
u8[idx] = int << 24 >>> 24
u8[idx + 1] = int << 16 >>> 24
u8[idx + 2] = int << 8 >>> 24
u8[idx + 3] = int >>> 24
}
const ZIP_VERSION = 10
const blankLocalHeader = new Uint8Array(30)
{
writeIntToU8Array(blankLocalHeader,0,LOCAL_FILE_SIGNATURE)
writeIntToU8Array(blankLocalHeader,14,CRC_32_MAGIC)
// todo make sure version, ect are exactly right
writeU16ToU8Array(blankLocalHeader,4,ZIP_VERSION)
}
const blankCentralHeader = new Uint8Array(46)
{
writeIntToU8Array(blankCentralHeader,0,CENTRAL_FILE_SIGNATURE)
writeU16ToU8Array(blankCentralHeader,4,16) // my name is BeOS :)
writeU16ToU8Array(blankCentralHeader,6,ZIP_VERSION)
}
const copyBuffer = (b1,s1,b2,s2,l) => {
// could be optimized by switching to u64 for long stretches
for (let i = 0; i < l; i++) {
b2[s2 + i] = b1[s1 + i]
}
}
const filesToZip = (files) => {
const fileCreateTime = Date.now()
const createTimeMsDosFormat = dateUnixToMsDosFormat(fileCreateTime)
const mstime = performance.now()
// measure text length by concatting then encoding. can't use text.length bc utf8
let str = ""
let tl = 0
for (let file of files) {
str += file.fullName + file.text
tl += 30 + file.fullName.length + file.text.length
}
let size = textEncoder.encode(str).length + LOCAL_FILE_HEADER_LENGTH * files.length + END_CENTRAL_DIR_HEADER_LENGTH
console.log(str.length - tl)
console.log(`mstime ${performance.now() - mstime}`)
let buffer = new ArrayBuffer(size)
let u8 = new Uint8Array(buffer)
let idx = 0
for (let file of files) {
const headerStart = idx
copyBuffer(blankLocalHeader,0,u8,idx,blankLocalHeader.length)
writeU16ToU8Array(u8,headerStart + 10,createTimeMsDosFormat)
writeU16ToU8Array(u8,headerStart + 12,createTimeMsDosFormat)
idx += blankLocalHeader.length
const nameU8 = u8.subarray(idx)
const { read: nameLen } = textEncoder.encodeInto(file.fullName,nameU8)
idx += nameLen
const textU8 = u8.subarray(idx)
const { read: textLen } = textEncoder.encodeInto(file.text,textU8)
const crc = crc32(u8,idx,idx + textLen)
writeIntToU8Array(u8,headerStart + 14,crc)
idx += textLen
writeIntToU8Array(u8,headerStart + 18,textLen)
writeIntToU8Array(u8,headerStart + 22,textLen)
writeU16ToU8Array(u8,headerStart + 26,nameLen)
}
//   writeU16ToU8Array(blankCentralHeader,12,createTimeMsDosFormat)
// writeU16ToU8Array(blankCentralHeader,14,createTimeMsDosFormat)
// writeIntToU8Array(blankCentralHeader,16,CRC_32_MAGIC)
const blob = new Blob([buffer])
console.log(`filestozip ${performance.now() - mstime}`)
return blob
}
const testRoundTrip = () => {
const jsonOutput = storeToRoamJSON(store)
store = roamJsonToStore(store.graphName,jsonOutput)
const jsonOutput2 = storeToRoamJSON(store)
const eq = jsonOutput === jsonOutput2
if (!eq) {
console.log(jsonOutput)
console.log(jsonOutput2)
console.error("round trip failed")
} else {
console.log("Round trip test passed!")
}
}
const createPageTest = () => {
const oldStore = store
store = blankStore()
macros.createPage("Test Page")
store = oldStore
}
// todo switch this to async with empty promise?
let testSTime
const renderMulti = (f,state = undefined,reps = 100,recurse = false) => {
if (!recurse) {
testSTime = performance.now()
}
if (reps > 0) {
const exit = f(state)
if (!exit)
setTimeout(() => renderMulti(f,state,reps - 1,true),0)
} else {
console.log(`test func took ${performance.now() - testSTime}`)
}
}
const benchmarkPageLoad = () => renderMulti(() => goto("pageTitle","Welcome to Micro Roam"))
let benchmarkRandomWalkSTime = null
const benchmarkRandomWalk = () => renderMulti(() => {
let linkTitles = []
const pageLinks = document.querySelectorAll(".page-ref")
const tags = document.querySelectorAll(".tag")
const pageBreadcrumbs = document.querySelectorAll(".breadcrumb-page")
for (let link of pageLinks) {
linkTitles.push(link.children[1].innerText)
}
for (let tag of tags) {
linkTitles.push(tag.innerText.substring(1))
}
for (let pb of pageBreadcrumbs) {
linkTitles.push(pb.innerText)
}
linkTitles = linkTitles.filter(x => store.titles[x] && store.blox[store.titles[x]])
const chosenTitle = linkTitles[Math.floor(Math.random() * (linkTitles.length - 1))]
goto("pageTitle",chosenTitle)
})
const benchmarkRenderAll = async () => {
const stime = performance.now()
let functionTime = 0
let count = 0
for (let pageTitle in store.titles) {
const functionSTime = performance.now()
gotoNoHistory("pageTitle",pageTitle)
functionTime += performance.now() - functionSTime
count += 1
await new Promise(resolve => setTimeout(resolve,0))
}
const duration = performance.now() - stime
const message = `rendered ${count} pages in ${Math.round(duration)}ms, avg ${Math.round(duration / count)}ms
function time avg ${Math.round(functionTime / count)}`
console.log(message)
notifyText(message,10)
}
const testAll = () => {
testRoundTrip()
benchmarkPageLoad()
benchmarkRandomWalk()
benchmarkRenderAll()
}
const benchmarkGen = () => {
const stime = performance.now()
for (let i = 0; i < 100; i++) {
generateInnerRefs()
}
console.log(`gen took ${performance.now() - stime}`)
}
const log = () => {
user.logging = true
saveUser()
}
const nolog = () => {
user.logging = false
saveUser()
}
const flash = benchmarkRenderAll
const reset = () => {
localStorage.removeItem("user")
const r = indexedDB.deleteDatabase("microroam")
window.location.href = window.location.href
}
const blank = (name = "default") => {
store = blankStore()
store.graphName = name
user = { settings: { graphName: "default",theme: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? "dark" : "light",topBar: "visible",logging: false,spellcheck: false } }
user.graphName = name
saveUser()
debouncedSaveStore()
goto("dailyNotes")
}
const pr = () => {
console.log(JSON.stringify(store))
}
const downloadBinary = () => {
const buffer = storeToBinary()
const data = new Blob([buffer],{ type: 'application/x-micro-roam' })
const url = URL.createObjectURL(data)
const button = document.createElement("a")
button.setAttribute('href',url)
button.setAttribute('download',`${store.graphName}.mrm`)
button.click()
}
const loadGraphminerNotes = () => {
fetch("./graphminer-store.json").then(text => text.json().then(json => {
store = json
user.graphName = store.graphName
saveUser()
start()
debouncedSaveStore()
}))
}
const taonotes = loadGraphminerNotes
const terminalCommands = {
blank,reset,flash,log,page,nolog,pr,taonotes,downloadBinary
}
/*
Here's what's lost importing Markdown that's saved in JSON:
block author
block create time
block end time
block references get confused with quotes - referencing a block just looks like it's text in quotes, "Block Refs". Micro Roam treats all quotes that could be block refs as block refs, which accidentally creates too many block refs
blocks with line breaks in them can split into two blocks
*/
const mdToStore = (files) => { // files: [{name, ext, fullName, text}]
const now = Date.now()
const oldStore = store
const blockStringIndex = {}
store = blankStore()
const getPageId = (title) => store.pagesByTitle[title] || newUid()
for (let file of files) {
const title = file.name
const text = file.text
const pageId = getPageId(title)
const page = { "create-time": now,title: title }
store.pages[pageId] = page
store.pagesByTitle[title] = pageId
if (text.length > 0) {
page.children = []
const addBlock = (string) => {
const blockId = newUid()
blockStringIndex[string] = blockId // overwrite previous string when multiple have the same :(
const block = { "create-time": now,string }
store.blocks[blockId] = block
page.children.push(blockId)
}
const stack = [page]
const blockBreaks = text.matchAll(/\n((?:    )*)- /g)
let idx = 2 // skip first block break, "- "
for (let blockBreak of blockBreaks) {
addBlock(text.substring(idx,blockBreak.index))
idx = blockBreak.index + blockBreak[0].length
}
addBlock(text.substring(idx))
}
}
console.log(store)
// for (let blockId in store.blocks) {
//   const block = store.blocks[blockId]
//   const { pageRefs,quotes } = parseMdBlock(block.string)
// }
// const { pageRefs,quotes } = parseMdBlock(blockText)
}
const parseMdBlock = (text) => {
}
/*
block refs ger replaced with "referenced block text". in order to recover these I have to search for a block with that text
if you have
'
text
- text
'
as a block, it will look like 2 blocks in markdown
example store:
*/
const blocToMd = (blocId) => {
let result = ""
const recurse = (blocId,level) => {
const bloc = store.blox[blocId]
if (bloc === undefined) console.log(blocId)
for (let i = 0; i < level; i++) {
result += "    "
}
result += "- " + bloc.s.replaceAll(/\(\(([a-zA-Z0-9\-_]+)\)\)/g,(match,group) => {
const b = store.blox[group]
if (b) {
return '"' + store.blox[group].s + '"'
} else {
return match
}
}
) + "\n"
for (let childId of bloc.k || []) {
recurse(childId,level + 1)
}
}
recurse(blocId,0)
return result
}
const storeToMdObjects = () => {
const result = []
for (let title in store.titles) {
const page = store.blox[store.titles[title]]
let text = ""
for (let k of page.k || []) {
text += blocToMd(k)
}
result.push({ fullName: title + ".md",text })
}
return result
}
const storeToMdZip = () => {
return filesToZip(storeToMdObjects())
}
</script>
</body>