<script>let idb=null,store=null,otherStores={},r;const basicBitchServerUrl="http://localhost:3000";let user,userText=localStorage.getItem("user"),usingLocalStore=!0,startFn=()=>gotoNoHistory("dailyNotes"),dataLoaded=!1,scriptsLoaded=!1;const setDataLoaded=()=>{scriptsLoaded&&start(),dataLoaded=!0},start=()=>{saveUser(),startFn(),user.h&&user.s.commitId!==user.s.syncCommitId&&debouncedSaveStore()},invalidateLocal=()=>{indexedDB.deleteDatabase("microroam");console.error("Local replica invalid. Resetting from server"),user.s.commitId=void 0,user.s.syncCommitId=void 0,localStorage.setItem("user",JSON.stringify(user)),localStorage.removeItem("store"),window.location.href=window.location.href};if(userText){if(user=JSON.parse(userText),user.h){const c=new Headers;c.set("h",user.h),user.s.syncCommitId&&c.set("commitid",user.s.syncCommitId);let e=`${basicBitchServerUrl}/get/${user.s.graphName}`;fetch(e,{method:"POST",headers:c}).then(async s=>{304!==s.status?200===s.status?(console.log(`server on commit ${s.headers.get("commitid")} local on commit ${user.s.syncCommitId}`),usingLocalStore=!1,s.json().then(e=>{console.log("got blox");const o=startFn;startFn=()=>{store=hydrateFromBlox(user.s.graphName,e),user.s.syncCommitId=s.headers.get("commitid"),o()},setDataLoaded()})):console.log("STORE NOT ON SERVER"):console.log("already up to date")})}const b=localStorage.getItem("store");if(b){try{store=JSON.parse(b),setDataLoaded()}catch(e){invalidateLocal()}r=indexedDB.open("microroam",5),r.onsuccess=e=>idb=e.target.result}else r=indexedDB.open("microroam",5),r.onsuccess=e=>{if(console.log("normal success"),idb=e.target.result,!0===usingLocalStore)try{idb.transaction(["stores"],"readonly").objectStore("stores").get(user.graphName).onsuccess=e=>{if(!0===usingLocalStore)if(e.target.result)try{store=JSON.parse(e.target.result.store),setDataLoaded()}catch(e){invalidateLocal()}else console.log("adding default graph")}}catch(e){}}}else user={s:{graphName:"default",theme:window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",topBar:"visible",logging:!1,spellcheck:!1,editingSpotlight:!0}},fetch("./default-store.json").then(e=>{e.json().then(e=>{store=e,startFn=()=>gotoNoHistory("pageTitle","Welcome to Micro Roam"),setDataLoaded()})}),r=indexedDB.open("microroam",5),r.onsuccess=e=>idb=e.target.result;r.onupgradeneeded=o=>{console.log("upgradeneeded");const s=r.result,e=Array.from(s.objectStoreNames);e.includes("stores")?(console.log(o),console.log(s),r.onsuccess=()=>{console.log("new success"),idb=o.target.result;const e=s.transaction(["stores"],"readonly").objectStore("stores");e.get(user.s.graphName).onsuccess=e=>{store=e.target.result.store;const o=oldStoreToRoamJSON[s.version](store);roamJsonToStore(user.s.graphName,o),saveStore(),setDataLoaded()}}):s.createObjectStore("stores",{keyPath:"graphName"})},r.onerror=e=>{console.log("error"),console.log(e),alert('In order to save your notes between sessions, Micro Roam needs access to IndexedDB. \nYou can allow access by exiting "private browsing" mode, or by using a newer browser, or by changing browser settings')}</script><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400&display=swap" rel="stylesheet"><style>*{outline:0;scrollbar-width:none}.dark{--background:#000000;--click:rgb(100, 100, 100);--text:#dbdbdb;--link:#3f84c0;--brackets:#a7b6c2;--block-ref:rgb(63, 63, 63);--bullet:#8f9091;--border:#afbeca;--bar:#565d63;--break:#838e97;--highlight:#685000;--page-ref:#3ac263;--shadow:rgb(98, 98, 98);--notification:#183d23;--query-background:#051809;--editing-background:#141414;--selected:#2d4a66}.light{--background:white;--click:rgb(197, 197, 197);--text:black;--link:rgb(54, 123, 184);--brackets:#a7b6c2;--block-ref:lightgrey;--bullet:#394b59;--border:#585e64;--bar:#7c858d;--shadow:#585e64;--break:#a8b4be;--highlight:rgb(255, 247, 128);--page-ref:#1cce37;--notification:#a4d1b1;--query-background:#b0dfbd;--editing-background:#e6e6e6;--selected:#abcdeb}a,button,input{font-family:Inter}input{border:none;background-color:var(--background);color:var(--text)}button{appearance:none;border:none;box-shadow:none;cursor:pointer;background-color:inherit;color:inherit;font-size:inherit}span{margin:0;padding:0}::-webkit-scrollbar{width:0%;height:0%}::selection{background-color:#85b7e8;color:var(--text)}body{scrollbar-width:0;font-family:Inter;font-weight:400;margin:0;color:var(--text);background-color:var(--background)}a{color:var(--link)}a:visited{color:var(--link)}#app{height:100%;width:100%;display:flex;flex-direction:column}#page-frame-outer{width:100%;overflow-y:scroll}#page-frame{margin:0 auto 30px;max-width:min(900px,100%)}#top-bar{width:100%;display:flex;flex-direction:row;align-content:space-between;background-color:var(--background)}#top-bar button{font-size:.9em;color:var(--bullet);padding:10px 10px 8px}.top-bar-transition{transition:margin-top .1s}#top-bar-left,#top-bar-right{display:flex;flex-direction:row}#top-connect,#top-hamburger{padding:7px 6px 2px 4px;cursor:pointer}#options-frame{position:fixed;top:36px;right:5px;display:flex;flex-direction:column}#options-frame button{border-radius:10px;padding:6px;display:block}#create-new-store{border-radius:10px;padding:6px;font-size:1.1em}#search-input{background-color:var(--background);color:var(--text);padding:3px 13px;margin:5px 3px 4px;display:block;font-size:1.1em;box-shadow:0 0 2px var(--bullet);border-radius:100px;flex-grow:1}#search-input::placeholder{color:var(--bullet)}#autocomplete-list,#command-list,#options-frame,#template-list{position:absolute;display:flex;flex-direction:column;background-color:var(--background);font-size:1.3em;border-radius:10px;box-shadow:0 0 6px 0 var(--shadow)}.autocomplete__suggestion[data-selected=true],.command__suggestion[data-selected=true],.template__suggestion[data-selected=true]{background-color:var(--click)}.autocomplete__suggestion,.command__suggestion,.template__suggestion{padding:10px;cursor:pointer;border-radius:5px}#search-result-list{position:absolute;display:flex;flex-direction:column;background-color:var(--background);font-size:1.3em;border-radius:5px;box-shadow:0 0 8px var(--shadow)}.search-result[data-selected=true]{background-color:var(--click)}.search-result{padding:7px;cursor:pointer;border-radius:5px}.page{margin-right:30px;margin-left:30px;position:relative}.page__title{font-size:38px;margin:35px 0 20px 0;font-weight:300}.backref-frame__body,.page__body{margin-left:20px}.backref-list__body{margin-left:10px}.backref-list__title{font-size:1.3em;padding:20px 0 0}.page-break{height:0;margin:50px 25px;border:1px solid var(--break);border-width:1px 0 0 0}.block{position:relative;border-radius:5px}.block[data-selected=true]{background-color:var(--selected)}.block__body{padding:5px 2px;white-space:pre-wrap}[data-editingspotlight=true] .block__body[data-editmode=true]{background-color:var(--editing-background);border-radius:4px}.block__bullet{cursor:pointer;position:absolute;left:-21px;top:4px}.block__children{margin-left:22px;position:relative}.block__children::before{display:block;position:absolute;content:"\200B";top:0;height:100%;width:6px;transform:translateX(-34px);border-left:1px solid var(--bar)}.block-focus-frame{margin:60px 0}.breadcrumb-page{cursor:pointer}.breadcrumb-block{cursor:pointer}.backref-frame__breadcrumb{margin:15px 0 5px 0;font-size:1.2em}.block-focus-frame__breadcrumb{margin:15px 0 5px 0;font-size:1.2em}.page-ref{position:relative}.page-ref__brackets{font-weight:lighter;color:var(--brackets)}.page-ref__graphname{font-weight:lighter;color:var(--page-ref)}.page-ref__body{color:var(--page-ref);font-weight:600}.page-ref:hover{cursor:pointer}.page-ref:hover>.page-ref__body{text-decoration:underline}.tag__body{color:var(--page-ref);position:relative;font-weight:600}.tag__graph-name{color:var(--page-ref);position:relative;font-weight:300}.tag:hover{text-decoration:underline;cursor:pointer}.block-ref{background-color:var(--block-ref)}.block-ref:hover{text-decoration:underline;cursor:pointer}.bold{font-weight:700}.italic{font-style:italic}.highlight{background-color:var(--highlight);border-radius:2px;padding:1px}.block-focus-frame{margin:35px 0 0 60px}.url{color:var(--link);text-decoration:underline;cursor:pointer}.literal{font-family:Inconsolata;font-size:1.15em}.code-block{font-family:Inconsolata;font-size:1.15em}.attribute{font-weight:700}.attribute:hover{cursor:pointer}.image-embed{max-width:100%}.todo-checkbox{transform:translateY(1px);height:14px;width:14px;margin:0 2px}.compute-failed{background-color:var(--query-background);border-radius:4px;padding:5px 2px;margin-left:-2px}#terminal{font-family:Inconsolata;width:100%;padding:8px;background-color:#000;color:#fff}.query-frame{background-color:var(--query-background);border-radius:8px;padding:1px 12px 18px;margin:3px 0}.notification{text-align:center;min-width:300px;position:fixed;left:50%;transform:translateX(-50%);top:-40px;margin-top:0;opacity:1;transition:top .25s ease-out,opacity .2s linear;padding:20px;background-color:var(--notification);border-radius:8px}#login,#signup{position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--background);text-align:center}#login-form,#signup-form{position:fixed;top:28%;left:50%;transform:translateX(-50%);padding:13px 20px 20px;border-radius:12px;display:flex;flex-direction:column;justify-content:space-between}#login input,#signup input{background-color:var(--background);color:var(--text);font-size:1.4em;border-radius:3px;display:block;padding:4px;margin-bottom:13px}#login button,#signup button{position:fixed;bottom:19%;left:50%;transform:translateX(-50%);display:block;padding:4px;border-radius:3px;background-color:var(--background);color:var(--placeholder)}#login button:focus,#signup button:focus{font-weight:700}#login p,#signup p{left:50%;font-size:1.7em;color:var(--placeholder);padding:4px;margin-bottom:20px;margin-top:65px}#login .exit-to-main,#signup .exit-to-main{bottom:9%}.really-want-to{padding:80px;position:fixed;top:30%;right:50%;transform:translateX(50%);background-color:var(--background);box-shadow:0 0 2px var(--shadow);border-radius:8px;text-align:center;flex-direction:column}.really-want-to button{margin-top:30px;display:block}</style><div id="html"><p style="font-family:Inter">please enable JavaScript</div><script>const elById = (str) => document.getElementById(str)
const getTemp = (str) => elById(str).content.firstElementChild

const allHtml = `<div id="app">
  <div id="top-bar" style="margin-top:-43px">
    <div id="top-bar-left">
      
    </div>
    <input id="search-input" placeholder="search" tabindex="-1">
    <div id="top-bar-right">
      
    </div>
    
    <svg id="top-connect" width="25" height="25">
      <line x1="12.5" y1="20" x2="21" y2="9" stroke="var(--bullet)" />
      <line x1="12.5" y1="20" x2="4" y2="9" stroke="var(--bullet)" />
      <line x1="12.5" y1="20" x2="12.5" y2="5" stroke="var(--bullet)" />
      
      <circle cx="4" cy="9" r="3.5" stroke="var(--bullet)" />
      <circle cx="12.5" cy="5" r="3.5" stroke="var(--bullet)" />
      <circle cx="21" cy="9" r="3.5" stroke="var(--bullet)" />
      
      <circle cx="12.5" cy="20" r="4.5" stroke="var(--bullet)" />
      <circle cx="12.5" cy="20" r="2.5" fill="var(--bullet)" />
    </svg>
    
    <svg id="top-hamburger" width="25" height="25">
      <circle cx="12.5" cy="5" r="2.5" fill="var(--bullet)" />
      <circle cx="12.5" cy="13" r="2.5" fill="var(--bullet)" />
      <circle cx="12.5" cy="21" r="2.5" fill="var(--bullet)" />
    </svg>
    
  </div>

  <div id="top-bar-hidden-hitbox" style="position:fixed;height:20px;width:100%;display:none;"></div>


  <div id="terminal" contenteditable="true" style="display:none"></div>

  <div id="page-frame-outer">
    <div id="page-frame">

    </div>
  </div>
  
  <div id="options-frame" style="display:none">
  </div>

  <!-- inline styles on this site are all edited directly by js -->
  <div id="autocomplete-list" style="display:none"></div>
  <div id="command-list" style="display:none"></div>
  <div id="search-result-list" style="display:none"></div>
  <div id="template-list" style="display:none"></div>

  <div id="login" style="display:none">
    <p>Login</p>
    <form id="login-form">
      <input type="email" id="login-email" placeholder="email">
      <input type="password" id="login-password" placeholder="password">
      <input type="submit" style="height:0px" tabindex="-1">
    </form>
    <button id="switch-to-signup">Sign up</button>
    <button class="exit-to-main">Back</button>
  </div>

  <div id="signup" style="display:none">
    <p>Sign up</p>
    <form id="signup-form">
      <input type="email" id="signup-email" placeholder="email">
      <input type="text" id="signup-username" placeholder="username">
      <input type="password" id="signup-password" placeholder="password">
      <input type="submit" style="height:0px" tabindex="-1">
    </form>
    <button id="switch-to-login">Login</button>
    <button class="exit-to-main">Back</button>
  </div>

  <div id="really-want-to-leave" class="really-want-to" style="display:none">
    Your data will be lost if you sign out now
    <button>Continue</button>
  </div>
</div>

<title>Micro Roam</title>


<template id="page">
  <div class="page">
    <h1 class="page__title" contenteditable="true" tabindex="-1"></h1>

    <div class="page__body">

    </div>
    <div class="page__backlinks">

    </div>
  </div>
</template>

<template id="block">
  <div class="block">
    <svg class="block__bullet" width="20" height="20">
      <circle cx="10" cy="10.5" r="3" fill="var(--bullet)" />
    </svg>
    <div class="block__body" contenteditable="true" tabindex="-1"></div>
    <div class="block__children">

    </div>
  </div>
</template>

<template id="backref-list">
  <div class="backref-list">
    <div class="backref-list__title">Linked References</div>
    <div class="backref-list__body"></div>
  </div>
</template>

<template id="query-frame">
  <div class="query-frame"></div>
</template>

<template id="block-focus-frame">
  <div class="block-focus-frame">
    <div class="block-focus-frame__breadcrumb"></div>
    <div class="block-focus-frame__body"></div>
    <div class="block-focus-frame__backlinks"></div>
  </div>
</template>

<template id="backref-frame">
  <div class="backref-frame">
    <div class="backref-frame__breadcrumb"></div>
    <div class="backref-frame__body"></div>
  </div>
</template>

<template id="page-ref">
  <span class="page-ref"><span class="page-ref__brackets"></span><span class="page-ref__graphname"></span><span class="page-ref__body"></span><span
      class="page-ref__brackets"></span></span>
</template>

<template id="tag">
  <span class="tag"><span class="tag__graph-name"></span><span class="tag__body"></span></span>
</template>

<template id="image-embed">
  <img class="image-embed">
</template>

<template id="compute-failed">
  <span class="compute-failed"><span class="compute-failed__brackets"></span><span
      class="compute-failed__body"></span><span class="compute-failed__brackets"></span></span>
</template>

<template id="todo-checkbox">
  <input type="checkbox" class="todo-checkbox">
</template>

<template id="video-embed">
  <iframe class="video-embed" width="560" height="315" title="YouTube video player" frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen></iframe>
</template>

<template id="breadcrumb-page">
  <span class="breadcrumb-page"></span>
</template>

<template id="notification">
  <div class="notification"></div>
</template>

<template id="breadcrumb-block">
  <span class="breadcrumb-block"><span class="breadcrumb-block__arrow">-></span><span
      class="breadcrumb-block__body"></span></span>
</template>

<template id="autocomplete__suggestion">
  <div class="autocomplete__suggestion"></div>
</template>

<template id="command__suggestion">
  <div class="command__suggestion"></div>
</template>

<template id="template__suggestion">
  <div class="template__suggestion"></div>
</template>

<template id="search-result">
  <div class="search-result"></div>
</template>`

const allFrame = elById("html")

allFrame.innerHTML = allHtml

const topBarRight = elById('top-bar-right')
const topBarLeft = elById('top-bar-left')
const optionsFrame = elById('options-frame')

const topButtons = {}

let topButtonNames = ["Help", "Daily Notes", "Report Issue", "Sign Up", "Sign Out", "Login", "Upload", "Download",]
for (let name of topButtonNames) {
  topButtons[name] = document.createElement('button')
  topButtons[name].innerText = name
  topButtons[name].tabindex = -1
}

topButtons["Create New Graph"] = document.createElement('input')
topButtons["Create New Graph"].placeholder = "Create New Graph"
topButtons["Create New Graph"].id = "create-new-store"
topButtons["Create New Graph"].type = "text"
topButtons["Create New Graph"].size = 15

const disconnectedFileInput = document.createElement('input')
disconnectedFileInput.type = "file"

topButtonNames = Object.keys(topButtons)

let toShowOnTopBar = ["help", "Daily Notes", "Report Issue", "Sign Up"]

const layoutTopBar = () => {
  const split = Math.round(toShowOnTopBar.length / 2)
  for (let i = 0; i < split; i++) {
    topBarLeft.appendChild(topButtons[topButtonNames[i]])
  }
  for (let i = split; i < toShowOnTopBar.length; i++) {
    topBarRight.appendChild(topButtons[topButtonNames[i]])
  }
  for (let name of topButtonNames) {
    if (!toShowOnTopBar.includes(name)) {
      optionsFrame.appendChild(topButtons[name])
    }
  }
}
layoutTopBar()


// Cursor info. Raw info stored in JSON, DOM elements cached in lots of random vars
let sessionState = { pageFrame: "dailyNotes", focusId: null, scroll: 0, position: null }

// these two stored for re-focusing dom nodes after they're moved
let focusNode = null
let focusOffset = null

// accessing current block
let focusBlock = null
let focusBlockBody = null

// accessing current editing spans
let editingTemplateExpander = null
let editingCommandElement = null
let editingLink = null
let editingTitle = null

let focusSuggestion = null

let dragSelectStartBlock = null
let dragSelect = null
let clipboardData = null


const SEARCH_RESULT_LENGTH = 12

// Singleton elements


document.body.className = user.s.theme

const topBar = document.getElementById("top-bar")
const topBarHiddenHitbox = document.getElementById("top-bar-hidden-hitbox")

if (user.s.topBar === 'visible') {
  topBar.style.marginTop = "0px"
  topBarHiddenHitbox.style.display = "none"
}
setTimeout(() => topBar.className = "top-bar-transition", 200)


const pageFrame = elById("page-frame")
const pageFrameOuter = elById("page-frame-outer")
const searchInput = elById("search-input")
const terminalElement = elById("terminal")

const searchResultList = elById("search-result-list")
searchResultList.dataset.templateName = "search-result"

const autocompleteList = elById("autocomplete-list")
autocompleteList.dataset.templateName = "autocomplete__suggestion"

const inlineCommandList = elById("command-list")
inlineCommandList.dataset.templateName = "command__suggestion"

const templateList = elById("template-list")
templateList.dataset.templateName = "template__suggestion"

const switchToLogin = elById("switch-to-login")
const switchToSignup = elById("switch-to-signup")
const signupElement = elById("signup")
const loginElement = elById("login")

const reallyWantToLeaveElement = elById("really-want-to-leave")

const appElement = elById('app')

const topHamburgerElement = elById('top-hamburger')

const connectFrame = elById('connect-frame')


// login/signup
const loginForm = elById("login-form")
const loginEmailElement = elById("login-email")
const loginPasswordElement = elById("login-password")
const signupForm = elById("signup-form")

const signupUsernameElement = elById("signup-username")
const signupEmailElement = elById("signup-email")
const signupPasswordElement = elById("signup-password")

// Templates
const pageTemplate = getTemp("page")
const blockTemplate = getTemp("block")
const backrefListTemplate = getTemp("backref-list")
const blockFocusFrameTemplate = getTemp("block-focus-frame")
const searchResultTemplate = getTemp("search-result")
const breadcrumbBlockTemplate = getTemp("breadcrumb-block")
const breadcrumbPageTemplate = getTemp("breadcrumb-page")
const backrefFrameTemplate = getTemp("backref-frame")
const notificationTemplate = getTemp("notification")

// Block parsing Templates
const tagTemplate = getTemp("tag")
const pageRefTemplate = getTemp("page-ref")
const imageEmbedTemplate = getTemp("image-embed")
const computeFailedTemplate = getTemp("compute-failed")
const todoCheckboxTemplate = getTemp("todo-checkbox")
const videoEmbedTemplate = getTemp("video-embed")
const queryFrameTemplate = getTemp("query-frame")

const textEncoder = new TextEncoder()

const CHARS_64 = "-_0123456789abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ"
const CHARS_16 = "0123456789abcdef"

let newUid
{
  let UidRandomContainer = new Uint8Array(9)
  newUid = () => {
    let result
    do {
      crypto.getRandomValues(UidRandomContainer)
      result = ""
      for (let i = 0; i < 9; i++) {
        result += CHARS_64[UidRandomContainer[i] % 64]
      }
    } while (store.blox[result] !== undefined)
    return result
  }
}

// I'm using base64 126 bit UUIDs instead because they're less length in JSON and they are more ergonomic to write in markup like ((uuid)) if I ever want to do that
let newUUID
{
  let UuidRandomContainer = new Uint8Array(21)
  newUUID = () => { // this is 126 bits, 21xbase64
    crypto.getRandomValues(UuidRandomContainer)
    let result = ""
    for (let i = 0; i < 21; i++) {
      result += CHARS_64[UuidRandomContainer[i] % 64]
    }
    return result
  }
}



const applyDif = (string, dif) => {
  // not using dif.s||result.length because dif.s could be 0
  let end = string.length
  if (dif.s !== undefined) end = dif.s
  const start = end - (((dif.d !== undefined) && dif.d.length) || 0)
  return string.substring(0, start) + (dif.i || "") + string.substring(end)
}

const unapplyDif = (string, dif) => {
  const dLen = (((dif.d !== undefined) && dif.d.length) || 0)
  const iLen = (((dif.i !== undefined) && dif.i.length) || 0)
  if (dif.s !== undefined) {
    const start = dif.s - dLen
    const end = start + iLen
    return string.substring(0, start) + (dif.d || "") + string.substring(end)
  } else {
    const start = string.length - dLen - iLen
    return string.substring(0, start) + (dif.d || "")
  }
}


const undoEditBlox = (edit, blox) => {

  // console.log(edit)
  const [op, id, p1, p2, p3, p4] = edit
  switch (op) {
    case "cr":
      const parent = blox[id].p
      if (parent) {
        blox[parent].k = blox[parent].k.filter(x => x !== id)
      }
      delete blox[id]
      break
    case "dl":
      blox[id] = p1
      const parentId = p1.p, idx = p2
      if (parentId) {
        if (!blox[parentId].k) blox[parentId].k = []
        if (idx !== undefined) {
          blox[parentId].k.splice(idx, 0, id)
        } else {
          blox[parentId].k.push(id)
        }
      }
      break
    case "mv":
      const oldParent = p1, oidx = p2, newParent = p3, nidx = p4
      const block = blox[id]
      blox[oldParent].k = blox[oldParent].k.filter(x => x != id)
      block.p = newParent
      if (!blox[newParent].k) blox[newParent].k = []
      blox[newParent].k.splice(nidx, 0, id)
      break
    case "df":
      const df = p1
      const bloc = blox[id]
      bloc.et = commit.time
      bloc.s = unapplyDif(bloc.s, df)
      break
  }
}


const doEditBlox = (edit, blox, time) => {
  const [op, id, p1, p2, p3, p4] = edit
  switch (op) {
    case "dl":
      const parent = blox[id].p
      if (parent) {
        blox[parent].k = blox[parent].k.filter(x => x !== id)
      }
      delete blox[id]
      break
    case "cr":
      blox[id] = {
        ct: time,
        s: ""
      }
      const parentId = p1, idx = p2
      if (parentId !== undefined) {
        blox[id].p = parentId
        if (blox[parentId].k === undefined) blox[parentId].k = []
        if (idx === undefined) {
          blox[parentId].k.push(id)
        } else {
          blox[parentId].k.splice(idx, 0, id)
        }
      }
      break
    case "mv":
      const newParent = p1, nidx = p2, oldParent = p3
      const block = blox[id]
      blox[oldParent].k = blox[oldParent].k.filter(x => x != id)
      block.p = newParent
      if (!blox[newParent].k) blox[newParent].k = []
      blox[newParent].k.splice(nidx, 0, id)
      break
    case "df":
      const df = p1
      const bloc = blox[id]
      bloc.et = time
      bloc.s = applyDif(bloc.s, df)
      break
  }
}

let getProcessMemory
try {
  performance.memory.heapUsed
  getProcessMemory = () => (performance.memory && performance.memory.heapUsed)
} catch (e) {
  process.memoryUsage().heapUsed
  getProcessMemory = () => process.memoryUsage().heapUsed
}

class LruCache {
  constructor(fetcher, maxProcessMemory = 1500000000) { // 1.5G
    this.maxProcessMemory = maxProcessMemory
    this.fetcher = fetcher
    this.map = new Map()
  }
  async get(key) {
    const val = this.map.get(key)
    if (val !== undefined) {
      this.map.delete(key)
      this.map.set(key, val)
      return val
    } else {
      const fetched = await this.fetcher(key)
      if (fetched) {
        this.map.set(key, fetched)
      }
      if (getProcessMemory() > this.maxProcessMemory) {
        for (const item of this.map) {
          this.map.delete(item[0])
          break
        }
      }
      return fetched
    }
  }
}

const promisify = (fn) => (...args) => new Promise((resolve, err) => fn(...args, resolve))

// this is v slow, 7M dates / s
// not using bit shifts here because this needs to work with 64 bit ints and JS doesn't expose 64 bit bit-shifts
const intToBase64 = (int) => {
  if (int === undefined) return
  let str = ""
  while (int > 0) {
    str = "" + CHARS_64[int % 64] + str
    int = Math.floor(int / 64)
  }
  return str
}

const base64ToInt = (str) => {
  let result = 0
  for (let i = 0; i < str.length; i++) {
    result += CHARS_64.indexOf(str[i]) * Math.pow(64, (str.length - i - 1))
  }
  return result
}


try {
  exports.applyDif = applyDif
  exports.unapplyDif = unapplyDif
  exports.doEditBlox = doEditBlox
  exports.undoEditBlox = undoEditBlox
  exports.promisify = promisify
  exports.LruCache = LruCache
  exports.newUid = newUid
  exports.newUUID = newUUID
  exports.base64ToInt = base64ToInt
  exports.intToBase64 = intToBase64
} catch (e) {

}
//~

// deepcopy for JSON-ifiables, but faster than JSON.parse . JSON.stringify
const cpy = (x) => {
  if (typeof x === "object") {
    if (x instanceof Array) {
      return x.map(cpy)
    } else {
      const result = {}
      for (let key in x) {
        result[key] = cpy(x[key])
      }
      return result
    }
  } else return x
}

const monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
]

const getOrdinal = (i) => {
  const j = i % 10,
    k = i % 100
  if (j == 1 && k != 11) return i + "st"
  if (j == 2 && k != 12) return i + "nd"
  if (j == 3 && k != 13) return i + "rd"
  return i + "th"
}

const formatDate = (date) =>
  `${monthNames[date.getMonth()]} ${getOrdinal(
    date.getDate()
  )}, ${date.getFullYear()}`

const formatTime = (date) => {
  return date.getHours() + ":" + date.getMinutes()
}

const unFormatDate = (string) => {
  const match = string.match(/([a-zA-Z]+) ([0-9]{1,2})(?:st|nd|rd|th), ([0-9]{4})/)
  if (match && monthNames.includes(match[1])) {
    return new Date()
  }
}

// const formatDateId = (date) => `${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`
const formatDateYMD = (date) => `${date.getFullYear()}-${formatInt(date.getMonth() + 1, 2)}-${formatInt(date.getDate(), 2)}`

const truncateElipsis = (text, limit = 40) => {
  if (text.length > limit) {
    return text.substring(0, limit - 3) + "..."
  }
  return text
}

const getTomorrowDateString = () => {
  return formatDate(new Date(Date.now() + 86400000))
}

const getYesterdayDateString = () => {
  return formatDate(new Date(Date.now() - 86400000))
}

const getLastWeekDateString = () => {
  const obj = new Date(Date.now())
  obj.setDate(obj.getDate() - 7)
  return formatDate(obj)
}

const getNextWeekDateString = () => {
  const obj = new Date(Date.now())
  obj.setDate(obj.getDate() + 7)
  return formatDate(obj)
}

const formatInt = (int, digits) => {
  const raw = int.toString()
  return ("0".repeat(digits - raw.length) + raw)
}

const clamp = (x, min, max) => Math.max(min, Math.min(x, max))


// firefox rounds to 1ms. rounding is supposedly to protect against Specter and related vulnerabilities
const ustime = () => {
  const p = Math.floor((performance.timing.navigationStart + performance.now()) * 1000)
  console.log(p)
  return p
}

const pushToArrInObj = (obj, key, val) => {
  if (obj[key] === undefined) {
    obj[key] = [val]
  } else obj[key].push(val)
}

const canWriteBloc = (blocId) => { // todo implement readonly blocs
  return true
}

/*
Paralel difs are too much work. Switching to simpler single command buffer
I feel like I had a specification for diffs, but I seem to have lost it.
{d:string,i:string,s:number}
d: string to delete backwards (keep string instead of length so it's reversible)
i: string to insert forwards
s: position. defaults to end of string

["cr"|"dl"|"df"|"mv", ]

*/

const isSynced = () => user.s.commitId === user.s.syncCommitId

const diff = (string, oldString) => { // todo real diff
  return { d: oldString, i: string }
}

let undoCommitList = []
let undoCommitSessionStateList = []
let undoCommitInProgress = []

let masterCommitList = []
let masterCommitInProgress = []


const undoEditCacheStuff = (edit) => {
  const [op, id, p1, p2, p3, p4] = edit
  console.log(edit)
  switch (op) {
    case 'cr':
      if (p1 === undefined) {
        delete store.titles[p1.s]
      }
      break
    case 'df':
      setLinks(store, id)
      const bloc = store.blox[id]
      if (bloc.p === undefined) {
        const oldString = applyDif(bloc.s, p1) // this work could be deduplicated, but AAAAGGGGHHHH there's already so much coupling to deduplicate work!
        delete store.titles[oldString]
        store.titles[bloc.s] = id
      }
      break
  }
}

const undo = () => {
  const commit = undoCommitList.pop()
  sessionState = undoCommitSessionStateList.pop()
  for (let i = commit.edits.length - 1; i >= 0; i--) {
    const edit = commit.edits[i]
    undoEditBlox(edit, store.blox)
    undoEditCacheStuff(edit)
  }
}

const doEditCacheStuff = (edit, includeInnerOuter = false) => {
  const [op, id, p1, p2, p3, p4] = edit
  switch (op) {
    case 'dl':
      if (!p1.p) {
        delete store.titles[p1.s]
      }
      const refsOut = store.forwardRefs[id]
      if (refsOut) {
        for (let ref of refsOut) {
          const backRefs = store.refs[ref]
          if (backRefs.length === 1) {
            delete store.refs[ref]
          } else {
            store.refs[ref] = backRefs.filter(x => x != id)
          }
        }
      }
      const refsIn = store.refs[id]
      if (refsIn) {
        // todo turn refs to dead pages into plaintext
      }
      break
    case 'df':
      setLinks(store, id, includeInnerOuter)
      const bloc = store.blox[id]
      if (bloc.p === undefined) {
        const oldString = unapplyDif(bloc.s, p1) // this work could be deduplicated, but AAAAGGGGHHHH there's already so much coupling to deduplicate work!
        delete store.titles[oldString]
        if (store.titles[bloc.s] !== undefined) {
          console.error(`duplicate block title ${bloc.s}`)
          return
        }
        store.titles[bloc.s] = id
      }
      break
  }
}

const doEdit = (...edit) => {
  const time = intToBase64(Date.now())
  undoCommitInProgress.push(edit)
  masterCommitInProgress.push(edit)
  print(edit)
  // console.log(edit)
  doEditBlox(edit, store.blox, time)
  doEditCacheStuff(edit)
}

const commit = () => {
  const newId = newUUID()
  undoCommitList.push({ id: newId, t: intToBase64(Date.now()), edits: undoCommitInProgress })
  undoCommitSessionStateList.push(cpy(sessionState))
  user.s.commitId = newId
  undoCommitInProgress = []
  setTimeout(() => {
    debouncedSaveStore()
    saveUserJustLocalStorage()
  }, 0)
}

const commitEdit = (...edit) => {
  doEdit(...edit)
  commit()
}

const saveStore = (force = false) => {
  // stringify blox, then stringify rest of store and insert blox string to avoid re-stringifying blox
  const blox = store.blox
  const bloxText = JSON.stringify(blox)
  let fullString = "{"
  for (let key in store) {
    if (key !== 'blox' && store[key] !== undefined)
      fullString += '"' + key + '":' + JSON.stringify(store[key]) + ","
  }
  fullString += '"blox":' + bloxText + '}'
  saveStoreToBasicBitchServer(bloxText, force)
  saveStoreStringLocal(fullString)
}

const saveStoreIncremental = () => {
  syncEditsWithBasicBitchServer()
  saveStoreStringLocal(JSON.stringify(store))
}

const saveStoreStringLocal = (string) => {
  try {
    localStorage.setItem('store', string)
  } catch (e) {
    // mainly catch localstorage size limit
    localStorage.removeItem('store')
    console.error(`Local Storage Failure: ${e}`)
  }
  const transaction = idb.transaction(["stores"], "readwrite")
  const storeStore = transaction.objectStore("stores")
  const req = storeStore.put({
    graphName: store.graphName,
    store: string
  })
  req.onsuccess = () => {
    console.log("saved")
  }
  req.onerror = (event) => {
    console.log("save error")
    console.log(event)
  }
}

let saveStoreTimeout = null

const debouncedSaveStore = () => {
  if (user.s.commitId !== user.s.syncCommitId) {
    clearTimeout(saveStoreTimeout)
    saveStoreTimeout = setTimeout(saveStoreIncremental, 300)
  }
}

const print = (text) => {
  if (user.s.logging) {
    console.log(text)
  }
}

// @inprogress
// originally I wanted to just collect changes done on each id individually and consolidate them, but the fact that {i:"a"} operates on the end and {i:"a", p:1} operates from the beginning means you can't consolidate between end and middle changes without knowing starting or ending configuration. could be fixed by indexing everthing from the end
// todo index diffs from the end instead of the beginning to make it consistent with end-default
// also moving blocks changes the idx of other children, which means moves on different blocks aren't independent
// so what really needs to happen is a maximal partial state must be created and then compressed
// requires indexing around holes / insertions into child lists
const mergeEdits = (edits) => {
  const result = []
  const state = {}
  for (let i = 0; i < edits.length; i++) {
    const edit = edits[i]

  }
}

const macros = {}
macros.nocommit = {
  copyBlock: (oldId, parentId, idx) => {
    // todo make this stop infinite looping when you copy a block into its own children using snapshots when I get those
    const copyBlock = (oldId, parentId, idx) => {
      const newId = newUid()
      const block = store.blox[oldId]
      doEdit("cr", newId, parentId, idx)
      doEdit("df", newId, diff(block.s, ""))
      if (block.k) {
        for (let i = 0; i < block.k.length; i++) {
          const kidId = block.k[i]
          copyBlock(kidId, newId, i)
        }
      }
      return newId
    }
    return copyBlock(oldId, parentId, idx)
  },
  delete: (id) => {
    const bloc = store.blox[id]
    let idx = undefined
    if (bloc.p) idx = store.blox[bloc.p].k.indexOf(id)
    doEdit("dl", id, cpy(bloc), idx)
  },
  write: (id, string) => {
    doEdit("df", id, diff(string, store.blox[id].s))
  },
  writePageTitle: (id, string) => {
    const oldString = store.blox[id].s
    // create page first so that changing the backrefs will reference existing page instead of making new page
    doEdit("df", id, diff(string, oldString))
    for (let ref of store.refs[id] || []) {
      const bloc = store.blox[ref]
      const oldBlocString = bloc.s
      const newBlocString = bloc.s.replaceAll(oldString, string)
      console.log(oldBlocString)
      console.log(newBlocString)
      doEdit("df", ref, diff(newBlocString, oldBlocString))
    }
  },
  createPage: (title) => {
    if (store.titles[title]) {
      console.error(`tried to create page that already exists ${title}`)
      return
    }
    console.log(`making page ${title}`)
    const id = newUid()
    doEdit("cr", id)
    doEdit("df", id, diff(title, ""))
    return id
  },
  create: (parentId, idx) => {
    const id = newUid()
    doEdit('cr', id, parentId, idx)
    return id
  },
  move: (id, parentId, idx) => {
    const bloc = store.blox[id]
    if (idx === undefined) idx = store.blox[parentId].k.length
    doEdit("mv", id, parentId, idx, bloc.p, store.blox[bloc.p].k.indexOf(id))
  }
}
for (let k in macros.nocommit) {
  macros[k] = (...args) => {
    const result = macros.nocommit[k](...args)
    commit()
    return result
  }
}


// blox or bloc means either block or page. they're almost the same, just one has a parent and the other doesn't, and linking syntax is different
const blankStore = () => ({
  blox: {},
  titles: {},

  refs: {},
  forwardRefs: {},
  innerRefs: {},
  outerRefs: {},

  roamProps: {},
  ownerRoamId: undefined,
  graphName: undefined,
})

const bloxProps = [
  "s",  // string
  "p",  // parent
  "ct", // create time
  "k", // kids
  "et", // edit time
  "cu", // create user
  "eu"  // edit user
]

const gcPage = (store, pageId) => {
  if (isPageEmpty(store, pageId))
    macros.nocommit.delete(pageId)
}

const isPageEmpty = (store, pageId) => {
  const page = store.blox[pageId]
  if (store.refs[pageId] !== undefined && store.refs[pageId].length > 0) return false
  if (page.k) {
    if (page.k.length > 1) return false
    if (page.k.length === 0) return true
    const childId = page.k[0]
    return isBlockEmpty(store, childId)
  }
  return true
}

const isBlockEmpty = (store, blockId) => {
  const block = store.blox[blockId]
  return block.s === "" && (block.k === undefined || block.k.length === 0)
}

const fixParents = () => {
  for (let id in store.blox) {
    delete store.blox[id].p
  }
  for (let id in store.blox) {
    const bloc = store.blox[id]
    for (let childId of bloc.k || []) {
      store.blox[childId].p = id
    }
  }
}

const fixDuplicatePages = () => {
  const titles = {}
  for (let id in store.blox) {
    const bloc = store.blox[id]
    if (!bloc.p) {
      pushToArrInObj(titles, store.blox[id].s, id)
    }
  }
  for (let id in titles) {
    const arr = titles[id]
    for (let i = 1; i < arr.length; i++) {
      for (let k of store.blox[arr[i]].k || []) {
        macros.move(k, arr[0])
      }
      macros.delete(arr[i])
    }
  }
}

// 1             2              3   4         5         6       7
// page-ref-open page-ref-close tag block-ref attribute literal code-block
const parseRegexJustLinks = /(\[\[)|(\]\])|#([\/a-zA-Z0-9_-]+)|\(\(([a-zA-Z0-9\-_]+)\)\)|(^[\/a-zA-Z0-9_-]+)::|`([^`]+)`|```/g

const setLinks = (store, blocId, doInnerOuterRefs = false, nogc = false) => {
  for (let ref of store.forwardRefs[blocId] || []) {
    store.refs[ref] = store.refs[ref].filter(x => x !== blocId)
    if (!nogc) gcPage(store, ref)
  }
  const forwardRefs = []
  store.forwardRefs[blocId] = forwardRefs

  let doRef
  if (doInnerOuterRefs) {
    doRef = (ref) => {
      if (ref in store.refs) {
        store.refs[ref].push(blocId)
      } else {
        store.refs[ref] = [blocId]
      }
      forwardRefs.push(ref)
    }
  } else {
    doRef = (ref) => {
      if (ref in store.refs) store.refs[ref].push(blocId)
      else store.refs[ref] = [blocId]
      forwardRefs.push(ref)
    }
  }

  const doTitle = (title) => {
    let ref = store.titles[title]
    if (ref === undefined) {
      ref = macros.nocommit.createPage(title) // todo manage the commit on this one. Need some standard for when to commit / when to do
    }
    doRef(ref)
  }

  const bloc = store.blox[blocId]
  const text = bloc.s
  const matches = text.matchAll(parseRegexJustLinks)
  // Roam allows like whatevs in the tags and attributes. I only allow a few select chars.

  let idx = 0
  let stackTop = undefined // s is string, t is type
  let stack = []

  for (let match of matches) {
    if (stack.length === 0 || stackTop.t === "cb") {
      if (match[1]) {
        const pageRefElement = { t: "pr", s: "" }
        stack.push(pageRefElement)
        stackTop = stack[stack.length - 1]
      } else if (match[3]) {
        doTitle(match[3])
      } else if (match[5]) {
        doTitle(match[5])
      } else if (match[4]) {
        if (store.blox[match[4]] !== undefined)
          doRef(match[4])
      } else if (match[7]) {
        if (stackTop && stackTop.t === "cb") {
          stack.pop()
        } else {
          const codeBlockElement = { t: 'cb', s: "" }
          stack.push(codeBlockElement)
          stackTop = stack[stack.length - 1]
        }
      }
    } else {
      stackTop.s = stackTop.s + text.substring(idx, match.index)
      idx = match.index
      if (match[1]) {
        const pageRefElement = { t: "pr", s: "" }
        stackTop.s = stackTop.s + "[["
        stack.push(pageRefElement)
        stackTop = stack[stack.length - 1]
      } else if (match[2]) {
        let s = "]]"
        if (stackTop.t === "pr") {
          s = stackTop.s + "]]"
          doTitle([stackTop.s])
          stack.pop()
          stackTop = stack[stack.length - 1]
        }
        if (stackTop !== undefined) stackTop.s = stackTop.s + s
      } else if (match[3]) {
        doTitle(match[3])
        stackTop.s = stackTop.s + match[0]
      } else if (match[5]) {
        stackTop.s = stackTop.s + match[0]
        doTitle(match[5])
      } else if (match[4]) {
        if (store.blox[match[4]] !== undefined)
          doRef(match[4])
        stackTop.s = stackTop.s + match[0]
      } else if (match[7]) {
        if (stackTop && stackTop.t === "cb") {
          stack.pop()
        } else {
          const codeBlockElement = { t: 'cb', s: "" }
          stack.push(codeBlockElement)
          stackTop = stack[stack.length - 1]
        }
      } else {
        stackTop.s = stackTop.s + match[0]
      }
    }
    idx = match.index + match[0].length
  }
  if (forwardRefs.length === 0) delete store.forwardRefs[blocId]
}

const generateRefs = (store) => {
  const stime = performance.now()
  store.refs = {}
  store.forwardRefs = {}
  for (let blocId in store.blox) {
    setLinks(store, blocId)
  }
  console.log(`gen refs took ${performance.now() - stime}`)
}

const mergeLists = (list1, list2) => {
  for (let x of list2) {
    if (!list1.includes(x)) list1.push(x)
  }
}

// destructured return here costs me like 3ms over 10_000 calls. unfortunate
const arrSetDiff = (cur, old) => {
  let added = []
  let deleted = []
  for (let ref of cur) {
    if (!old.includes(ref)) added.push(ref)
  }
  for (let oldRef of old) {
    if (!cur.includes(oldRef)) deleted.push(oldRef)
  }
  return { added, deleted }
}

// @INPROGRESS
const propagateRefs = (blocId, refs, oldRefs) => {
  const { added, deleted } = arrSetDiff(refs, oldRefs)
  const bloc = store.blox[blocId]
  if (bloc.p) {
    let p = bloc.p
    while (p) {
      const pbloc = store.blox[p]
      const prefs = store.forwardRefs[p]
      for (let i = 0; i < added.length; i++) { // warning i modified inside loop during deletions
        const adr = added[i]
        if (prefs.includes(adr)) {
          added[i] = added.pop()
          i -= 1
        } else {
          prefs.push(adr)
        }
      }
      p = pbloc.p
    }
  }
  let parent = bloc;
  do {
    parent = store.blox[parent.p]
    for (let i = 0; i < added.length; i++) {

    }
  } while (parent.p)

}

// inner refs are refs in a page/block and any pages/blocks within it
const generateInnerRefs = () => {
  // algorithm: for each ref anywhere, add it to each of its parent's uprefs
  const stime = performance.now()
  store.innerRefs = {}
  for (let blocId in store.forwardRefs) {
    const refs = store.forwardRefs[blocId]
    let id = blocId
    while (id) {
      if (!store.innerRefs[id]) store.innerRefs[id] = []
      mergeLists(store.innerRefs[id], refs)
      id = store.blox[id].p
    }
  }
  // console.log(`innerrefs took ${performance.now() - stime}`)
}

// outer refs are refs in a block / page and each block/page in its ancestry
const generateOuterRefs = () => {
  const stime = performance.now()
  store.outerRefs = {}
  for (let blocId in store.forwardRefs) {
    const refs = store.forwardRefs[blocId]
    const fn = (id) => {
      if (!store.outerRefs[id]) store.outerRefs[id] = []
      mergeLists(store.outerRefs[id], refs)
      for (let cid of store.blox[id].k || []) {
        fn(cid)
      }
    }
    fn(blocId)
  }
  // console.log(`outerrefs took ${performance.now() - stime}`)
}

const generateInnerOuterRefs = () => {
  generateInnerRefs()
  generateOuterRefs()
}

const mergeStore = (otherStore) => {
  // merge pages by title, adding all blocks to the end
  // if the new store has a block with the same id, give it a new id

  const idTranslation = {}

  for (let blocId in otherStore.blox) {
    const bloc = otherStore.blox[blocId]
    if (!store.titles[bloc.s]) {
      idTranslation[blocId] = store.titles[bloc.s]
    } else if (store.blox[blocId]) {
      idTranslation[blocId] = newUid()
    }
  }

  const transferBlock = (blockId, parentId) => {
    const newBlockId = idTranslation[blockId] || blockId
    const block = otherStore.blox[blockId]
    const newBlock = {
      ...block
    }
    store.blox[newBlockId] = newBlock
    newBlock.p = parentId
    if (block.k) {
      newBlock.k = []
      for (let childId of block.k) {
        let newChildId = idTranslation[childId] || childId
        transferBlock(childId, newBlockId)
        newBlock.k.push(newChildId)
      }
    }
  }

  for (let title in otherStore.titles) {
    const pageId = otherStore.titles[title]
    const page = otherStore.blox[pageId]
    if (store.titles[page.s] === undefined) {
      const newPageId = idTranslation(pageId) || pageId
      const newPage = {
        ...page
      }
      store.blox[newPageId] = newPage
      store.titles[page.s] = newPageId
      if (page.k) {
        newPage.k = []
        for (let blockId of kids) {
          const newBlockId = getNewId(blockId)
          transferBlock(blockId, newPageId)
          newPage.k.push(newBlockId)
        }
      }
    } else if (page.k) {
      const newPageId = store.titles[page.s]
      const existingPage = store.blox[newPageId]
      if (!existingPage.k) {
        existingPage.k = []
      }
      for (let childId of page.k) {
        const newChildId = idTranslation[childId] || childId
        transferBlock(childId, newPageId)
        existingPage.k.push(newChildId)
      }
    }
  }
}



// search

const escapeRegex = (string) => string.replaceAll(/([\[\]\(\)])/g, "\\$1").replaceAll("\\\\", "")

const newSearchRegex = (string) => new RegExp(escapeRegex(string), "i")

const searchRefCountWeight = 0.05
const pageOverBlockWeight = 1

let titleExactFullTextSearchCache = []
const titleExactFullTextSearch = (string) => {
  const regex = newSearchRegex(string)
  titleExactFullTextSearchCache = []
  for (let title in store.titles) {
    const id = store.titles[title]
    const page = store.blox[id]
    const match = title.match(regex)
    if (match) {
      titleExactFullTextSearchCache.push({
        title,
        id,
        idx: match.index - (store.refs[id] ? store.refs[id].length : 0) * searchRefCountWeight
      })
    }
  }
  titleExactFullTextSearchCache.sort((a, b) => a.idx - b.idx)
  return titleExactFullTextSearchCache
}

let exactFullTextSearchCache = []
const exactFullTextSearch = (string) => {
  const regex = newSearchRegex(string)
  exactFullTextSearchCache = []
  for (let id in store.blox) {
    const bloc = store.blox[id]
    const string = bloc.s
    const match = string.match(regex)
    if (match) {
      const matchObj = {
        id,
        idx: match.index - (store.refs[id] ? store.refs[id].length : 0) * searchRefCountWeight - (bloc.p === undefined) * pageOverBlockWeight
      }
      if (bloc.p) matchObj.string = bloc.s
      else matchObj.title = bloc.s
      exactFullTextSearchCache.push(matchObj)
    }
  }
  exactFullTextSearchCache.sort((a, b) => a.idx - b.idx)
  return exactFullTextSearchCache
}


let templateSearchCache = []
const searchTemplates = (string) => {
  const templatePageId = store.titles["roam/templates"]
  const templatePage = store.blox[templatePageId]
  templateSearchCache = []
  let searchRegex

  try {
    searchRegex = newSearchRegex(string)
  } catch {
    return templateSearchCache
  }

  if (templatePage) {
    const fn = (blockId) => {
      const block = store.blox[blockId]
      console.log(block.s)
      const match = block.s.match(searchRegex)
      console.log(match)
      if (match) {
        templateSearchCache.push({
          id: blockId,
          string: block.s,
          idx: match.idx
        })
      }
    }
    if (store.refs[templatePageId]) {
      for (let backref of store.refs[templatePageId])
        fn(backref)
    }
    if (store.blox[templatePageId].k) {
      for (let blockId of store.blox[templatePageId].k)
        fn(blockId)
    }
    console.log(templateSearchCache)
    templateSearchCache = templateSearchCache.sort((a, b) => b.idx - a.idx)
    console.log(templateSearchCache)

  }
  return templateSearchCache
}

const generateTitles = (store) => {
  store.titles = {}
  for (let id in store.blox) {
    const bloc = store.blox[id]
    if (bloc.p === undefined) store.titles[bloc.s] = id
  }
}

const hydrateFromBlox = (graphName, blox) => {
  console.log("hydratefromblox")
  let store = blankStore()
  store.blox = blox
  store.graphName = graphName
  generateTitles(store)
  generateRefs(store)
  return store
}

const sortByLastEdited = (arr) => {
  arr.sort((a, b) => {
    if (store.blox[a].et > store.blox[b].et) {
      return -1
    }
    return 1
  })
}

const createAndSwitchToNewStore = async (storeName) => {
  store = blankStore()
  store.graphName = storeName
  user.s.graphName = storeName
  user.s.commitId = "MYVERYFIRSTCOMMITEVER"
  saveUser()
  await addGraph()
  saveStore()
  window.location.href = window.location.href
}

const prepFocusIdForCursor = () => {
  if (focusBlock &&
    focusBlock.isConnected &&
    focusBlock.dataset.id !== sessionState.focusId) {

    focusBlockBody.textContent = ""
    renderBlockBody(focusBlockBody, store.blox[focusBlock.dataset.id].s)
  }

  focusBlock = document.querySelector(`.block[data-id="${sessionState.focusId}"]`)
  focusBlockBody = focusBlock.children[1]

  if (focusBlock === undefined) {
    throw new Error(`tried to focus block that doesn't exist: ${sessionState.focusId}`)
  }

  sessionState.isFocused = true

  const text = store.blox[sessionState.focusId].s
  focusBlockBody.innerText = ""
  renderBlockBody(focusBlockBody, text, true)
}

const focusIdPosition = () => {
  prepFocusIdForCursor()

  const scanElement = (element) => {
    for (let el of element.childNodes) {
      if (el.nodeName === "#text") {
        if (sessionState.position >= (el.startIdx || 0) && sessionState.position <= (el.startIdx || 0) + el.textContent.length) {
          scanResult = el
          const placeToGo = sessionState.position - el.startIdx
          // console.log(`startIdx ${el.startIdx} togo ${placeToGo}`)
          getSelection().collapse(el, placeToGo)
          return el
        }
      } else {
        const z = scanElement(el)
        if (z) return z
      }
    }
  }
  scanElement(focusBlockBody)
  updateCursorSpanInfo()
}

const selectIdWholeNode = (node) => {
  prepFocusIdForCursor()

  //todo ......

  updateCursorSpanInfo()
}

const setFocusedBlockString = (string, diff) => {
  let theString = string
  if (theString === undefined) {
    theString = store.blox[sessionState.focusId].s
  }

  if (diff !== undefined) {
    commitEdit('df', sessionState.focusId, diff)
  } else {
    macros.write(sessionState.focusId, theString)
  }

  focusIdPosition()
}

const getEditingSimpleSpan = (className) => {
  const elements = focusBlockBody.querySelectorAll("." + className)
  for (let temp of elements) {
    if (temp.childNodes[0].endIdx >= sessionState.position && temp.childNodes[0].startIdx < sessionState.position) {
      return temp
    }
  }
}


const updateCursorPosition = () => {
  focusNode = getSelection().focusNode
  focusOffset = getSelection().focusOffset
  const block = focusNode.parentNode.closest(".block")
  sessionState.focusId = block.dataset.id
  sessionState.position = (focusNode.startIdx || 0) + focusOffset
}

const updateCursorSpanInfo = () => {
  editingLink = undefined
  const tags = focusBlockBody.querySelectorAll(".tag")
  for (let tag of tags) {
    if (tag.children[1].firstChild.endIdx >= sessionState.position && tag.children[0].firstChild.startIdx < sessionState.position) {
      editingLink = tag
    }
  }
  const pageRefs = focusBlockBody.querySelectorAll(".page-ref")
  for (let ref of pageRefs) {
    if (ref.children[2].firstChild.endIdx >= sessionState.position && ref.children[1].firstChild.startIdx < sessionState.position) {
      editingLink = ref
    }
  }
  editingTitle = editingLink && editingLink.title

  editingTemplateExpander = getEditingSimpleSpan("template-expander")

  editingUrlElement = getEditingSimpleSpan("url")

  editingCommandElement = getEditingSimpleSpan("command")
  if (editingCommandElement === undefined)
    inlineCommandList.style.display = "none"
  if (editingTemplateExpander === undefined)
    templateList.style.display = "none"
  if (editingLink === undefined)
    autocompleteList.style.display = "none"
}


const focusBlockEnd = (blockNode) => {
  sessionState.focusId = blockNode.dataset.id
  sessionState.position = store.blox[sessionState.focusId].s.length
  focusIdPosition()
}

const focusBlockStart = (blockNode) => {
  sessionState.focusId = blockNode.dataset.id
  sessionState.position = 0
  focusIdPosition()
}

const focusBlockVerticalOffset = (offset, block = focusBlock, start = false) => { // this closure feels weird, maybe shoudn't use this language feature?
  const blocks = Array.from(document.querySelectorAll(".block"))
  const newActiveBlock = blocks[blocks.indexOf(block) + offset]
  if (newActiveBlock) {
    newActiveBlock.scrollIntoView({ block: 'nearest', inline: 'nearest' })

    if (!start) {
      focusBlockEnd(newActiveBlock)
    } else {
      focusBlockStart(newActiveBlock)
    }
  }
}

const getChildren = (node) => {
  return node.className === "block" ? node.children[2].children : node.children[1].children
}


const getClosestPageLink = (node) => {
  return node.closest(".tag") || node.closest(".attribute") || node.closest(".page-ref")
}

const getPageTitleOfNode = (node) => {
  const linkNode = getClosestPageLink(node)
  return linkNode && linkNode.title
}


const renderPage = (parentNode, uid, hasBackrefs = true) => {
  const page = store.blox[uid]
  const element = pageTemplate.cloneNode(true)
  const title = element.firstElementChild
  const body = element.children[1]
  body.dataset.id = uid
  element.dataset.id = uid

  if (page.s === undefined) {
    throw new Error(`error with page id ${uid}`)
  }
  title.innerText = page.s

  let children = page.k
  if (!children || children.length === 0) { // todo set standards for when lists can be empty to reduce ambiguity
    const newId = newUid()
    commitEdit("cr", newId, uid, 0)
    children = page.k
  }

  for (let child of children) {
    renderBlock(body, child)
  }

  const refs = store.refs[uid]
  if (hasBackrefs && refs && refs.length > 0) {
    const backrefsListElement = backrefListTemplate.cloneNode(true)
    element.children[2].appendChild(backrefsListElement)
    renderBackrefs(backrefsListElement.children[1], refs)
  }

  parentNode.appendChild(element)
  return element
}

const renderBackrefs = (parent, refs) => {
  sortByLastEdited(refs)
  for (let backref of refs) {
    const backrefFrame = backrefFrameTemplate.cloneNode(true)
    renderBreadcrumb(backrefFrame.children[0], backref)
    renderBlock(backrefFrame.children[1], backref)
    parent.appendChild(backrefFrame)
  }
}

const renderBlock = (parentNode, uid, idx) => {
  const element = blockTemplate.cloneNode(true)
  const body = element.children[1]
  const childrenContainer = element.children[2]
  element.dataset.id = uid
  childrenContainer.dataset.id = uid
  body.dataset.id = uid

  const string = store.blox[uid].s
  renderBlockBody(body, string)

  const children = store.blox[uid].k
  for (let child of children || []) {
    renderBlock(childrenContainer, child)
  }

  if (idx !== undefined && parentNode.children.length >= idx) {
    parentNode.insertBefore(element, parentNode.children[idx])
  } else {
    parentNode.appendChild(element)
  }
  return element
}

const renderBreadcrumb = (parent, blockId) => {
  blockId = store.blox[blockId].p
  const list = []
  while (blockId !== undefined) {
    const block = store.blox[blockId]
    if (block.p !== undefined) {
      list.push({ string: block.s, id: blockId })
    } else
      list.push({ title: block.s, id: blockId })
    blockId = block.p
  }
  if (list.length > 0) {
    const node = breadcrumbPageTemplate.cloneNode(true)
    const title = list[list.length - 1].title
    renderBlockBody(node, title)
    node.dataset.title = title
    parent.appendChild(node)
    for (let i = list.length - 2; i >= 0; i--) {
      const node = breadcrumbBlockTemplate.cloneNode(true)
      const nodeBody = node.children[1]
      renderBlockBody(nodeBody, list[i].string)
      node.dataset.id = list[i].id
      parent.appendChild(node)
    }
  }
}

const renderResultSet = (parent, resultSet, resultFrame, startIdx = 0) => {
  if (resultSet.length === 0) {
    resultFrame.style.display = "none"
    focusSuggestion = null
    return
  }
  const resultTemplate = getTemp(resultFrame.dataset.templateName)
  resultFrame.innerHTML = ""
  resultFrame.style.display = "block"
  const rect = parent.getBoundingClientRect()
  resultFrame.style.top = rect.bottom
  resultFrame.style.left = rect.left
  resultFrame.dataset.resultStartIdx = startIdx
  const resultLength = Math.min(resultSet.length, startIdx + SEARCH_RESULT_LENGTH)
  for (let i = startIdx; i < resultLength; i++) {
    matchingTitle = resultSet[i]
    const suggestion = resultTemplate.cloneNode(true)
    if (i == startIdx) {
      focusSuggestion = suggestion
      suggestion.dataset.selected = "true"
    }
    suggestion.dataset.id = matchingTitle.id
    if (matchingTitle.title) {
      suggestion.dataset.title = matchingTitle.title
      suggestion.innerText = truncateElipsis(matchingTitle.title, 50)
    } else {
      suggestion.dataset.string = matchingTitle.string
      suggestion.innerText = truncateElipsis(matchingTitle.string, 50)
    }
    resultFrame.appendChild(suggestion)
  }
}

const notifyText = (text, duration) => {
  const el = notificationTemplate.cloneNode(true)
  el.innerText = text
  appElement.appendChild(el)
  setTimeout(() => el.style.top = "60px", 50)
  const durationMillis = (duration && duration * 1000) || 5000
  setTimeout(() => el.style.opacity = "0", durationMillis)
  setTimeout(() => {
    el.remove()
  }, durationMillis + 300)
}

// 1             2              3  4         5    6         7
// page-ref-open page-ref-close or block-ref bold highlight italic

// 8    9       10                11  12         13      14-15
// link literal template-expander and code-block command image-embed

// 16            17           18-19 20-21
// compute-start compute-end  tag   attribute
const parseRegex = /(\[\[(?:[a-zA-Z0-9\-]+:)?)|(\]\])|(or)|\(\(([a-zA-Z0-9\-_]+)\)\)|(\*\*)|(\^\^)|(__)|((?:https?\:\/\/)(?:[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*))|`([^`]+)`|;;([^ \n\r]+)|(and)|(```)|(\/[ a-zA-Z]*)|!\[([^\]]*)\]\(((?:https?\:\/\/)(?:[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*))\)|({{)|(}})|#([a-zA-Z0-9\-]+:)?([\/a-zA-Z0-9_-]+)|^([a-zA-Z0-9\-]+:)?([ \/a-zA-Z0-9_-]+)::/g
// Roam allows like whatevs in the tags and attributes. I only allow a few select chars.

// This regex runs at 50-100M chars/s
// a regex this large runs at 1/3 the speed of a regex like /d([a-z])/g for equivelent string lengths + match counts + group counts
// adding a group slows it down by like 25%
// adding a named group halves its speed - unfortunately that's why I don't use named groups

const renderBlockBody = (parent, text, editMode = false) => {
  parent.dataset.editmode = editMode
  const stack = [parent]
  const matches = text.matchAll(parseRegex)

  let idx = 0
  let stackTop = parent

  let lastTextNode = null

  const newTextNode = (string) => {
    lastTextNode = document.createTextNode(string)
    lastTextNode.startIdx = idx
    lastTextNode.endIdx = idx + string.length
    return lastTextNode
  }

  for (let match of matches) {

    stackTop.appendChild(newTextNode(text.substring(idx, match.index)))
    idx = match.index

    if (match[1] !== undefined) {
      const pageRefElement = pageRefTemplate.cloneNode(true)
      pageRefElement.startIdx = idx + 2
      stackTop.appendChild(pageRefElement)
      stackTop.graphName = match[1]
      if (editMode)
        pageRefElement.children[0].appendChild(newTextNode("[["))
      pageRefElement.startIdx = idx

      const theTextNode = document.createTextNode(match[0].substring(2))
      theTextNode.startIdx = idx + 2
      theTextNode.endIdx = idx + match[0].length

      pageRefElement.children[1].appendChild(theTextNode)
      stack.push(pageRefElement.children[2])
      stackTop = stack[stack.length - 1]
    } else if (match[2] !== undefined) {
      if (stackTop.className === "page-ref__body") {
        stackTop.parentNode.endIdx = idx
        stackTop.parentNode.title = stackTop.innerText
        stackTop.parentNode.endIdx = idx + 2
        if (editMode)
          stackTop.parentNode.children[3].appendChild(newTextNode("]]"))
        stack.pop()
        stackTop = stack[stack.length - 1]
        lastTextNode.endIdx += 2
      } else {
        const el = document.createElement("span")
        if (editMode)
          el.className = "page-ref-close-missing-open"
        el.appendChild(newTextNode("]]"))
        stackTop.appendChild(el)
      }
    } else if (match[3] !== undefined) {
      const andElement = document.createElement('span')
      andElement.className = 'compute-or'
      andElement.appendChild(newTextNode("or"))
      stackTop.appendChild(andElement)
    } else if (match[4] !== undefined) {
      if (editMode) {
        const brElement = document.createElement('span')
        brElement.className = "block-ref-editing"
        brElement.appendChild(newTextNode(match[0]))
        stackTop.appendChild(brElement)
      } else {
        const blockId = match[4]
        const block = store.blox[blockId]
        if (block) {
          const blockRefElement = document.createElement('span')
          blockRefElement.className = 'block-ref'
          blockRefElement.innerText = block.s
          blockRefElement.dataset.id = blockId
          stackTop.appendChild(blockRefElement)
        } else {
          stackTop.appendChild(newTextNode(match[0]))
        }
      }
    } else if (match[5] !== undefined) {
      if (stackTop.className === "bold") {
        if (editMode)
          stackTop.appendChild(newTextNode("**"))
        stack.pop()
        stackTop = stack[stack.length - 1]
        lastTextNode.endIdx += 2
      } else {
        const boldElement = document.createElement('span')
        boldElement.className = 'bold'
        stackTop.appendChild(boldElement)
        if (editMode)
          boldElement.appendChild(newTextNode("**"))
        stack.push(boldElement)
        stackTop = boldElement
      }
    } else if (match[6] !== undefined) {
      if (stackTop.className === "highlight") {
        if (editMode)
          stackTop.appendChild(newTextNode("^^"))
        stack.pop()
        stackTop = stack[stack.length - 1]
        lastTextNode.endIdx += 2
      } else {
        const highlightElement = document.createElement('span')
        highlightElement.className = 'highlight'
        stackTop.appendChild(highlightElement)
        if (editMode)
          highlightElement.appendChild(newTextNode("^^"))
        stack.push(highlightElement)
        stackTop = highlightElement
      }
    } else if (match[7] !== undefined) {
      if (stackTop.className === "italic") {
        if (editMode)
          stackTop.appendChild(newTextNode("__"))
        stack.pop()
        stackTop = stack[stack.length - 1]
        lastTextNode.endIdx += 2

      } else {
        const italicElement = document.createElement('span')
        italicElement.className = 'italic'
        if (editMode)
          italicElement.appendChild(newTextNode("__"))
        stackTop.appendChild(italicElement)
        stack.push(italicElement)
        stackTop = italicElement
      }
    } else if (match[8] !== undefined) {
      const urlElement = document.createElement('span')
      urlElement.className = 'url'
      urlElement.appendChild(newTextNode(match[0]))
      urlElement.href = match[8]
      stackTop.appendChild(urlElement)
    } else if (match[9] !== undefined) {
      const literalElement = document.createElement('span')
      literalElement.className = 'literal'
      if (editMode) literalElement.appendChild(newTextNode(match[0]))
      else literalElement.appendChild(newTextNode(match[9]))
      stackTop.appendChild(literalElement)
    } else if (match[10] !== undefined) {
      const templateExpanderElement = document.createElement('span')
      templateExpanderElement.className = 'template-expander'
      templateExpanderElement.appendChild(newTextNode(match[0]))
      stackTop.appendChild(templateExpanderElement)
    } else if (match[11] !== undefined) {
      const andElement = document.createElement('span')
      andElement.className = 'compute-and'
      andElement.appendChild(newTextNode("and"))
      stackTop.appendChild(andElement)
    } else if (match[12] !== undefined) {
      if (stackTop.className === "code-block") {
        if (editMode) stackTop.appendChild(newTextNode("```"))
        stack.pop()
        stackTop = stack[stack.length - 1]
      } else {
        const codeBlockElement = document.createElement('div')
        codeBlockElement.className = 'code-block'
        stackTop.appendChild(codeBlockElement)
        stack.push(codeBlockElement)
        stackTop = codeBlockElement
        if (editMode) stackTop.appendChild(newTextNode("```"))
      }
    } else if (match[13] !== undefined) {
      const commandElement = document.createElement("span")
      commandElement.className = "command"
      commandElement.appendChild(newTextNode(match[0]))
      stackTop.appendChild(commandElement)
    } else if (match[14] !== undefined && match[15] !== undefined) {
      if (editMode) {
        const imageJustTextElement = document.createElement("span")
        imageJustTextElement.className = "image-full-text"
        imageJustTextElement.appendChild(newTextNode(match[0]))
        stackTop.appendChild(imageJustTextElement)
      } else {
        const imageElement = imageEmbedTemplate.cloneNode(true)
        imageElement.alt = match[14]
        imageElement.src = match[15]
        stackTop.appendChild(imageElement)
      }
    } else if (match[16] !== undefined) {
      const computeFailedElement = computeFailedTemplate.cloneNode(true)
      computeFailedElement.startIdx = idx + 2
      stackTop.appendChild(computeFailedElement)
      computeFailedElement.children[0].appendChild(newTextNode("{{"))
      stack.push(computeFailedElement.children[1])
      stackTop = stack[stack.length - 1]
    } else if (match[17] !== undefined) {
      if (stackTop.className === "compute-failed__body") {
        const el = stackTop.parentNode
        el.endIdx = idx
        el.text = text.substring(el.startIdx, el.endIdx)
        el.children[2].appendChild(newTextNode("}}"))
        transformComputeElement(el, editMode)
        stack.pop()
        stackTop = stack[stack.length - 1]
        lastTextNode.endIdx += 2
      } else {
        const el = document.createElement("span")
        el.appendChild(newTextNode("}}"))
        stackTop.appendChild(el)
      }
    } else if (match[19] !== undefined) { // 18 is optional graphname
      const tagElement = tagTemplate.cloneNode(true)

      match[18] ||= ""
      tagElement.children[0].appendChild(newTextNode("#" + match[18]))
      tagElement.graphName = match[18]
      tagElement.title = match[19]

      const theTextNode = document.createTextNode(match[19])
      theTextNode.startIdx = idx + match[18].length + 1
      theTextNode.endIdx = idx + match[0].length

      tagElement.startIdx = idx
      tagElement.endIdx = idx + match[0].length

      tagElement.children[1].appendChild(theTextNode)

      stackTop.appendChild(tagElement)
    } else if (match[21] !== undefined) { // 20 is optional graphname
      const attributeElement = document.createElement('span')
      attributeElement.className = 'attribute'
      attributeElement.graphName = match[20]
      attributeElement.title = match[21]
      attributeElement.appendChild(newTextNode(match[0]))
      stackTop.appendChild(attributeElement)
    }
    idx = match.index + match[0].length
  }

  stack[stack.length - 1].appendChild(newTextNode(text.substring(idx)))

  // todo make it add back astarisks and stuff in non-edit mode
  /**
   * PARSING REVELATION!!!!
   * Instead of backtracking and deleting when a block doesn't close, I can just erase the className of the block. Then it's still part of the tree but looks like it's gone! much less performance cost than backtracking!!
   */
  while (stackTop !== parent) {
    if (stackTop.className === "page-ref")
      stackTop.children[0].className = stackTop.children[0].className + "-incomplete"
    stackTop.className = stackTop.className + "-incomplete"
    stackTop = stackTop.parentNode
  }
}

const queryOperationOrder = { "root": 0, "compute-or": 1, "compute-and": 2, "page": 3 }
// not using 0 because that would be falsy

const transformComputeElement = (el, editMode) => {
  const seq = el.children[1].children
  if (seq.length === 0) return
  const firstEl = seq[0]
  const pageTitle = getPageTitleOfNode(firstEl)
  if (!pageTitle) {
    return
  }
  switch (pageTitle) {
    case "TODO":
      if (!editMode) {
        el.textContent = ""
        const checkbox = todoCheckboxTemplate.cloneNode(true)
        el.appendChild(checkbox)
      } else {
        return
      }
      break
    case "DONE":
      if (!editMode) {
        el.textContent = ""
        const checkedCheckbox = todoCheckboxTemplate.cloneNode(true)
        checkedCheckbox.checked = true
        el.appendChild(checkedCheckbox)
      } else {
        return
      }
      break
    case "video":
      if (!editMode && !user.s.noVideo) {
        if (seq.length !== 2) return
        if (seq[1].className === "url") {
          const videoEmbedElement = videoEmbedTemplate.cloneNode(true)
          videoEmbedElement.src = youtubeLinkToEmbed(seq[1].innerText)
          el.textContent = ""
          el.appendChild(videoEmbedElement)
        }
      } else {
        return
      }
      break
    case "query":

      // step 1 parse element list using precedence climbing
      let tree = {
        // l: undefined,
        // r: undefined,
        op: "root",
        // title: undefined,
        // p: undefined
      }
      let cur = tree
      for (let i = 1; i < seq.length; i++) {
        const newNode = {}
        const el = seq[i]
        const title = getPageTitleOfNode(el)
        if (title) {
          newNode.title = title
          newNode.op = "page"
          if (cur.l === undefined) {
            cur.l = newNode
          } else if (cur.r === undefined) {
            cur.r = newNode
          } else {
            console.error("page ref with no operator")
            return
          }
          newNode.p = cur
          cur = newNode
          continue
        }
        const opOrder = queryOperationOrder[el.className]
        if (opOrder !== undefined) {
          newNode.op = el.className
          let prev = undefined
          while (queryOperationOrder[cur.op] > opOrder) {
            prev = cur
            cur = cur.p
          }
          newNode.l = prev
          if (prev !== undefined) prev.p = newNode
          if (cur.l === prev) cur.l = newNode
          else cur.r = newNode
          newNode.p = cur
          cur = newNode
        }
      }
      tree = tree.l

      const queryStime = performance.now()
      const blocksWithQueries = {}
      for (let id of store.refs[store.titles["query"]]) {
        blocksWithQueries[id] = 1
      }
      const result = []
      for (let key in queryAstObjectSetStrategy(tree)) {
        if (blocksWithQueries[key] === undefined && store.blox[key] !== undefined) result.push(key)
      }
      // console.log(`query took ${performance.now() - queryStime}`)
      // console.log(result)

      // todo UGGGH 
      const queryFrame = queryFrameTemplate.cloneNode(true)
      renderBackrefs(queryFrame, result)
      const block = el.closest(".block")
      const otherQuery = block.querySelector(".query-frame")
      if (otherQuery) otherQuery.remove()
      block.appendChild(queryFrame)
      return
      break
    default:
      return
  }
  el.className = "compute"
}


const queryAstArrayStrategy = (ast) => {
  if (ast === undefined) return []
  let r = queryAstArrayStrategy(ast.r)
  let l = queryAstArrayStrategy(ast.l)
  switch (ast.op) {
    case "compute-and":
      const result = []
      for (let id of r) {
        if (l.includes(id)) result.push(id)
      }
      return result
    case "compute-or":
      for (let el of r) {
        l.push(el)
      }
      return l
    case "page":
      return [...(store.refs[store.titles[ast.title]] || [])]
  }
}

const queryAstObjectSetStrategy = (ast) => {
  if (ast === undefined) return {}
  let r = queryAstObjectSetStrategy(ast.r)
  let l = queryAstObjectSetStrategy(ast.l)
  let result = {}
  switch (ast.op) {
    case "compute-and":
      for (let id in r) {
        if (l[id] === 1) result[id] = 1
      }
      return result
    case "compute-or":
      for (let id in r) {
        l[id] = 1
      }
      return l
    case "page":
      const idList = store.refs[store.titles[ast.title]]
      for (let id of idList) {
        result[id] = 1
      }
      return result
  }
}

/*
[1 and 2] or
[[1 and 2] or]
 
[1 or 2] and
[1 or [2 and ]]
 
[1 or [2 and [3 nand 4]]] and
                     ^
[1 or 2] or
[[1 or 2] or]
 */

const idOfYoutubeURL = (url) => {
  const match = url.match(/^https:\/\/www\.youtube.com\/watch\?v=([a-zA-Z0-9]+)(&t=.+)?$/)
  if (match) return match[1]
}

const embedLinkOfYoutubeId = (id) => {
  return `https://www.youtube.com/embed/${id}`
}

const youtubeLinkToEmbed = (link) => embedLinkOfYoutubeId(idOfYoutubeURL(link))


// API knowingly does not follow REST spec because CORS sucks and this isn't CRUD

const reset = () => {
  localStorage.clear()
  const r = indexedDB.deleteDatabase("microroam")
  window.location.href = window.location.href
}

const syncEditsWithBasicBitchServer = async () => {
  if (masterCommitInProgress.length === 0) {
    return
  }
  const headers = new Headers()
  headers.set('h', user.h)
  const newCommitId = newUUID()
  const commit = { id: newCommitId, t: intToBase64(Date.now()), edits: masterCommitInProgress }
  masterCommitInProgress = []
  headers.set('body', JSON.stringify(commit))
  headers.set('synccommitid', user.s.syncCommitId)
  const response = await fetch(`${basicBitchServerUrl}/edit/${store.graphName}`, { headers })
  if (response.status === 200) {
    user.s.syncCommitId = newCommitId
    masterCommitList.push(commit)
  } else if (response.status === 409) {
    console.log("conflicting edit")
    invalidateLocal()
  } else {
    masterCommitInProgress = [...commit.edits, ...masterCommitInProgress]
  }
}

const saveStoreToBasicBitchServer = async (blox, force = false) => {
  const putSentTime = performance.now()
  const headers = new Headers()
  headers.set('h', user.h)
  const syncCommitId = user.s.commitId
  headers.set('commitid', syncCommitId)
  headers.set('synccommitid', user.s.syncCommitId)
  if (force) headers.set('force', 'true')
  const response = await fetch(`${basicBitchServerUrl}/put/${store.graphName}`,
    {
      method: "POST", body: blox,
      headers
    })
  if (response.status === 200 || response.status === 304) {
    user.s.syncCommitId = syncCommitId
    console.log(`save confirmed in ${performance.now() - putSentTime}`)
  } else {
    console.warn(`failed to save to server`)
  }
}

const getBloxFromBasicBitchServer = async (graphName) => {
  const getSentTime = performance.now()
  const response = await fetch(`${basicBitchServerUrl}/get/${graphName}`,
    { headers: { passwordHash: user.h } })
  switch (reponse.status) {
    case 200:
      const blox = await response.json()
      console.log(`got in ${performance.now() - getSentTime}`)
      return blox
    default:
      console.warn(`failed to get store`)
  }
}

const addOtherStore = async (graphName) => {
  const blox = await getBloxFromBasicBitchServer(graphName)
  const otherStore = hydrateFromBlox(blox)
  otherStores[graphName] = otherStore
}

const saveSettingsToBasicBitchServer = async () => {
  const headers = new Headers()
  headers.set('h', user.h)
  headers.set('body', JSON.stringify(user.s))
  const response = await fetch(`${basicBitchServerUrl}/settings`,
    { headers })
  if (response.status !== 200) {
    console.log("failed to save settings")
  }
}

const middlePepper = "76pCgT0lW6ES9yjt01MeH"
const beginPepper = "CeoPPOv9rIq6O7YiYlSFX"
const endPepper = "Rzw1dagomQGpoo2s7iGE3lYL2yruaJDGrUk6bFCvz"
const hashPassword = async (password, email) => {
  const saltAndPeppered = `${beginPepper}${password}${middlePepper}${email}${endPepper}`
  const buffer = textEncoder.encode(saltAndPeppered)
  const hashed = await crypto.subtle.digest("SHA-512", buffer)
  const passwordHashBuffer = new Uint8Array(hashed)
  let passwordHash = ""
  for (let i = 0; i < passwordHashBuffer.length; i++) {
    passwordHash += String.fromCharCode(passwordHashBuffer[i])
  }
  passwordHash = btoa(passwordHash)
  passwordHash = passwordHash.replaceAll("/", "-").replaceAll("+", "_").replaceAll("=", "")
  return passwordHash
}

loginForm.addEventListener("submit", async (event) => {
  event.preventDefault()
  const email = loginEmailElement.value
  loginEmailElement.value = ""
  const password = loginPasswordElement.value
  loginPasswordElement.value = ""
  const passwordHash = await hashPassword(password, email)
  const response = await fetch(`${basicBitchServerUrl}/auth`, { method: "POST", headers: { h: passwordHash } })
  if (response.status === 200) {
    user = await response.json()
    saveUser()
    invalidateLocal()
    console.log(user)
  } else {
    notifyText("Don't know that username + password.")
  }
})


signupForm.addEventListener("submit", async (event) => {
  event.preventDefault()
  const email = signupEmailElement.value
  signupEmailElement.value = ""
  const username = signupUsernameElement.value
  signupUsernameElement.value = ""
  const password = signupPasswordElement.value
  signupPasswordElement.value = ""
  const passwordHash = await hashPassword(password, email)
  const jsonBody = JSON.stringify({ h: passwordHash, u: username, e: email, s: user.s })
  console.log(jsonBody)
  const headers = new Headers()
  headers.set('body', jsonBody)
  const response = await fetch(`${basicBitchServerUrl}/signup`, { method: "POST", headers })
  if (response.status === 200) {
    console.log(response)
    user = await response.json()
    saveUser()
    invalidateLocal()
    console.log(`signed up`)
  } else {
    const responseText = await response.json()
    notifyText(responseText)
  }
})

const addGraph = async () => {
  const headers = new Headers()
  headers.set('h', user.h)
  headers.set('commitid', user.s.commitId)
  const syncCommitId = user.s.commitId
  const response = await fetch(`${basicBitchServerUrl}/creategraph/${store.graphName}`, { headers, method: 'POST', body: JSON.stringify(store.blox) })
  if (!response.ok) {
    notifyText("failed to add graph")
    return
  }
  user.s.syncCommitId = syncCommitId
}


/**
example query string
?title=Micro Roam&scroll=100&focus=fS4vHpM2_&position=10
 */
const initialDailyNotes = 5

const renderSessionState = () => {

  // clear screen
  searchResultList.style.display = "none"
  pageFrameOuter.removeEventListener("scroll", dailyNotesInfiniteScrollListener)
  pageFrame.innerHTML = ""
  searchInput.value = ""

  // render state
  switch (sessionState.pageFrame) {
    case "pageTitle":
      let existingPage = store.titles[sessionState.page]
      if (existingPage === undefined) {
        existingPage = macros.createPage(sessionState.page)
      }
      renderPage(pageFrame, existingPage)
      break
    case "block":
      const blockFocusFrame = blockFocusFrameTemplate.cloneNode(true)
      pageFrame.appendChild(blockFocusFrame)
      renderBreadcrumb(blockFocusFrame.children[0], sessionState.block)
      renderBlock(blockFocusFrame.children[1], sessionState.block)
      const backRefs = store.refs[sessionState.block]
      if (backRefs) {
        backRefs.sort((a, b) => store.blox[b].et - store.blox[a].et)
        const backrefsListElement = backrefListTemplate.cloneNode(true)
        blockFocusFrame.children[2].appendChild(backrefsListElement)
        for (let backref of backRefs) {
          renderBlock(backrefsListElement.children[1], backref)
        }
      }
      break
    case "dailyNotes":
      pageFrameOuter.addEventListener("scroll", dailyNotesInfiniteScrollListener)
      sessionState.oldestDate = new Date(Date.now())
      let numNotesLoaded = 0
      console.log(store.titles)
      let dateString = formatDate(sessionState.oldestDate)
      generateTitles(store) // todo get rid of title corruption and remove this. it's here because the titles are always corrupted at this point, I have no idea why.
      if (!store.titles[dateString]) {
        console.log(`creating page ${dateString}`)
        macros.createPage(dateString)
      }
      for (let i = 0; i < 1000; i++) {
        const daysNotes = store.titles[dateString]
        if (daysNotes) {
          renderPage(pageFrame, daysNotes)
          const pageBreak = document.createElement("div")
          pageBreak.className = "page-break"
          pageFrame.appendChild(pageBreak)
          numNotesLoaded += 1
          if (numNotesLoaded >= initialDailyNotes) {
            break
          }
        }
        sessionState.oldestDate.setDate(
          sessionState.oldestDate.getDate() - 1
        )
        dateString = formatDate(sessionState.oldestDate)

      }
      if (numNotesLoaded < initialDailyNotes) pageFrame.lastChild.remove() // remove last page divider
      break
  }

  if (!sessionState.isFocused || !pageFrame.querySelector(`.block[data-id="${sessionState.focusId}"]`)) {
    const firstBlockElement = pageFrame.querySelector('.block')
    sessionState.position = 0
    sessionState.focusId = firstBlockElement.dataset.id
  } else {
    console.log(`SESSION STATE ALREADY FOCUSED ON ${sessionState.focusId}`)
  }
  focusIdPosition()

  pageFrameOuter.scrollTop = sessionState.scroll || 0

}

const gotoNoHistory = (commandName, ...command) => {
  switch (commandName) {
    case "dailyNotes":
      sessionState.pageFrame = "dailyNotes"
      break
    case "pageTitle":
      sessionState.pageFrame = "pageTitle"
      sessionState.page = command[0]
      break
    case "block":
      sessionState.pageFrame = "block"
      sessionState.block = command[0]
      break
  }

  renderSessionState()
}

const goto = (...command) => {
  sessionState.scroll = pageFrameOuter.scrollTop

  const oldSessionState = JSON.parse(JSON.stringify(sessionState))

  sessionState.isFocused = false
  sessionState.scroll = 0
  gotoNoHistory(...command)
  setTimeout(() => {
    history.replaceState(oldSessionState, "Micro Roam")
    // todo use page title, in more places than just this because apparently here's not often supported
    history.pushState(sessionState, "Micro Roam")
  }, 0)
}

const gotoReplaceHistory = (...command) => {
  gotoNoHistory(...command)
  history.replaceState(sessionState, "Micro Roam")
}

window.addEventListener("popstate", (event) => {
  console.log(event.state)
  if (event.state) {
    sessionState = event.state
    renderSessionState()
  }
})


const dailyNotesInfiniteScrollListener = () => {
  const fromBottom =
    pageFrame.getBoundingClientRect().bottom - innerHeight
  if (fromBottom < 700) {
    for (let i = 0; i < 100; i++) {
      sessionState.oldestDate.setDate(sessionState.oldestDate.getDate() - 1)
      const daysNotes = store.titles[formatDate(sessionState.oldestDate)]
      if (daysNotes) {
        renderPage(pageFrame, daysNotes)
        const pageBreak = document.createElement("div")
        pageBreak.className = "page-break"
        pageFrame.appendChild(pageBreak)
        break
      }
    }
  }
}


const parseStackTrace = (string) => {
  const result = []
  const matches = string.matchAll(/([^ ]+) \(([^\)]+):([0-9]+):([0-9]+)\)(?:\n|$)/g)
  for (let match of matches) {
    result.push({ function: match[1], file: match[2], line: match[3], column: match[4] })
  }
  return result
}
const logError = (message, url, lineNumber, columnNumber, error) => {
  const errorInfo = { line: lineNumber, file: url, stack: parseStackTrace(error.stack), message, column: columnNumber }
  const existingErrors = localStorage.getItem("error_log")
  if (existingErrors) {
    const z = JSON.parse(existingErrors)
    z.push(errorInfo)
    localStorage.setItem("error_log", JSON.stringify(z))
  } else {
    localStorage.setItem("error_log", JSON.stringify([errorInfo]))
  }
  // todo send error to server at this point
  return false // we don't actually "catch" the error, we just report that it happened. The error is still an error
}

window.onerror = logError


const showTopBar = () => {
  topBar.style.marginTop = "0px"
  topBarHiddenHitbox.style.display = "none"
}
const hideTopBar = () => {
  topBar.style.marginTop = "-36px"
  topBarHiddenHitbox.style.display = "block"
}
const saveUser = () => {
  document.body.className = user.s.theme
  if (user.s.topBar === "visible") showTopBar()
  else hideTopBar()

  document.body.spellcheck = user.s.spellcheck
  document.body.dataset['editingspotlight'] = user.s.editingSpotlight

  if (user.h) {
    topButtons["Sign Out"].style.display = "block"
    topButtons["Sign Up"].style.display = "none"
    topButtons["Login"].style.display = "none"
  } else {
    topButtons["Sign Out"].style.display = "none"
    topButtons["Sign Up"].style.display = "block"
    topButtons["Login"].style.display = "block"
  }
  saveUserJustLocalStorage()
  saveSettingsToBasicBitchServer()
}

const saveUserJustLocalStorage = () => {
  localStorage.setItem("user", JSON.stringify(user))

}


// Finally starting the program after everything's compiled
if (dataLoaded) start()
scriptsLoaded = true


const ptest = () => {
  const t2 = performance.now()
  for (let i = 0; i < 100; i++) {
    generateInnerOuterRefs()
  }
  const took = (performance.now() - t2)
  console.log(`thing took ${took}`)
}
// ptest()</script><script async>const downloadHandler=()=>{console.log("download");const e=storeToRoamJSON(store),t=new Blob([e],{type:"text/json"}),o=URL.createObjectURL(t),n=document.createElement("a");n.setAttribute("href",o),n.setAttribute("download",`${store.graphName}-${formatDateYMD(new Date(Date.now()))}.json`),n.click()},downloadMd=()=>{console.log("download md");const e=storeToMdZip(),t=URL.createObjectURL(e),o=document.createElement("a");o.setAttribute("href",t),o.setAttribute("download",`${store.graphName}-md-${formatDateYMD(new Date(Date.now()))}.zip`),o.click()},expandTemplate=()=>{const e=focusSuggestion.dataset.id,t=store.blox[sessionState.focusId];if(void 0===t.k||0===t.k.length){const o=store.blox[sessionState.focusId].p,n=store.blox[e].k,s=store.blox[o].k.indexOf(sessionState.focusId);macros.nocommit.delete(sessionState.focusId,!1);const r=focusBlock.parentNode;focusBlock.remove();for(let e=0;e<n.length;e++){const a=n[e],l=s+e,i=macros.nocommit.copyBlock(a,o,l),c=renderBlock(r,i,l);0===e&&focusBlockEnd(c)}commit()}else notifyText("can't use a template inside a block that has children");templateList.style.display="none"},pasteBlocks=()=>{const e=store.blox[sessionState.focusId],o=e.p;let n=store.blox[o].k.indexOf(sessionState.focusId);const s=focusBlock.parentNode;if(""===focusBlockBody.innerText?(macros.nocommit.delete(sessionState.focusId),focusBlock.remove()):n+=1,clipboardData.dragSelect.rooted){const t=macros.nocommit.copyBlock(clipboardData.dragSelect.root,o,n),r=renderBlock(s,t,n);focusBlockEnd(r)}else{let t=null;for(let e=0;e<clipboardData.dragSelect.endIdx+1-clipboardData.dragSelect.startIdx;e++){const a=store.blox[clipboardData.dragSelect.root].k[e+clipboardData.dragSelect.startIdx],l=macros.nocommit.copyBlock(a,o,e+n),i=renderBlock(s,l,e+n);t=i}focusBlockEnd(t)}commit()},autocomplete=()=>{const e=store.blox[sessionState.focusId].s;if("tag"===editingLink.className){editingLink.childNodes[0];if(focusSuggestion.dataset.title.match(/^[a-zA-Z0-9\-_]+$/)){const t=e.slice(0,editingLink.startIdx)+"#"+focusSuggestion.dataset.title+e.slice(editingLink.endIdx);sessionState.position=editingLink.startIdx+focusSuggestion.dataset.title.length+1,setFocusedBlockString(t)}else{const o=e.slice(0,editingLink.startIdx)+"[["+focusSuggestion.dataset.title+"]]"+e.slice(editingLink.endIdx);console.log(o),sessionState.position=editingLink.startIdx+focusSuggestion.dataset.title.length+4,setFocusedBlockString(o)}}else{const n=e.slice(0,editingLink.startIdx)+"[["+focusSuggestion.dataset.title+"]]"+e.slice(editingLink.endIdx);console.log(n),sessionState.position=editingLink.startIdx+focusSuggestion.dataset.title.length+4,setFocusedBlockString(n)}autocompleteList.style.display="none"},indentFocusedBlock=()=>{const e=sessionState.focusId,t=focusBlock.previousElementSibling;if(t&&t.dataset&&t.dataset.id){const o=t.dataset.id;console.log(o);const n=store.blox[o].k&&store.blox[o].k.length||0;macros.move(e,o,n),t.children[2].appendChild(focusBlock),getSelection().collapse(focusNode,focusOffset)}},dedentFocusedBlock=()=>{const e=sessionState.focusId,t=store.blox[e].p,o=store.blox[t];if(o){const n=o.p,s=store.blox[n].k.indexOf(t);macros.move(e,n,s+1);const r=focusBlock.parentNode.parentNode,a=r.parentNode,l=r.nextElementSibling;l?a.insertBefore(focusBlock,l):a.appendChild(focusBlock),getSelection().collapse(focusNode,focusOffset)}};document.addEventListener("input",n=>{if(sessionState.isFocused)if(updateCursorPosition()," "!==focusBlockBody.innerText&&""!==focusBlockBody.innerText){let e=focusBlockBody.innerText,o=null!==n.data&&1===n.data.length&&"insertText"===n.inputType;if(null!==n.data)if("["===n.data){const s=n.target.querySelectorAll(".page-ref-close-missing-open");let t=!1;for(let e of s)if(console.log(e),e.childNodes[0].startIdx>sessionState.position){t=!0;break}t||(e=e.substring(0,sessionState.position)+"]"+e.substring(sessionState.position),o=!1)}else"]"===n.data&&"]"===e[sessionState.position]&&(e=e.substring(0,sessionState.position-1)+e.substring(sessionState.position),o=!1);let t={d:store.blox[sessionState.focusId].s,i:e};if(o&&(t=sessionState.position===e.length?{i:n.data}:{i:n.data,s:sessionState.position-1}),setFocusedBlockString(e,t),editingCommandElement){const r=matchInlineCommand(editingCommandElement.innerText.substring(1));renderResultSet(editingCommandElement,r,inlineCommandList,0)}if(editingTitle){const a=titleExactFullTextSearch(editingTitle);renderResultSet(editingLink,a,autocompleteList,0)}if(editingTemplateExpander){const l=editingTemplateExpander.innerText.substring(2),i=searchTemplates(l);renderResultSet(editingTemplateExpander,i,templateList,0)}}else macros.write(sessionState.focusId,"");else if("search-input"===n.target.id){const e=exactFullTextSearch(n.target.value);renderResultSet(searchInput,e,searchResultList,0)}else if("page__title"===n.target.className){console.log("edit title");const t=n.target.parentNode.dataset.id;macros.writePageTitle(t,n.target.innerText)}});const globalHotkeys={"hide top bar":{key:"b",control:!0,fn:()=>{"0px"===topBar.style.marginTop?user.s.topBar="hidden":user.s.topBar="visible",saveUser()}},escape:{key:"Escape",fn:()=>{autocompleteList.style.display="none",templateList.style.display="none"}},upload:{key:"d",control:!0,fn:()=>{topButtons.Upload.click()}},download:{key:"s",control:!0,shift:!0,fn:downloadHandler},save:{key:"s",control:!0,fn:debouncedSaveStore},"toggle color theme":{key:"m",control:!0,fn:()=>{"light"===document.body.className?user.s.theme="dark":user.s.theme="light",saveUser()}},search:{key:"u",control:!0,fn:()=>{"0px"!==topBar.style.marginTop&&(topBar.style.marginTop="0px"),searchInput.focus()}},open:{key:"o",control:!0,fn:e=>{editingTitle?goto("pageTitle",editingTitle):editingUrlElement&&editingUrlElement.click()}},"daily notes":{key:"d",alt:!0,fn:()=>{goto("dailyNotes")}},undo:{key:"z",control:!0,fn:()=>{0<undoCommitList.length&&(undo(),renderSessionState())}},"delete block":{key:"k",control:!0,shift:!0,fn:()=>{const e=store.blox[sessionState.focusId];if(void 0===e.k||0===e.k.length){const t=focusBlock,o=sessionState.focusId;focusBlockVerticalOffset(-1),t.remove(),macros.delete(o)}else notifyText('no "delete block" for blocks with children (at least right now)')}},terminal:{key:"i",control:!0,alt:!0,fn:()=>{"none"===terminalElement.style.display?(terminalElement.style.display="block",terminalElement.focus()):terminalElement.style.display="none"}},p:{key:"p",control:!0,fn:()=>{console.log("at least it wasn't print")}}};document.addEventListener("keydown",event=>{for(let hotkeyName in globalHotkeys){const hotkey=globalHotkeys[hotkeyName];if(event.key.toLowerCase()===hotkey.key&&event.shiftKey===!!hotkey.shift&&event.ctrlKey===!!hotkey.control&&event.altKey===!!hotkey.alt)return hotkey.fn(event),void event.preventDefault()}if(dragSelect){let did=!1;if(("c"===event.key||"x"===event.key)&&event.ctrlKey){let text="";console.log("copy blocks");const id=dragSelect.root.dataset.id;if(dragSelect.rooted)text=blocToMd(id);else{const kids=store.blox[id].k;for(let i=dragSelect.startIdx;i<dragSelect.endIdx+1;i++)text+=blocToMd(kids[i])}clipboardData={dragSelect:{root:id,startIdx:dragSelect.startIdx,endIdx:dragSelect.endIdx,rooted:dragSelect.rooted},text:text},console.log(clipboardData),navigator.clipboard.writeText(text),did=!0}if("Backspace"===event.key||"Delete"===event.key||"x"===event.key&&event.ctrlKey){if(console.log(dragSelect),dragSelect.rooted)focusBlockVerticalOffset(-1,dragSelect.root),macros.nocommit.delete(dragSelect.root.dataset.id),document.querySelectorAll(`.block[data-id="${dragSelect.root.dataset.id}"]`).forEach(e=>e.remove());else{const childNodes=getChildren(dragSelect.root);focusBlockVerticalOffset(-1,childNodes[dragSelect.startIdx]),console.log(`cnl ${childNodes.length} start ${dragSelect.startIdx} end ${dragSelect.endIdx}`);for(let i=dragSelect.endIdx;i>=dragSelect.startIdx;i--){const node=childNodes[i];macros.nocommit.delete(node.dataset.id),document.querySelectorAll(`.block[data-id="${node.dataset.id}"]`).forEach(e=>e.remove())}commit()}dragSelect=null,did=!0}did&&event.preventDefault()}else if("none"!==autocompleteList.style.display)"Enter"===event.key&&(autocomplete(),event.preventDefault()),updownythingey(editingLink,autocompleteList,titleExactFullTextSearchCache,focusSuggestion)&&event.preventDefault();else if("none"!==templateList.style.display)"Tab"!==event.key&&"Enter"!==event.key||(expandTemplate(),event.preventDefault()),updownythingey(editingTemplateExpander,templateList,templateSearchCache,focusSuggestion)&&event.preventDefault();else if("none"!==inlineCommandList.style.display)"Tab"!==event.key&&"Enter"!==event.key||(execInlineCommand(),event.preventDefault()),updownythingey(editingCommandElement,inlineCommandList,commandSearchCache,focusSuggestion)&&event.preventDefault();else if(sessionState.isFocused){let blocks,newActiveBlock;switch(event.key){case"Enter":if(!event.shiftKey){let idx=store.blox[store.blox[sessionState.focusId].p].k.indexOf(sessionState.focusId);event.ctrlKey||(idx+=1),console.log(idx);const newBlockUid=newUid();commitEdit("cr",newBlockUid,store.blox[sessionState.focusId].p,idx);const newBlockElement=renderBlock(focusBlock.parentNode,newBlockUid,idx);newBlockElement.children[1].focus(),event.preventDefault()}break;case"Tab":(event.shiftKey?dedentFocusedBlock:indentFocusedBlock)(),event.preventDefault();break;case"Backspace":if(0===sessionState.position){const parent=store.blox[store.blox[sessionState.focusId].p];if(void 0!==parent.p||1!==parent.k.length){const currentFocusBlock=focusBlock;focusBlockVerticalOffset(-1),macros.delete(currentFocusBlock.dataset.id),currentFocusBlock.remove(),event.preventDefault()}}break;case"ArrowDown":if(event.altKey&&event.shiftKey){const parentId=store.blox[sessionState.focusId].p,parentElement=focusBlock.parentNode,currentIdx=store.blox[parentId].k.indexOf(sessionState.focusId);focusBlock.nextElementSibling&&(macros.move(sessionState.focusId,parentId,currentIdx+1),focusBlock.nextElementSibling.nextElementSibling?parentElement.insertBefore(focusBlock,focusBlock.nextElementSibling.nextElementSibling):parentElement.appendChild(focusBlock),getSelection().collapse(focusNode,focusOffset),event.preventDefault())}else event.shiftKey||event.altKey||(focusBlockVerticalOffset(1),event.preventDefault());break;case"ArrowUp":if(event.altKey&&event.shiftKey){const parentId=store.blox[sessionState.focusId].p,parentElement=focusBlock.parentNode,currentIdx=store.blox[parentId].k.indexOf(sessionState.focusId);focusBlock.previousElementSibling&&(macros.move(sessionState.focusId,parentId,currentIdx-1),parentElement.insertBefore(focusBlock,focusBlock.previousElementSibling),getSelection().collapse(focusNode,focusOffset),event.preventDefault())}else event.shiftKey||event.altKey||(focusBlockVerticalOffset(-1),event.preventDefault());break;case"ArrowLeft":event.shiftKey&&event.altKey?dedentFocusedBlock():0===sessionState.position?(focusBlockVerticalOffset(-1),event.preventDefault()):--sessionState.position;break;case"ArrowRight":event.shiftKey&&event.altKey?indentFocusedBlock():sessionState.position===focusBlockBody.innerText.length?(focusBlockVerticalOffset(1,focusBlock,!0),event.preventDefault()):sessionState.position+=1;break;case"c":event.ctrlKey&&(clipboardData=null)}}if(document.activeElement&&"search-input"===document.activeElement.id){if("Enter"===event.key)return!event.ctrlKey&&focusSuggestion?focusSuggestion.dataset.title?goto("pageTitle",focusSuggestion.dataset.title):goto("block",focusSuggestion.dataset.id):goto("pageTitle",event.target.value),void event.preventDefault();const didUpDowny=updownythingey(searchInput,searchResultList,exactFullTextSearchCache,focusSuggestion);didUpDowny&&event.preventDefault()}if("none"!==terminalElement.style.display&&"Enter"===event.key&&!event.ctrlKey&&!event.shiftKey&&!event.altKey){const string=event.target.innerText,first=string.match(/^[a-z]+/);if(first&&terminalCommands[first[0]]){const fn=terminalCommands[first[0]];fn(string.substring(first[0].length)),event.preventDefault(),terminalElement.style.display="none",terminalElement.innerHTML=""}else try{eval(string),event.ctrlKey||(terminalElement.style.display="none",terminalElement.innerHTML="")}catch(error){console.log(error),event.preventDefault()}}print(sessionState)}),document.addEventListener("paste",e=>{if(console.log(e),clipboardData){const t=e.clipboardData.getData("text");t.replaceAll(/\r/g,"")==clipboardData.text?(pasteBlocks(),e.preventDefault()):clipboardData=void 0}});const updownythingey=(e,t,o,n)=>{const s="ArrowUp"===event.key||"Tab"===event.key&&event.shiftKey?-1:("ArrowDown"===event.key||"Tab"===event.key)&&1;if(s){const r=-1===s?n.previousElementSibling:n.nextElementSibling;if(r)r.dataset.selected="true",focusSuggestion=r,delete n.dataset.selected;else{const a=parseInt(t.dataset.resultStartIdx),l=clamp(a+s*SEARCH_RESULT_LENGTH,0,o.length-SEARCH_RESULT_LENGTH);renderResultSet(e,o,t,l),-1===s&&(delete t.firstElementChild.dataset.selected,t.lastElementChild.dataset.selected=!0)}return!0}};document.addEventListener("mousedown",t=>{const e=getClosestPageLink(t.target);if(e)goto("pageTitle",e.title,e.graphName);else{const o=t.target.closest(".block__bullet");if("search-result"!==t.target.className){"search-input"!==t.target.id&&(searchResultList.style.display="none");const n=t.target.closest(".breadcrumb-page"),s=t.target.closest(".breadcrumb-block");if(o)goto("block",o.parentNode.dataset.id);else if("block-ref"===t.target.className)goto("block",t.target.dataset.id);else if("url"===t.target.className){const r=document.createElement("a");r.target="_blank",r.href=t.target.innerText,r.click()}else if(t.target===topButtons.Download)downloadHandler();else if("template__suggestion"===t.target.className)focusSuggestion&&(focusSuggestion.dataset.selected=!1),t.target.dataset.selected=!0,focusSuggestion=t.target,expandTemplate();else if(t.target===topButtons.Upload)disconnectedFileInput.click();else if(t.target===topButtons["Daily Notes"])goto("dailyNotes");else if("autocomplete__suggestion"===t.target.className)focusSuggestion&&(focusSuggestion.dataset.selected=!1),t.target.dataset.selected=!0,autocomplete();else if(t.target===topButtons.Help)goto("pageTitle","Welcome to Micro Roam");else if(n)goto("pageTitle",n.dataset.title);else if(s)goto("block",s.dataset.id);else if("exit-to-main"==t.target.className)signupElement.style.display="none",loginElement.style.display="none";else if("command__suggestion"===t.target.className)execInlineCommand();else if("image-embed"===t.target.className)focusBlockStart(t.target.closest(".block")),t.preventDefault();else if("todo-checkbox"===t.target.className){const a=t.target.checked,l=a?"TODO":"DONE",i=t.target.closest(".block"),c=i.dataset.id,d=t.target.closest(".compute");let e=store.blox[c].s;e=e.substring(0,d.startIdx)+"[["+l+"]]"+e.substring(d.endIdx),macros.write(c,e);const u=t.target.closest(".block__body");u.textContent="",renderBlockBody(u,e),t.preventDefault()}else if("top-connect"===t.target.id)if("none"===connectFrame.style.display){connectFrame.style.display="block";otherStores}else connectFrame.style.display="none"}else t.target.dataset.title?goto("pageTitle",t.target.dataset.title):goto("block",t.target.dataset.id)}});const commonAncestorNode=(e,t)=>{const o=[];for(;void 0!==e.dataset.id;)o.push(e.dataset.id),e=e.parentNode.parentNode;const n=[];for(;void 0!==t.dataset.id;){if(n.push(t.dataset.id),-1!==o.indexOf(t.dataset.id)){const s=o[o.indexOf(t.dataset.id)-1],r=n[n.length-2],a=store.blox[t.dataset.id].k,l=a?a.indexOf(r):-1,i=a?a.indexOf(s):-1,c=Math.max(i,l);return{root:t,startIdx:Math.max(Math.min(i,l),0),endIdx:-1===c?a.length:c,rooted:-1===l||-1===i}}t=t.parentNode.parentNode}},setDragSelected=t=>{if(dragSelect)if(dragSelect.rooted)dragSelect.root.dataset.selected=t;else{const o=getChildren(dragSelect.root);for(let e=dragSelect.startIdx;e<dragSelect.endIdx+1;e++)o[e].dataset.selected=t}},mouseMoveListener=e=>{setDragSelected(!1);const t=e.target.closest(".block");if(t&&t!==dragSelectStartBlock){getSelection().empty();const o=commonAncestorNode(dragSelectStartBlock,t);o&&(dragSelect=o,setDragSelected(!0))}else dragSelect=null};document.addEventListener("mousedown",e=>{setDragSelected(!1),dragSelect=null,e.target.closest(".block")&&(document.addEventListener("mousemove",mouseMoveListener),dragSelectStartBlock=e.target.closest(".block"))}),document.addEventListener("mouseup",e=>{null!==dragSelectStartBlock&&(document.removeEventListener("mousemove",mouseMoveListener),dragSelectStartBlock=null)}),document.addEventListener("selectionchange",e=>{if(focusNode=getSelection().focusNode,focusOffset=getSelection().focusOffset,focusNode){const t=focusNode.parentNode.closest(".block");if(t&&canWriteBloc(t.dataset.id))return sessionState.isFocused=!0,sessionState.position=(focusNode.startIdx||0)+focusOffset,void(t.dataset.id!==sessionState.focusId&&(sessionState.focusId=t.dataset.id,focusIdPosition()))}sessionState.isFocused=!1});const showTopBarFn=()=>{user.s.topBar="visible",saveUser()};let showTopBarTimeout=null;topBarHiddenHitbox.addEventListener("mouseover",()=>{clearTimeout(showTopBarTimeout),showTopBarTimeout=setTimeout(showTopBarFn,400)}),topBarHiddenHitbox.addEventListener("mouseout",()=>{clearTimeout(showTopBarTimeout),showTopBarTimeout=null}),disconnectedFileInput.addEventListener("change",e=>{const t=e.target.files[0];console.log(t);const{name:o,ext:n}=splitFileName(t.name);console.log(`name ${o} extension ${n}`),"zip"===n?t.arrayBuffer().then(e=>{const t=zipToFiles(e);if(console.log(t),1===t.length&&"json"===t[0].ext)store=roamJsonToStore(t[0].name,t[0].text),preprocessImportedStore();else throw notifyText("Markdown import doesn't work yet. Upload a .json file, or a .zip file containing a .json file instead.",12),new Error("md import doesn't work")}):"json"===n?t.text().then(e=>{user.s.graphName=o,store=roamJsonToStore(o,e),preprocessImportedStore()}):notifyText("Micro Roam only accepts a .json file or .zip file containing 1 .json file")});const preprocessImportedStore=async()=>{startFn=()=>gotoNoHistory("dailyNotes"),await addGraph(),start()};topButtons["Sign Up"].addEventListener("click",e=>{focusSignup(),e.stopPropagation(),e.preventDefault()});const focusSignup=()=>{signupElement.style.display="block",loginElement.style.display="none",signupEmailElement.focus()},focusLogin=()=>{loginElement.style.display="block",signupElement.style.display="none",loginEmailElement.focus()};switchToSignup.addEventListener("click",focusSignup),switchToLogin.addEventListener("click",focusLogin);const rwlClickOutListener=e=>{console.log("rwlclick"),null===e.target.closest(".really-want-to")&&(reallyWantToLeaveElement.style.display="none",document.removeEventListener("click",rwlClickOutListener))};topButtons["Sign Out"].addEventListener("click",()=>{isSynced()?reset():(reallyWantToLeaveElement.style.display="flex",document.addEventListener("click",e=>rwlClickOutListener(e)),event.stopPropagation())}),reallyWantToLeaveElement.children[0].addEventListener("click",reset),topHamburgerElement.addEventListener("click",()=>{"block"==optionsFrame.style.display?optionsFrame.style.display="none":optionsFrame.style.display="block"}),topButtons["Create New Graph"].addEventListener("keydown",e=>{"Enter"===e.key&&createAndSwitchToNewStore(e.target.value)});const inlineCommandReplaceString=(e,t=0)=>{sessionState.position=editingCommandElement.firstChild.startIdx+e.length+t,editingCommandElement.innerText=e,setFocusedBlockString(focusBlockBody.innerText)},inlineCommands={TODO:()=>{const e=editingCommandElement.firstChild.startIdx+9;editingCommandElement.remove();let t=focusBlockBody.innerText;t="{{#TODO}}"+t,sessionState.position=e,setFocusedBlockString(t)},"page link":()=>{inlineCommandReplaceString("[[]]",-2)},today:()=>{inlineCommandReplaceString("[["+formatDate(new Date(Date.now()))+"]]")},video:()=>{inlineCommandReplaceString("{{#video: }}",-2)},query:()=>{inlineCommandReplaceString("{{#query: }}",-2)},"current time":()=>{const e=new Date(Date.now());inlineCommandReplaceString(formatTime(e))},tomorrow:()=>{inlineCommandReplaceString("[["+getTomorrowDateString()+"]]")},yesterday:()=>{inlineCommandReplaceString("[["+getYesterdayDateString()+"]]")},"next week":()=>{inlineCommandReplaceString("[["+getNextWeekDateString()+"]]")},"last week":()=>{inlineCommandReplaceString("[["+getLastWeekDateString()+"]]")},bold:()=>{inlineCommandReplaceString("****",-2)},italic:()=>{inlineCommandReplaceString("____",-2)},highlight:()=>{inlineCommandReplaceString("^^^^",-2)}};let commandSearchCache=[];const matchInlineCommand=e=>{commandSearchCache=[];let t;try{t=newSearchRegex(e)}catch(e){return commandSearchCache}for(let e in inlineCommands)e.match(t)&&commandSearchCache.push({string:e});return commandSearchCache},execInlineCommand=()=>{inlineCommandList.style.display="none",inlineCommands[focusSuggestion.dataset.string]()},roamBloxProps={children:"k",string:"s",title:"s","create-time":"ct","edit-time":"et",":create/user":"cu",":edit/user":"eu",uid:"uid",refs:"",":block/refs":""},roamJsonToStore=(e,t)=>{console.log("roamJsontostore");const o=performance.now(),s=intToBase64(Date.now()),n=JSON.parse(t);store=blankStore(),store.graphName=e,n[0][":edit/user"]&&(store.ownerRoamId=n[0][":edit/user"][":user/uid"]),ownerRoamId=store.ownerRoamId;const r=(t,e)=>{const o=intToBase64(t["create-time"])||s,n={s:t.string,p:e,ct:o,et:intToBase64(t["edit-time"])||o};store.blox[t.uid]=n,t[":create/user"]&&t[":create/user"][":user/uid"]!==ownerRoamId?n.cu=t[":create/user"][":user/uid"]:delete n.cu,t[":edit/user"]&&t[":edit/user"][":user/uid"]!==ownerRoamId?n.eu=t[":edit/user"][":user/uid"]:delete n.eu,t.children&&(n.k=t.children.map(e=>e.uid),t.children.forEach(e=>r(e,t.uid)));for(let e in t)e in roamBloxProps||(store.roamProps[t.uid]||(store.roamProps[t.uid]={}),store.roamProps[t.uid][e]=t[e])};for(let t of n){store.titles[t.title]=t.uid;const a=intToBase64(t["create-time"])||s,l={s:t.title,ct:a,et:intToBase64(t["edit-time"])||a};store.blox[t.uid]=l;for(let e in t)e in roamBloxProps||(store.roamProps[t.uid]||(store.roamProps[t.uid]={}),store.roamProps[t.uid][e]=t[e]);if(t[":create/user"]&&t[":create/user"][":user/uid"]!==ownerRoamId?l.cu=t[":create/user"][":user/uid"]:delete l.cu,t[":edit/user"]&&t[":edit/user"][":user/uid"]!==ownerRoamId?l.eu=t[":edit/user"][":user/uid"]:delete l.eu,void 0!==t.children){const i=[];l.k=i;for(let e=0;e<t.children.length;e++){const c=t.children[e];i.push(c.uid),r(c,t.uid)}}}return generateRefs(store),user.s.commitId="MYVERYFIRSTCOMMITEVER",console.log(`roamJsonToStore took ${performance.now()-o}`),console.log(store),store},storeToRoamJSON=s=>{const t=[],r=e=>{const t=s.blox[e],o={uid:e,string:t.s};t.ct&&(o["create-time"]=base64ToInt(t.ct)),t.et&&(o["edit-time"]=base64ToInt(t.et));const n=s.roamProps[e];return n&&Object.assign(o,n),t.k&&(o.children=t.k.map(r)),o[":create/user"]={":user/uid":s.ownerRoamId},o[":edit/user"]={":user/uid":s.ownerRoamId},t.cu&&(o[":create/user"]={":user/uid":t.cu}),t.eu&&(o[":edit/user"]={":user/uid":t.eu}),o};for(let e in s.titles){const o=s.titles[e],n=s.blox[o],a=s.roamProps[o],l={uid:o,title:n.s};n.ct&&(l["create-time"]=base64ToInt(n.ct)),n.et&&(l["edit-time"]=base64ToInt(n.et)),t.push(l),Object.assign(l,a),n.k&&(l.children=n.k.map(r)),l[":create/user"]={":user/uid":s.ownerRoamId},l[":edit/user"]={":user/uid":s.ownerRoamId},n[":create/user"]&&(l[":create/user"]={":user/uid":n[":create/user"]}),n[":edit/user"]&&(l[":edit/user"]={":user/uid":n[":edit/user"]})}return console.log(t),JSON.stringify(t)},oldStoreToRoamJSON={4:n=>{const t=[],s=e=>{const t={uid:e},o=n.blocks[e];return Object.assign(t,o),o.children&&(t.children=o.children.map(s)),t[":create/user"]={":user/uid":n.ownerRoamId},t[":edit/user"]={":user/uid":n.ownerRoamId},o[":create/user"]&&(t[":create/user"]={":user/uid":o[":create/user"]}),o[":edit/user"]&&(t[":edit/user"]={":user/uid":o[":edit/user"]}),o.refs&&(t.refs=o.refs.map(e=>({uid:e}))),o[":block/refs"]&&(t[":block/refs"]=o[":block/refs"].map(e=>({":block/uid":e}))),delete t.backRefs,delete t.parent,t};for(let e in n.pages){const o=n.pages[e],r={uid:e};t.push(r),Object.assign(r,o),delete r.backRefs,o.children&&(r.children=o.children.map(s)),r[":create/user"]={":user/uid":n.ownerRoamId},r[":edit/user"]={":user/uid":n.ownerRoamId},o[":create/user"]&&(r[":create/user"]={":user/uid":o[":create/user"]}),o[":edit/user"]&&(r[":edit/user"]={":user/uid":o[":edit/user"]})}return console.log(t),JSON.stringify(t)}},mdToStore=t=>{const n=intToBase64(Date.now()),s=(store,{});store=blankStore();for(let e of t){const r=e.name,a=e.text,l=(o=r,store.pagesByTitle[o]||newUid()),i={"create-time":n,title:r};if(store.pages[l]=i,store.pagesByTitle[r]=l,0<a.length){i.children=[];const c=e=>{const t=newUid();s[e]=t;const o={"create-time":n,string:e};store.blocks[t]=o,i.children.push(t)},d=(i,a.matchAll(/\n((?:    )*)- /g));let t=2;for(let e of d)c(a.substring(t,e.index)),t=e.index+e[0].length;c(a.substring(t))}}var o;console.log(store)},parseMdBlock=e=>{},blocToMd=e=>{let n="";const s=(e,t)=>{const o=store.blox[e];void 0===o&&console.log(e);for(let e=0;e<t;e++)n+="    ";n+="- "+o.s.replaceAll(/\(\(([a-zA-Z0-9\-_]+)\)\)/g,(e,t)=>{const o=store.blox[t];return o?'"'+store.blox[t].s+'"':e})+"\n";for(let e of o.k||[])s(e,t+1)};return s(e,0),n},storeToMdObjects=()=>{const o=[];for(let e in store.titles){const n=store.blox[store.titles[e]];let t="";for(let e of n.k||[])t+=blocToMd(e);o.push({fullName:e+".md",text:t})}return o},storeToMdZip=()=>filesToZip(storeToMdObjects()),LOCAL_FILE_SIGNATURE=67324752,LOCAL_FILE_HEADER_LENGTH=30,END_CENTRAL_DIR_SIGNATURE=101010256,END_CENTRAL_DIR_HEADER_LENGTH=46,CENTRAL_FILE_SIGNATURE=33639248,ARCHIVE_EXTRA_RECORD_SIGNATURE=134630224,CRC_32_MAGIC=2869187666,splitFileName=e=>{const t=e.match(/\.([a-z]+)$/);return{name:e.substring(0,t.index),ext:t[1]}},zipToFiles=e=>{const t=new Uint8Array(e);let o=0;const n=[];for(;o<t.length;){const s=new ArrayBuffer(4),r=new Uint8Array(s);for(let e=0;e<4;e++)r[e]=t[o+e];const a=new Uint32Array(s)[0];if(a!==LOCAL_FILE_SIGNATURE){if(a===END_CENTRAL_DIR_SIGNATURE){console.log("got end central dir signature");break}console.log(`got signature ${a}`);break}{const l=new Uint16Array(e,8,1)[0];if(0!==l)return console.log(l),void notifyText("Micro Roam can't handle .zip files that are actually compressed. use a .json file or an uncompressed .zip file, like ones exported by Roam Research or Micro Roam",10);{const i=new ArrayBuffer(12),c=new Uint8Array(i);for(let e=0;e<12;e++)c[e]=t[e+18+o];const d=new Uint32Array(i),u=(d[0],d[1]),m=d[2];if(1441805<=m)break;const g=new TextDecoder,f=g.decode(new Uint8Array(e,o+30,m)),{name:p,ext:k}=splitFileName(f),S=g.decode(new Uint8Array(e,o+30+m,u));n.push({name:p,ext:k,text:S,fullName:f}),o+=30+m+u}}}return n};let crcTable=null;const makeCRCTable=()=>{let t;crcTable=[];for(let e=0;e<256;e++){t=e;for(let e=0;e<8;e++)t=1&t?3736805603^t>>>1:t>>>1;crcTable[e]=t}};function crc32(t,o,n){null===crcTable&&makeCRCTable();let s=-1;for(let e=o;e<n;e++)s=s>>>8^crcTable[255&(s^t[e])];return(-1^s)>>>0}const dateUnixToMsDosFormat=e=>{const t=new Date(e),o=t.getDate(),n=t.getMonth()+1,s=t.getFullYear()-1980;let r=o+(n<<5)+(s<<9);return console.log(r),console.log(r.toString(2)),r},writeU16ToU8Array=(e,t,o)=>{e[t]=o<<24>>>24,e[t+1]=o<<16>>>24},writeIntToU8Array=(e,t,o)=>{e[t]=o<<24>>>24,e[t+1]=o<<16>>>24,e[t+2]=o<<8>>>24,e[t+3]=o>>>24},ZIP_VERSION=10,blankLocalHeader=new Uint8Array(30);writeIntToU8Array(blankLocalHeader,0,LOCAL_FILE_SIGNATURE),writeIntToU8Array(blankLocalHeader,14,CRC_32_MAGIC),writeU16ToU8Array(blankLocalHeader,4,ZIP_VERSION);const blankCentralHeader=new Uint8Array(46);writeIntToU8Array(blankCentralHeader,0,CENTRAL_FILE_SIGNATURE),writeU16ToU8Array(blankCentralHeader,4,16),writeU16ToU8Array(blankCentralHeader,6,ZIP_VERSION);const copyBuffer=(t,o,n,s,r)=>{for(let e=0;e<r;e++)n[s+e]=t[o+e]},filesToZip=t=>{const e=Date.now(),o=dateUnixToMsDosFormat(e),n=performance.now();let s="",r=0;for(let e of t)s+=e.fullName+e.text,r+=30+e.fullName.length+e.text.length;let a=textEncoder.encode(s).length+LOCAL_FILE_HEADER_LENGTH*t.length+END_CENTRAL_DIR_HEADER_LENGTH;console.log(s.length-r),console.log(`mstime ${performance.now()-n}`);let l=new ArrayBuffer(a),i=new Uint8Array(l),c=0;for(let e of t){const u=c;copyBuffer(blankLocalHeader,0,i,c,blankLocalHeader.length),writeU16ToU8Array(i,u+10,o),writeU16ToU8Array(i,u+12,o),c+=blankLocalHeader.length;const m=i.subarray(c),{read:g}=textEncoder.encodeInto(e.fullName,m);c+=g;const f=i.subarray(c),{read:p}=textEncoder.encodeInto(e.text,f),k=crc32(i,c,c+p);writeIntToU8Array(i,u+14,k),c+=p,writeIntToU8Array(i,u+18,p),writeIntToU8Array(i,u+22,p),writeU16ToU8Array(i,u+26,g)}const d=new Blob([l]);return console.log(`filestozip ${performance.now()-n}`),d},testRoundTrip=()=>{const e=storeToRoamJSON(store);store=roamJsonToStore(store.graphName,e);const t=storeToRoamJSON(store),o=e===t;o?console.log("Round trip test passed!"):(console.log(e),console.log(t),console.error("round trip failed"))},createPageTest=()=>{const e=store;store=blankStore(),macros.createPage("Test Page"),store=e};let testSTime;const renderMulti=(e,t=void 0,o=100,n=!1)=>{if(n||(testSTime=performance.now()),0<o){const s=e(t);s||setTimeout(()=>renderMulti(e,t,o-1,!0),0)}else console.log(`test func took ${performance.now()-testSTime}`)},benchmarkPageLoad=()=>renderMulti(()=>goto("pageTitle","Welcome to Micro Roam"));let benchmarkRandomWalkSTime=null;const benchmarkRandomWalk=()=>renderMulti(()=>{let t=[];const o=document.querySelectorAll(".page-ref"),n=document.querySelectorAll(".tag"),s=document.querySelectorAll(".breadcrumb-page");for(let e of o)t.push(e.children[2].innerText);for(let e of n)t.push(e.innerText.substring(1));for(let e of s)t.push(e.innerText);t=t.filter(e=>store.titles[e]&&store.blox[store.titles[e]]);const e=t[Math.floor(Math.random()*(t.length-1))];goto("pageTitle",e)}),benchmarkRenderAll=async()=>{const e=performance.now();let t=0,o=0;for(let e in store.titles){const r=performance.now();gotoNoHistory("pageTitle",e),t+=performance.now()-r,o+=1,await new Promise(e=>setTimeout(e,0))}const n=performance.now()-e,s=`rendered ${o} pages in ${Math.round(n)}ms, avg ${Math.round(n/o)}ms \nfunction time avg ${Math.round(t/o)}`;console.log(s),notifyText(s,10)},testAll=()=>{testRoundTrip(),benchmarkPageLoad(),benchmarkRandomWalk(),benchmarkRenderAll()},benchmarkGen=()=>{const e=performance.now();for(let e=0;e<100;e++)generateInnerRefs();console.log(`gen took ${performance.now()-e}`)},log=()=>{user.s.logging=!0,saveUser()},nolog=()=>{user.s.logging=!1,saveUser()},flash=benchmarkRenderAll,blank=(e="default")=>{store=blankStore(),store.graphName=e,user={s:{graphName:"default",theme:window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",topBar:"visible",logging:!1,spellcheck:!1,editingSpotlight:!0}},user.s.graphName=e,saveUser(),debouncedSaveStore(),goto("dailyNotes")},pr=()=>{console.log(JSON.stringify(store))},downloadBinary=()=>{const e=storeToBinary(),t=new Blob([e],{type:"application/x-micro-roam"}),o=URL.createObjectURL(t),n=document.createElement("a");n.setAttribute("href",o),n.setAttribute("download",`${store.graphName}.mrm`),n.click()},monitor=string=>{const js=`setInterval(()=>console.log(${string}), 500)`;eval(js)},terminalCommands={blank:blank,reset:reset,flash:flash,log:log,page:page,nolog:nolog,pr:pr,downloadBinary:downloadBinary,monitor:monitor}</script>