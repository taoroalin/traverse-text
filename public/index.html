<body>
  <div id="app">
    <div id="top-bar" style="margin-top:0px">
      <a id="report-issue-button" target="_blank" href="mailto:taoroalin@gmail.com?subject=You Made Micro Roam Wrong"
        tabindex="-1">
        Report Issue
      </a>
      <button id="help-button" tabindex="-1">
        Help
      </button>
      <button id="daily-notes-button" tabindex="-1">
        Daily Notes
      </button>
      <input id="search-input" placeholder="search" tabindex="-1">
      <button id="upload-button" tabindex="-1">
        <input style="display:none" type="file" id="upload-input">
        Upload JSON
      </button>
      <a id="download-button" tabindex="-1">
        Download JSON
      </a>
    </div>

    <div id="top-bar-hidden-hitbox" style="position:fixed;height:15px;width:100%"></div>

    <div id="terminal" contenteditable="true" style="display:none"></div>

    <div id="page-frame-outer">
      <div id="page-frame">

      </div>
    </div>

    <div id="autocomplete-list" style="display:none"></div>
    <!-- inline styles on this site are all edited directly by js -->
    <div id="search-result-list" style="display:none"></div>
    <div id="template-list" style="display:none"></div>

  </div>
  <script>
    const r = indexedDB.open("microroam",4);// I had this as line 1, saves ~5ms start time, don't now cause I'm lazy
    // This needs to be the exact same db version as in worker.js
    const blankUser = { graphName: "default",theme: "light",topBar: "visible",logging: false,spellcheck: false }
    let user = blankUser
    const storedUser = localStorage.getItem("user")
    if (storedUser) user = JSON.parse(storedUser)
    let w = false; // flag for whether either code or data loaded
    let store = null;
    let idb = null

    const theresANewStore = () => {
      user.graphName = store.graphName
      saveUser()
      gotoNoHistory("dailyNotes")
      setTimeout(() => saveWorker.postMessage(["save",store]),0)
    }

    r.onsuccess = (e1) => {
      idb = e1.target.result
      idb.transaction(["stores"],"readonly").objectStore("stores").get(user.graphName).onsuccess = (e) => {
        if (e.target.result) {
          store = JSON.parse(e.target.result.store)
          if (w) {
            theresANewStore()
          } else
            w = true;
        } else {
          console.log("adding default graph")
          fetch("./default-store.json").then(text => text.json().then(json => {
            store = json
            user.graphName = json.graphName
            if (w) {
              theresANewStore()
            } else
              w = true;
          }))
        }
      }
    }
    r.onupgradeneeded = (event) => {
      const db = r.result
      const stores = Array.from(db.objectStoreNames)
      if (!stores.includes("stores"))
        db.createObjectStore("stores",{ keyPath: "graphName" })
    }
    r.onerror = (event) => {
      alert(`In order to save your notes between sessions, Micro Roam needs access to IndexedDB. 
      You can allow access by exiting "private browsing" mode, or by using a newer browser, or by changing browser settings`)
    }

    let commitDebounce = null

    let editingTemplateExpander = null

    let editingLink = null
    let editingTitle = null
    let focusNode = null
    let focusOffset = null

    let focusBlock = null

    let focusSuggestion = null
    let sessionState = { pageFrame: "dailyNotes",focusId: null,scroll: 0,position: null }

    const topBar = document.getElementById("top-bar")
    const topBarHiddenHitbox = document.getElementById("top-bar-hidden-hitbox")

    const showTopBar = () => {
      topBar.style.marginTop = "0px"
      topBarHiddenHitbox.style.display = "none"
    }
    const hideTopBar = () => {
      topBar.style.marginTop = "-46px"
      topBarHiddenHitbox.style.display = "block"
    }
    const saveUser = () => {
      document.body.className = user.theme
      if (user.topBar === "visible") showTopBar()
      else hideTopBar()
      localStorage.setItem("user",JSON.stringify(user))
    }
    saveUser()


    /* This inline script is all about opening a connection to IndexedDB and setting the user's theme ASAP. This allows IndexedDB to run in parallel with main script compilation, and avoids layout thrashing
    What happens is:
    1: IndexedDB Open request sent.
    2: Add onsuccess listener to request (if the request somehow succeeds before then, it fails). Then get user settings from localstorage, which tells you which graph to get out of indexeddb once the idb request succeeds (if request succeeds first, it loads default graph). Then set body class to user's color theme (which is why this script is in the html body) quickly so they don't see the screen flash the wrong color. Then add upgradeneeded, onerror listeners, then initialize global variables
    Onsuccess handler: sets store, then checks whether last script has finished loading, if it has, start rendering. That script also checks whether data loded, and triggers render if data is loaded
    */
  </script>

  <title>Micro Roam</title>

  
<style>
/* global styles ----------------------------------------------------------------------------- */
*{
  outline:none;
  scrollbar-width:none;
}

.dark{
  --background:#161616;
  --text: white;
  --link: #3f84c0;
  --brackets:#A7B6C2;
  --block-ref:rgb(63, 63, 63);
  --bullet:#758897;
  --border:#afbeca;
  --break: #838e97;
  --highlight:rgb(110, 93, 16);
  --click:darkgrey;
  --page-ref:#2bcc5b;
  --shadow:rgb(98, 98, 98);
  --notification:#2e4736;
}

.light{
  --background:white;
  --text:black;
  --link: rgb(54, 123, 184);
  --brackets:#A7B6C2;
  --block-ref:lightgrey;
  --bullet:#394B59;
  --border:#585e64;
  --shadow:#585e64;
  --break:#a8b4be;
  --highlight:rgb(255, 239, 146);
  --click:rgb(197, 197, 197);
  --page-ref:rgb(73, 197, 91);
  --notification:#a4d1b1;
}

input, button, a{
  font-family: 'Inter', Verdana;
}

input{
  border:none;
}

button{
  appearance: none;
  border:none;
  box-shadow: none;
  cursor:pointer;
  background-color:inherit;
  color:inherit;
  font-size:inherit;
}

span{
  margin:0;
  padding:0;
}

::-webkit-scrollbar{
  width:0%;
  height:0%;
}

::selection{
  background-color:#85b7e8;
  color:var(--text);
}

body {
    scrollbar-width: 0px;
    font-family: 'Inter', Verdana, Arial;
    font-weight: normal;
    margin: 0;
    color:var(--text);
    background-color: var(--background);
}

a{
  color:var(--link);
}

a:visited { color:var(--link) }

.notification{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  top:-40px; /* transitions to more px */
  margin-top: 0px;
  opacity:1;
  transition: top 0.25s ease-out, opacity 0.2s linear;
  padding:20px;
  background-color:var(--notification);
  border-radius:8px;
}


/* singular element styles --------------------------------------------------------------------------------------- */

#app{
  height:100%;
  width:100%;
  display:flex;
  flex-direction: column;
}

#page-frame-outer{
  width:100%;
  overflow-y:scroll;
}

#page-frame{
  margin: 0 auto 30px;
  max-width: min(900px, 100%);
}

#top-bar{
  width:100%;
  display: flex;
  flex-direction: row;
  align-content: space-between;
  background-color:var(--background);
  transition:margin-top 0.1s;
}

/* these have different paddings, but look the same because weird stuff. todo investigate */
#top-bar a{
  padding: 14px 10px 10px;
  font-size:0.9em;
}
#top-bar button{
  padding: 12px 10px 10px;
  font-size:0.9em;
}


#download-button, #report-issue-button {
  color:var(--text);
  display:block;
  cursor:pointer;
  text-decoration: none;
}

#search-input{
  background-color:var(--background);
  color:var(--text);
  padding:3px 13px;
  margin: 7px 5px 5px;
  display:block;
  font-size:1.2em;
  box-shadow:0 0 2px var(--shadow);
  border-radius:100px;
  flex-grow: 1;
}

#autocomplete-list, #template-list{
  position:absolute;
  display:flex;
  flex-direction: column;
  background-color:var(--background);
  font-size:1.3em;
  border-radius:5px;
  box-shadow: 0 0 8px var(--shadow);
}

.autocomplete__suggestion[data-selected="true"],.template__suggestion[data-selected="true"]{
  background-color:var(--click);
}

.autocomplete__suggestion, .template__suggestion{
  padding:7px;
  cursor:pointer;
  border-radius: 5px;
}


#search-result-list{
  position:absolute;
  display:flex;
  flex-direction: column;
  background-color:var(--background);
  font-size:1.3em;
  border-radius:5px;
  box-shadow: 0 0 8px var(--shadow);
}

.search-result[data-selected="true"]{
  background-color:var(--click);
}

.search-result{
  padding:7px;
  cursor:pointer;
  border-radius: 5px;
}

/* Page styles --------------------------------------------------------------------------------------------------- */

.page{
  margin-right:30px;
  margin-left:30px;
  position:relative;
}

.page__title{
  font-size: 36px;
  margin: 40px 0 20px 0;
}

.page__body, .backref-frame__body{
  margin-left:20px;
}

.backref-list__body{
  margin-left:10px;
}

.backref-list__title{
  font-size: 1.2em;
  font-weight:bold;
  padding: 20px 0 0;
}

.page-break{
  height:0px;
  margin: 60px 25px;
  border:1px solid var(--break);
  border-width: 1px 0 0 0;
}


.block{
  position:relative;
}

.block__body{
  padding:5px 0;
}

.block__bullet{
  cursor:pointer;
  position:absolute;
  left:-21px;
  top:4px;
}

.block__children{
  margin-left: 25px;
}

.block-focus-frame{
  margin: 60px 0;
}

.breadcrumb-page{
  cursor:pointer;
}

.breadcrumb-block{
  cursor:pointer;
}

.backref-frame__breadcrumb{
  margin:15px 0 5px 0;
  font-size:1.2em;
}

.block-focus-frame__breadcrumb{
  margin:15px 0 5px 0;
  font-size:1.2em;
}

/* Parsed block styles -------------------------------------------------------------------------------------- */

.page-ref{
  position:relative;
}

.page-ref__brackets{
  font-weight: lighter;
  color:var(--brackets);
}

.page-ref__body{
  color:var(--page-ref);
  font-weight: 800;
}

.page-ref__body:hover{
  text-decoration: underline;
  cursor:pointer;
}

.tag{
  color:var(--page-ref);
  font-weight: 800;
  position:relative;
}

.tag:hover{
  text-decoration: underline;
  cursor:pointer;
}

.block-ref{
  background-color:var(--block-ref);
}

.block-ref:hover{
  text-decoration: underline;
  cursor:pointer;
}

.bold{
  font-weight:bold;
}

.italic{
  font-style:italic;
}

.highlight{
  background-color: var(--highlight);
  border-radius:2px;
  padding:1px;
}

.block-focus-frame{
  margin: 35px 0 0 60px;
}

.url{
  color:var(--link);
  text-decoration: underline;
  cursor:pointer;
}

.literal{
  font-family:'Inconsolata';
  font-size:1.15em;
}

#terminal{
  font-family:'Inconsolata';
  width:100%;
  padding:8px;
  background-color: black;
  color:white;
}
</style>


  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata">

  <template id="page">
    <div class="page">
      <h1 class="page__title" contenteditable="true" tabindex="-1"></h1>

      <div class="page__body">

      </div>
      <div class="page__backlinks">

      </div>
    </div>
  </template>

  <template id="block">
    <div class="block">
      <svg class="block__bullet" width="20" height="20">
        <circle cx="10" cy="10.5" r="3" fill="var(--bullet)" />
      </svg>
      <div class="block__body" contenteditable="true" tabindex="-1">
      </div>
      <div class="block__children">

      </div>
    </div>
  </template>

  <template id="backref-list">
    <div class="backref-list">
      <div class="backref-list__title">Linked References</div>
      <div class="backref-list__body"></div>
    </div>
  </template>

  <template id="page-break">
    <div class="page-break"></div>
  </template>

  <template id="block-focus-frame">
    <div class="block-focus-frame">
      <div class="block-focus-frame__breadcrumb"></div>
      <div class="block-focus-frame__body"></div>
      <div class="block-focus-frame__backlinks"></div>
    </div>
  </template>

  <template id="backref-frame">
    <div class="backref-frame">
      <div class="backref-frame__breadcrumb"></div>
      <div class="backref-frame__body"></div>
    </div>
  </template>

  <template id="page-ref">
    <span class="page-ref"><span class="page-ref__brackets"></span><span class="page-ref__body"></span><span
        class="page-ref__brackets"></span></span>
  </template>

  <template id="tag">
    <span class="tag"></span>
  </template>

  <template id="block-ref">
    <span class="block-ref"></span>
  </template>

  <template id="block-ref">
    <span class="block-ref"></span>
  </template>

  <template id="bold">
    <span class="bold"></span>
  </template>

  <template id="italic">
    <span class="italic"></span>
  </template>

  <template id="highlight">
    <span class="highlight"></span>
  </template>

  <template id="literal">
    <span class="literal"></span>
  </template>

  <!-- this is a bit silly, since this element doesn't show up as anyting, but for consistancy?? -->
  <template id="template-expander">
    <span class="template-expander"></span>
  </template>

  <!--using spans with event handlers as links because they play nice with contenteditable-->
  <template id="url">
    <span class="url"></span>
  </template>

  <template id="autocomplete__suggestion">
    <div class="autocomplete__suggestion"></div>
  </template>

  <template id="template__suggestion">
    <div class="template__suggestion"></div>
  </template>

  <template id="search-result">
    <div class="search-result"></div>
  </template>

  <template id="breadcrumb-block">
    <span class="breadcrumb-block"><span class="breadcrumb-block__arrow">-></span><span
        class="breadcrumb-block__body"></span></span>
  </template>

  <template id="breadcrumb-page">
    <span class="breadcrumb-page"></span>
  </template>

  <template id="notification">
    <div class="notification"></div>
  </template>

  
<script>
const monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
]

const getOrdinal = (i) => {
  const j = i % 10,
    k = i % 100
  if (j == 1 && k != 11) return i + "st"
  if (j == 2 && k != 12) return i + "nd"
  if (j == 3 && k != 13) return i + "rd"
  return i + "th"
}

const formatDate = (date) =>
  `${monthNames[date.getMonth()]} ${getOrdinal(
    date.getDate()
  )}, ${date.getFullYear()}`

const truncateElipsis = (text,limit = 40) => {
  if (text.length > limit) {
    return text.substring(0,limit - 3) + "..."
  }
  return text
}


// this script gets saved to local storage and rehydrated to serialize old versions of the database
// so I don't need to ship code to read all the old versions of the database

// wacky shit ahead
// the first time this gets loaded, it calls itself "storeToRoamJSON". Subsequent times it calls itself "oldStoreToRoamJSON". 
// so if you want to read old database, load current save-between-versions, then load one from localStorage, then call "oldStoreToRoamJSON"

const storeToRoamJSON = (store) => {
  const roamJSON = []

  const blockIdToJSON = (blockId) => {
    const result = { uid: blockId }
    const block = store.blocks[blockId]
    Object.assign(result,block)

    if (block.children) result.children = block.children.map(blockIdToJSON)

    result[":create/user"] = { ":user/uid": store.ownerRoamId }
    result[":edit/user"] = { ":user/uid": store.ownerRoamId }
    if (block[":create/user"])
      result[":create/user"] = { ":user/uid": block[":create/user"] }
    if (block[":edit/user"])
      result[":edit/user"] = { ":user/uid": block[":edit/user"] }

    if (block.refs) result.refs = block.refs.map(x => ({ uid: x }))
    if (block[":block/refs"]) result[":block/refs"] = block[":block/refs"].map(x => ({ ":block/uid": x }))

    delete result.backRefs
    delete result.parent
    return result
  }

  for (let pageId in store.pages) {
    const page = store.pages[pageId]
    const jsonPage = { uid: pageId }
    roamJSON.push(jsonPage)
    Object.assign(jsonPage,page)
    delete jsonPage.backRefs
    if (page.children) {
      jsonPage.children = page.children.map(blockIdToJSON)
    }
    jsonPage[":create/user"] = { ":user/uid": store.ownerRoamId }
    jsonPage[":edit/user"] = { ":user/uid": store.ownerRoamId }
    if (page[":create/user"])
      jsonPage[":create/user"] = { ":user/uid": page[":create/user"] }
    if (page[":edit/user"])
      jsonPage[":edit/user"] = { ":user/uid": page[":edit/user"] }
  }
  console.log(roamJSON)

  return JSON.stringify(roamJSON)
}

const getIn = (arr,skip) => {
  let result = store
  for (let i = 0; i < arr.length - skip; i++) {
    if (result[arr[i]] === undefined) {
      result[arr[i]] = {}
    }
    result = result[arr[i]]
  }
  return result
}

// Edit format: {delete:[[...keys]],write:[[...keys,value]], add:[[...keys, value]], subtract:[[...keys, value]], insert: [[...keys, value, idx]]}

const doEdits = (edits) => {

  // it's important that subtract comes first because you can subtract something then insert it earlier in the same list
  if (edits.subtract) {
    for (let op of edits.subtract) {
      const obj = getIn(op,2)
      const key = op[op.length - 2]
      obj[key] = obj[key].filter(x => (x != op[op.length - 1]))
    }
  }

  if (edits.write) {
    for (let op of edits.write) {
      const obj = getIn(op,2)
      obj[op[op.length - 2]] = op[op.length - 1]
    }
  }
  if (edits.add) {
    for (let op of edits.add) {
      const obj = getIn(op,2)
      obj[op[op.length - 2]].push(op[op.length - 1])
    }
  }
  if (edits.insert) {
    for (let op of edits.insert) {
      const obj = getIn(op,3)
      const key = op[op.length - 3]
      const val = op[op.length - 2]
      const idx = op[op.length - 1]
      let old = obj[key]
      if (old === undefined) {
        old = [val]
        obj[key] = old
      } else if (old.length < idx) {
        console.log(old)
        console.log(key)
        throw new Error(`tried to insert past end of list`)
      } else {
        obj[key] = old.slice(0,idx)
        obj[key].push(val)
        obj[key].push(...old.slice(idx))
      }
    }
  }
  if (edits.delete) {
    for (let op of edits.delete) {
      const obj = getIn(op,1)
      delete obj[op[op.length - 1]]
    }
  }
}


const print = (text) => {
  if (user.logging) {
    console.log(text)
  }
}

// idk whether this is "random enough"
// it is highly performance inneficient but i don't need to call this many times
const CHARS_64 = "-_0123456789abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ"
const newUid = () => {
  let result
  do {
    result = ""
    for (let i = 0; i < 9; i++) {
      result += CHARS_64[Math.floor(Math.random() * 64)]
    }
  } while (store.pages[result] !== undefined || store.blocks[result] !== undefined)
  return result
}

const blockOrPageFromId = (id) => {
  return store.blocks[id] || store.pages[id]
}

const parentThingey = (id) => store.pages[id] ? "pages" : "blocks"

const commands = {
  deleteBlock: (blockId) => {
    const block = store.blocks[blockId]
    const parentId = block.parent
    const refs = block[":block/refs"]
    const backRefs = block.backRefs
    // todo make child ref tracking on delete block
    const edits = {
      subtract: [[parentThingey(block.parent),parentId,"children",blockId],
      ...refs.map(ref => ([parentThingey(ref),ref,"backRefs",blockId])),
      ...backRefs.map(backRef => ([parentThingey(backRef),backRef,"refs",blockId]))],
      delete: [["blocks",blockId]]
    }

    return { edits }
  },

  moveBlock: (blockId,parentId,idx,time) => {
    const oldParent = store.blocks[blockId].parent
    const edits = {
      write: [["blocks",blockId,"parent",parentId]],
      insert: [[parentThingey(parentId),parentId,"children",blockId,idx]],
      subtract: [[parentThingey(oldParent),oldParent,"children",blockId]]
    }
    return { edits,returns: undefined }
  },

  // writeBlock takes link title list to avoid recomputation. couples this with renderBlockBody
  writeBlock: (blockId,string,refTitles,time) => {
    /**
     * This does a lot. It
     * 
     * writes string
     * writes :edit/time
     * writes :block/refs
     * writes corresponding backRefs
     * removes old backRefs
     * 
     */

    const block = store.blocks[blockId]
    const oldRefs = block[":block/refs"]

    const edits = {
      write: [],
      subtract: [],
      add: [],
      delete: []
    }

    // add refs
    const newRefs = refTitles.map(title => {
      let pageId = store.pagesByTitle[title]
      if (pageId !== undefined) {
        if (!oldRefs.includes(pageId)) {
          edits.add.push(["pages",pageId,"backRefs",blockId])
        }
        return pageId
      }
      pageId = newUid()
      edits.write.push(["pages",pageId,{ title: title,children: [],":create/time": time,backRefs: [blockId] }])
      edits.write.push(["pagesByTitle",title,pageId])
      return pageId
    })

    // add string, edit time
    edits.write.push(["blocks",blockId,"string",string],
      ["blocks",blockId,"edit-time",time],
      ["blocks",blockId,":block/refs",newRefs])


    // subtract old refs
    if (oldRefs) {
      for (let oldRef of oldRefs) {
        if (!newRefs.includes(oldRef)) {
          const page = store.pages[oldRef]
          if (parentThingey(oldRef) === "pages" && (page.children === undefined || page.children.length === 0) && (page.backRefs === undefined || page.backRefs.length <= 1)) {
            edits.delete.push(["pagesByTitle",page.title])
            edits.delete.push(["pages",oldRef])
          } else {
            edits.subtract.push([parentThingey(oldRef),oldRef,"backRefs",blockId])
          }
        }
      }
    }

    return { edits }
  },

  createBlock: (parentId,idx,time) => {
    const blockId = newUid()
    const parentThingey = !!store.pages[parentId] ? "pages" : "blocks"
    const parent = store[parentThingey]
    const edits = {
      write: [["blocks",blockId,{ string: "",parent: parentId,":create/time": time,children: [],backRefs: [],":block/refs": [],refs: parent.refs }]],
      insert: [[parentThingey,parentId,"children",blockId,idx]],
    }
    return { edits,returns: blockId }
  },

  createPage: (pageTitle,time) => {
    const pageId = newUid()
    const edits = {
      write: [["pages",pageId,{ title: pageTitle,children: [],":create/time": time,backRefs: [] }],
      ["pagesByTitle",pageTitle,pageId]]
    }
    return { edits,returns: pageId }
  },

  writePageTitle: (pageId,title,time) => {
    const page = store.pages[pageId]
    const oldTitle = page.title
    const edits = {
      write: [["pages",pageId,"title",title],
      ["pages",pageId,"edit-time",time],
      ["pagesByTitle",title,pageId]],
      delete: [["pagesByTitle",oldTitle]]
    }
    if (page.backRefs) {
      for (let backRef of page.backRefs) {
        const block = store.blocks[backRef]
        let string = block.string

        // this replaces all other instances of that word, not just linked ones. This is a feature decision I made because it's easy
        edits.write.push(["blocks",backRef,"string",string.replaceAll(oldTitle,title)])
      }
    }
    return { edits }
  },
  copyBlock: (blockId,parentId,idx,time) => {
    const newId = newUid()
    const edits = { write: [],insert: [[parentThingey(parentId),parentId,"children",newId,idx]],subtract: [] }
    const copyBlock = (oldId,newId,parentId) => {
      const block = store.blocks[oldId]
      const newBlock = { "create-time": time,string: block.string,parent: parentId }
      for (let propName of LIST_PROPS) {
        if (block[propName])
          newBlock[propName] = Array.from(block[propName])
      }
      if (block.children) {
        newBlock.children = []
        for (let child of block.children) {
          const newChildId = newUid()
          copyBlock(child,newChildId,newId)
          newBlock.children.push(newChildId)
        }
      }
      edits.write.push(["blocks",newId,newBlock])
    }
    copyBlock(blockId,newId,parentId)
    return { edits,returns: newId }
  }

}

const runCommand = (...command) => {
  const { edits,returns } = commands[command[0]](...command.slice(1),Date.now())
  doEdits(edits)
  saveWorker.postMessage(["edits",edits])
  return returns
}


const blankStore = () => ({
  graphName: "default",
  ownerRoamId: "default",
  blocks: {},
  pages: {},
  pagesByTitle: {}
})

const LIST_PROPS = ["refs",":block/refs","backRefs"]

const LOCAL_FILE_SIGNATURE = 0x04034b50
const END_CENTRAL_DIR_SIGNATURE = 0x06054b50

const CENTRAL_FILE_SIGNATURE = 0x02014b50
const ARCHIVE_EXTRA_RECORD_SIGNATURE = 0x08064b50
const ZIP64_END_CENTRAL_SIGNATURE = 0x06064b50

const zipToFiles = (buffer) => {
  const bufferU8 = new Uint8Array(buffer)
  const length = bufferU8.length
  let idx = 0
  const result = []
  while (idx < length) {
    // I have to copy header u32s into new arrays because they might not be aligned :(
    const sigBuf = new ArrayBuffer(4)
    const sigInt8 = new Uint8Array(sigBuf)
    for (let i = 0; i < 4; i++) {
      sigInt8[i] = bufferU8[idx + i]
    }
    const sigInt = (new Uint32Array(sigBuf))[0]
    if (sigInt === LOCAL_FILE_SIGNATURE) {
      const compressionMethod = (new Uint16Array(buffer,8,1))[0]
      if (compressionMethod === 0) {

        const dumbArray = new ArrayBuffer(12)
        const dumbu8 = new Uint8Array(dumbArray)
        for (let i = 0; i < 12; i++) {
          dumbu8[i] = bufferU8[i + 18 + idx]
        }
        const dumbu32 = new Uint32Array(dumbArray)
        const compressedSize = dumbu32[0]
        const rawSize = dumbu32[1]
        const fileNameSize = dumbu32[2]

        if (fileNameSize >= 1441805) {
          break
        }
        const decoder = new TextDecoder()
        const fullName = decoder.decode(new Uint8Array(buffer,idx + 30,fileNameSize))
        const match = fullName.match(/\.([a-z]+)$/)
        const text = decoder.decode(new Uint8Array(buffer,idx + 30 + fileNameSize,rawSize))
        let ext,name
        if (match) {
          ext = match[1]
          name = fullName.substring(0,match.index)
        }
        result.push({ name,ext,text,fullName })
        idx += 30 + fileNameSize + rawSize

      } else {
        console.log(compressionMethod)
        notifyText("Micro Roam can't handle .zip files that are actually compressed. use a .json file or an uncompressed .zip file, like ones exported by Roam Research or Micro Roam",10)
        return
      }
    } else if (sigInt === END_CENTRAL_DIR_SIGNATURE) {
      break
    } else {
      console.log(`got signature ${sigInt}`)
      break
    }
  }
  return result
}
/*
ZIP

[local file header 1]
[encryption header 1]
[file data 1]
[data descriptor 1]
. 
.
.
[local file header n]
[encryption header n]
[file data n]
[data descriptor n]
[archive decryption header] 
[archive extra data record] 
[central directory header 1]
.
.
.
[central directory header n]
[zip64 end of central directory record]
[zip64 end of central directory locator] 
[end of central directory record]

local file header signature     4 bytes 0  (0x04034b50)
version needed to extract       2 bytes 4
general purpose bit flag        2 bytes 6
compression method              2 bytes 8
last mod file time              2 bytes 10
last mod file date              2 bytes 12
crc-32                          4 bytes 14
compressed size                 4 bytes 18
uncompressed size               4 bytes 22
file name length                2 bytes 26
extra field length              2 bytes 28

central file header signature   4 bytes 0  (0x02014b50)
version made by                 2 bytes 4
version needed to extract       2 bytes 6
general purpose bit flag        2 bytes 8
compression method              2 bytes 10
last mod file time              2 bytes 12
last mod file date              2 bytes 14
crc-32                          4 bytes 16
compressed size                 4 bytes 20
uncompressed size               4 bytes 24
file name length                2 bytes 28
extra field length              2 bytes 30
file comment length             2 bytes 32
disk number start               2 bytes 34
internal file attributes        2 bytes 36
external file attributes        4 bytes 38
relative offset of local header 4 bytes 42

end of central dir signature    4 bytes  (0x06054b50)
number of this disk             2 bytes
number of the disk with the
start of the central directory  2 bytes
total number of entries in the
central directory on this disk  2 bytes
total number of entries in
the central directory           2 bytes
size of the central directory   4 bytes
offset of start of central
directory with respect to
the starting disk number        4 bytes
.ZIP file comment length        2 bytes
.ZIP file comment       (variable size)

If one of the fields in the end of central directory
record is too small to hold required data, the field SHOULD be 
set to -1 (0xFFFF or 0xFFFFFFFF) and the ZIP64 format record 
SHOULD be created.

-- zip64 is for when data is too big for ZIP

*/

const roamJsonToStore = (graphName,text) => {
  const stime = performance.now()

  const obj = JSON.parse(text)

  const pages = {}
  const blocks = {}
  const pagesByTitle = {}

  let ownerRoamId = null
  // todo interface with roam user ids well
  if (obj[0][":edit/user"]) ownerRoamId = obj[0][":edit/user"][":user/uid"]

  const addBlock = (block,parent) => {
    blocks[block.uid] = block
    block.parent = parent

    // discard edit/user if it's the same as create/user to save space
    if (block[":create/user"] && block[":create/user"][":user/uid"] !== ownerRoamId)
      block[":create/user"] = block[":create/user"][":user/uid"]
    else delete block[":create/user"]
    if (block[":edit/user"] && block[":edit/user"][":user/uid"] !== ownerRoamId)
      block[":edit/user"] = block[":edit/user"][":user/uid"]
    else
      delete block[":edit/user"]

    if (block.children) {
      const children = block.children
      block.children = children.map(child => child.uid)
      children.forEach((child) => addBlock(child,block.uid))
    }
    if (block.refs)
      block.refs = block.refs.map(ref => ref.uid)
    if (block[":block/refs"])
      block[":block/refs"] = block[":block/refs"].map(ref => ref[":block/uid"])
    delete block.uid
    block.backRefs = []

    // Round points in drawings to nearest pixel to save 600K on my json
    if (block[":block/props"] && block[":block/props"][":drawing/lines"]) {
      for (let line of block[":block/props"][":drawing/lines"]) {
        line[":points"] = line[":points"].map(p => ([Math.round(p[0]),Math.round(p[1])]))
      }
    }
    if (block.props && block.props.lines) {
      for (let line of block.props.lines) {
        line.points = line.points.map(p => ([Math.round(p[0]),Math.round(p[1])]))
      }
    }
  }

  for (let page of obj) {
    pagesByTitle[page.title] = page.uid
    pages[page.uid] = page
    if (page[":create/user"] && page[":create/user"][":user/uid"] !== ownerRoamId)
      page[":create/user"] = page[":create/user"][":user/uid"]
    else delete page[":create/user"]
    if (page[":edit/user"] && page[":edit/user"][":user/uid"] !== ownerRoamId)
      page[":edit/user"] = page[":edit/user"][":user/uid"]
    else
      delete page[":edit/user"]

    if (page.children !== undefined) {
      const children = page.children
      page.children = []
      for (let child of children) {
        page.children.push(child.uid)
        addBlock(child,page.uid)
      }
    }
    delete page.uid
    page.backRefs = []
  }

  // add backrefs
  for (let blockUid in blocks) {
    const block = blocks[blockUid]

    if (block[":block/refs"]) {
      block[":block/refs"].forEach(ref => {
        if (blocks[ref] !== undefined) {
          blocks[ref].backRefs.push(blockUid)
        } else if (pages[ref] !== undefined) {
          pages[ref].backRefs.push(blockUid)
        } else {
          //throw new Error(`bad ref ${ref}`)
        }
      })
    }

  }

  // remove empty pages
  for (let pageId in pages) {
    const page = pages[pageId]
    if ((!page.children || page.children.length === 0) && page.backRefs.length === 0) {
      delete pagesByTitle[page.title]
      delete pages[pageId]
    }
  }

  const store = { graphName,pages,blocks,pagesByTitle,ownerRoamId }
  console.log(`roamJsonToStore took ${performance.now() - stime}`)
  console.log(store)

  return store
}


/*

Here's what's lost importing Markdown that's saved in JSON:
block author
block create time
block end time
block references get confused with quotes - referencing a block just looks like it's text in quotes, "Block Refs". Micro Roam treats all quotes that could be block refs as block refs, which accidentally creates too many block refs
blocks with line breaks in them can split into two blocks

*/

const mdToStore = (files) => { // files: [{name, ext, fullName, text}]

  const now = Date.now()

  const oldStore = store

  const blockStringIndex = {}

  store = blankStore()

  const getPageId = (title) => store.pagesByTitle[title] || newUid()


  for (let file of files) {
    const title = file.name
    const text = file.text
    const pageId = getPageId(title)
    const page = { "create-time": now,title: title }
    store.pages[pageId] = page
    store.pagesByTitle[title] = pageId
    if (text.length > 0) {
      page.children = []

      const addBlock = (string) => {
        const blockId = newUid()
        blockStringIndex[string] = blockId // overwrite previous string when multiple have the same :(
        const block = { "create-time": now,string }
        store.blocks[blockId] = block
        page.children.push(blockId)
      }

      const stack = [page]
      const blockBreaks = text.matchAll(/\n((?:    )*)- /g)
      let idx = 2 // skip first block break, "- "

      for (let blockBreak of blockBreaks) {
        addBlock(text.substring(idx,blockBreak.index))
        idx = blockBreak.index + blockBreak[0].length
      }
      addBlock(text.substring(idx))
    }
  }

  console.log(store)

  // for (let blockId in store.blocks) {
  //   const block = store.blocks[blockId]
  //   const { pageRefs,quotes } = parseMdBlock(block.string)
  // }
  // const { pageRefs,quotes } = parseMdBlock(blockText)
}

const parseMdBlock = (text) => {

}
/*
block refs ger replaced with "referenced block text". in order to recover these I have to search for a block with that text

if you have
'
text
- text
'
as a block, it will look like 2 blocks in markdown
*/

const mergeStore = (otherStore) => {
  // merge pages by title, adding all blocks to the end
  // if the new store has a block with the same id, give it a new id

  const idTranslation = {}

  const getNewId = (id) => {
    if (store.blocks[id] !== undefined || store.pages[id] !== undefined)
      return idTranslation[id] || newUid()
    return id
  }

  for (let blockId in otherStore.blocks) {
    getNewId(blockId)
  }

  for (let pageId in otherStore.pages) {
    getNewId(pageId)
  }


  const transferBlock = (blockId,newBlockId,parentId) => {
    const block = otherStore.blocks[blockId]
    const newBlock = { ...block }
    store.blocks[newBlockId] = newBlock
    block.parent = parentId
    if (block.children) {
      newBlock.children = []
      for (let childId of block.children) {
        let newChildId = getNewId(childId)
        transferBlock(childId,newChildId,newBlockId)
        newBlock.children.push(newChildId)
      }
    }
    for (let listName of LIST_PROPS) {
      let list = block[listName]
      if (list) {
        newBlock[listName] = list.map(getNewId)
      }
    }
  }

  for (let pageId in otherStore.pages) {
    let page = otherStore.pages[pageId]
    const existingPageId = store.pagesByTitle[page.title]
    if (existingPageId === undefined) {
      const newPageId = getNewId(pageId)
      const newPage = { ...page }
      store.pages[newPageId] = newPage
      store.pagesByTitle[page.title] = newPageId
      if (page.children) {
        newPage.children = []
        for (let blockId of page.children) {
          const newBlockId = getNewId(blockId)
          transferBlock(blockId,newBlockId,pageId)
          newPage.children.push(newBlockId)
        }
      }

      for (let listName of LIST_PROPS) {
        let list = page[listName]
        if (list) {
          newPage[listName] = list.map(getNewId)
        }
      }

    } else {
      const existingPage = store.pages[existingPageId]
      if (page.children) {
        if (existingPage.children === undefined) existingPage.children = []
        for (let childId of page.children) {
          const newChildId = getNewId(childId)
          transferBlock(childId,newChildId,existingPageId)
          existingPage.children.push(newChildId)
        }
      }
      for (let listName of LIST_PROPS) {
        if (page[listName]) {
          if (existingPage[listName] === undefined) existingPage[listName] = []
          for (let name of page[listName]) {
            existingPage[listName].push(getNewId(name))
          }
        }
      }
    }
  }

}

// gc for when I leak data by accident
const gcBlocks = () => {
  for (let blockId of Array.from(store.blocks)) {
    const block = store.blocks[blockId]
    if (store.pages[block.parent] === undefined && store.blocks[block.parent] === undefined) {
      delete store.blocks[blockId]
    }
  }
}



// search

const escapeRegex = (string) => {
  return string.replaceAll(/(?<=^|[^`])([\[\]\(\)])/g,"\\$1").replaceAll("`","")
}

const searchRefCountWeight = 0.05

const titleExactFullTextSearch = (string) => {
  const regex = new RegExp(escapeRegex(string),"i")
  const results = []
  for (let id in store.pages) {
    const page = store.pages[id]
    const title = page.title
    const match = title.match(regex)
    if (match) {
      results.push({ title,id,idx: match.index - page.backRefs.length * searchRefCountWeight })
    }
  }
  results.sort((a,b) => a.idx - b.idx)
  return results.slice(0,10)
}

const exactFullTextSearch = (string) => {
  const regex = new RegExp(escapeRegex(string),"i")
  const results = []
  for (let id in store.pages) {
    const page = store.pages[id]
    const title = page.title
    const match = title.match(regex)
    if (match) results.push({ title,id,idx: match.index - page.backRefs.length * searchRefCountWeight })
  }
  for (let blockUid in store.blocks) {
    const block = store.blocks[blockUid]
    const match = block.string.match(regex)
    // weight blocks 1 lower than titles 
    if (match) results.push({ string: block.string,id: blockUid,idx: match.index + 1 - block.backRefs.length * searchRefCountWeight })
  }
  return results.sort((a,b) => a.idx - b.idx).slice(0,10)
}

const searchTemplates = (string) => {
  const templatePage = store.pages[store.pagesByTitle["roam/templates"]]
  const result = []
  if (templatePage) {
    const fn = (blockId,f) => {
      const block = store.blocks[blockId]
      const match = block.string.match(f ? /^([^ \r\n]+)\s*$/ : /^([^ \r\n]+)\s*(?:(?:#roam\/templates)|(?:\[\[roam\/templates\]\]))$/)
      console.log(match)
      if (match) {
        if (match.length >= string.length && match[1].substring(0,string.length).toLowerCase() === string.toLowerCase()) {
          result.push({ id: blockId,string: match[1] })
        }
      }
    }
    if (templatePage.backRefs) {
      for (let backref of templatePage.backRefs)
        fn(backref,0)
    }
    if (templatePage.children) {
      for (let blockId of templatePage.children)
        fn(blockId,1)
    }
  }
  return result
}

const getTemp = (str) => document.getElementById(str).content.firstElementChild

// Templates
const pageTemplate = getTemp("page")
const blockTemplate = getTemp("block")
const backrefListTemplate = getTemp("backref-list")
const blockFocusFrameTemplate = getTemp("block-focus-frame")
const pageBreakTemplate = getTemp("page-break")
const suggestionTemplate = getTemp("autocomplete__suggestion")
const searchResultTemplate = getTemp("search-result")
const templateSuggestionTemplate = getTemp("template__suggestion")
const breadcrumbBlockTemplate = getTemp("breadcrumb-block")
const breadcrumbPageTemplate = getTemp("breadcrumb-page")
const backrefFrameTemplate = getTemp("backref-frame")
const notificationTemplate = getTemp("notification")

// Block parsing Templates
const pageRefTemplate = getTemp("page-ref")
const tagTemplate = getTemp("tag")
const urlTemplate = getTemp("url")
const blockRefTemplate = getTemp("block-ref")
const boldTemplate = getTemp("bold")
const italicTemplate = getTemp("italic")
const highlightTemplate = getTemp("highlight")
const literalTemplate = getTemp("literal")
const templateExpanderTemplate = getTemp("template-expander")

// Singleton elements
const pageFrame = document.getElementById("page-frame")
const pageFrameOuter = document.getElementById("page-frame-outer")
const searchInput = document.getElementById("search-input")
const downloadButton = document.getElementById("download-button")
const terminalElement = document.getElementById("terminal")
const searchResultList = document.getElementById("search-result-list")
const autocompleteList = document.getElementById("autocomplete-list")
const templateList = document.getElementById("template-list")


const renderPage = (parentNode,uid) => {
  const page = store.pages[uid]
  const element = pageTemplate.cloneNode(true)
  const title = element.firstElementChild
  const body = element.children[1]
  body.dataset.id = uid
  element.dataset.id = uid

  title.innerText = page.title

  let children = page.children
  if (!children || children.length === 0) { // todo set standards for when lists can be empty to reduce ambiguity
    runCommand("createBlock",uid,0)
    children = page.children
  }
  for (let child of children) {
    renderBlock(body,child)
  }

  if (page.backRefs.length > 0) {
    const backrefsListElement = backrefListTemplate.cloneNode(true)
    element.children[2].appendChild(backrefsListElement)
    page.backRefs.sort((a,b) => store.blocks[b]["edit-time"] - store.blocks[a]["edit-time"])
    for (let backref of page.backRefs) {
      const backrefFrame = backrefFrameTemplate.cloneNode(true)
      renderBreadcrumb(backrefFrame.children[0],backref)
      renderBlock(backrefFrame.children[1],backref)
      backrefsListElement.children[1].appendChild(backrefFrame)
    }
  }

  parentNode.appendChild(element)
  return element
}

const renderBlock = (parentNode,uid,idx) => {
  const element = blockTemplate.cloneNode(true)
  const body = element.children[1]
  const childrenContainer = element.children[2]
  element.dataset.id = uid
  childrenContainer.dataset.id = uid
  body.dataset.id = uid

  const string = store.blocks[uid].string
  if (string) {
    renderBlockBody(body,string)
  }

  const children = store.blocks[uid].children
  if (children) {
    for (let child of children) {
      renderBlock(childrenContainer,child)
    }
  }

  if (idx !== undefined && parentNode.children.length >= idx) {
    parentNode.insertBefore(element,parentNode.children[idx])
  } else {
    parentNode.appendChild(element)
  }
  return element
}


const renderBlockBody = (parent,text) => {
  if (text[text.length - 1] !== " ") text += " " // add space because of getSelection.collapse() weirdness with end of contenteditable
  const stack = [parent]
  // 1             2              3   4         5    6         7      8    9       10
  // page-ref-open page-ref-close tag block-ref bold highlight italic link literal template-expander
  const matches = text.matchAll(/(\[\[)|(\]\])|(#[\/a-zA-Z0-9_-]+)|(\(\([a-zA-Z0-9\-_]{8,50}\)\))|(\*\*)|(\^\^)|(__)|((?:https?\:\/\/)(?:[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*))|`([^`]+)`|(;;(?:[^ \n\r]*))/g)

  let idx = 0
  let stackTop = parent

  const newTextNode = (string) => {
    const result = document.createTextNode(string)
    result.startIdx = idx
    result.endIdx = idx + string.length
    return result
  }

  const refTitles = []

  for (let match of matches) {

    stackTop.appendChild(newTextNode(text.substring(idx,match.index)))
    idx = match.index

    if (match[1]) {
      const pageRefElement = pageRefTemplate.cloneNode(true)
      stackTop.appendChild(pageRefElement)
      pageRefElement.children[0].appendChild(newTextNode("[["))
      stack.push(pageRefElement.children[1])
      stackTop = stack[stack.length - 1]
    } else if (match[2]) {
      if (stackTop.className === "page-ref__body") {
        stackTop.parentNode.children[2].appendChild(newTextNode("]]"))
        refTitles.push(stackTop.innerText)
        stack.pop()
        stackTop = stack[stack.length - 1]
      } else {
        stackTop.appendChild(newTextNode("]]"))
      }
    } else if (match[3]) {
      refTitles.push(match[3].substring(1))
      const tagElement = tagTemplate.cloneNode(true)
      tagElement.appendChild(newTextNode(match[3]))
      stackTop.appendChild(tagElement)
    } else if (match[4]) {
      const blockId = match[4].substring(2,match[4].length - 2)
      const block = store.blocks[blockId]
      if (block) {
        const blockRefElement = blockRefTemplate.cloneNode(true)
        blockRefElement.innerText = block.string
        blockRefElement.dataset.id = blockId
        stackTop.appendChild(blockRefElement)
      } else {
        stackTop.appendChild(newTextNode(match[0]))
      }
    } else if (match[5]) {
      if (stackTop.className === "bold") {
        stackTop.appendChild(newTextNode("**"))
        stack.pop()
        stackTop = stack[stack.length - 1]
      } else {
        const boldElement = boldTemplate.cloneNode(true)
        stackTop.appendChild(boldElement)
        boldElement.appendChild(newTextNode("**"))
        stack.push(boldElement)
        stackTop = boldElement
      }
    } else if (match[6]) {
      if (stackTop.className === "highlight") {
        stackTop.appendChild(newTextNode("^^"))
        stack.pop()
        stackTop = stack[stack.length - 1]
      } else {
        const boldElement = highlightTemplate.cloneNode(true)
        stackTop.appendChild(boldElement)
        boldElement.appendChild(newTextNode("^^"))
        stack.push(boldElement)
        stackTop = boldElement
      }
    } else if (match[7]) {
      if (stackTop.className === "italic") {
        stackTop.appendChild(newTextNode("__"))
        stack.pop()
        stackTop = stack[stack.length - 1]
      } else {
        const boldElement = italicTemplate.cloneNode(true)
        stackTop.appendChild(boldElement)
        boldElement.appendChild(newTextNode("__"))
        stack.push(boldElement)
        stackTop = boldElement
      }
    } else if (match[8]) {
      const urlElement = urlTemplate.cloneNode(true)
      urlElement.appendChild(newTextNode(match[8]))
      urlElement.href = match[8]
      stackTop.appendChild(urlElement)
    } else if (match[9]) {
      const literalElement = literalTemplate.cloneNode(true)
      literalElement.appendChild(newTextNode(match[0]))
      stackTop.appendChild(literalElement)
    } else if (match[10]) {
      const templateExpanderElement = templateExpanderTemplate.cloneNode(true)
      templateExpanderElement.appendChild(newTextNode(match[0]))
      stackTop.appendChild(templateExpanderElement)
    }
    idx = match.index + match[0].length
  }

  stack[stack.length - 1].appendChild(newTextNode(text.substring(idx)))

  /**
   * PARSING REVELATION!!!!
   * Instead of backtracking and deleting when a block doesn't close, I can just erase the className of the block. Then it's still part of the tree but looks like it's gone! much less performance cost than backtracking!!
   */
  while (stackTop !== parent) {
    if (stackTop.className === "page-ref")
      stackTop.children[0].className = ""
    stackTop.className = ""
    stackTop = stackTop.parentNode
  }
  return refTitles
}

const renderBreadcrumb = (parent,blockId) => {
  const list = []
  while (true) {
    blockId = store.blocks[blockId].parent
    if (store.blocks[blockId] !== undefined) {
      list.push({ string: store.blocks[blockId].string,id: blockId })
    } else {
      list.push({ title: store.pages[blockId].title,id: blockId })
      break
    }
  }
  const node = breadcrumbPageTemplate.cloneNode(true)
  const title = list[list.length - 1].title
  renderBlockBody(node,title)
  node.dataset.title = title
  parent.appendChild(node)
  for (let i = list.length - 2; i >= 0; i--) {
    const node = breadcrumbBlockTemplate.cloneNode(true)
    const nodeBody = node.children[1]
    renderBlockBody(nodeBody,list[i].string)
    node.dataset.id = list[i].id
    parent.appendChild(node)
  }
}

const notifyText = (text,duration) => {
  const el = notificationTemplate.cloneNode(true)
  el.innerText = text
  document.getElementById("app").appendChild(el)
  setTimeout(() => el.style.top = "60px",50)
  const dur = (duration && duration * 1000) || 5000
  setTimeout(() => el.style.opacity = "0",dur)
  setTimeout(() => {
    el.remove()
  },dur + 300)
}

// Event Listener Helpers -----------------------------------------------------------------------------------------------
const dailyNotesInfiniteScrollListener = () => {
  const fromBottom =
    pageFrame.getBoundingClientRect().bottom - innerHeight
  if (fromBottom < 700) {
    for (let i = 0; i < 100; i++) {
      sessionState.oldestDate.setDate(sessionState.oldestDate.getDate() - 1)
      const daysNotes = store.pagesByTitle[formatDate(sessionState.oldestDate)]
      if (daysNotes) {
        renderPage(pageFrame,daysNotes)
        pageFrame.appendChild(pageBreakTemplate.cloneNode(true))
        break
      }
    }
  }
}

const downloadHandler = () => {
  console.log("download")
  const json = storeToRoamJSON(store)
  const data = new Blob([json],{ type: 'text/json' })
  const url = URL.createObjectURL(data)
  downloadButton.setAttribute('href',url)
  downloadButton.setAttribute('download',`${store.graphName}-micro-roam.json`)
}

const expandTemplate = () => {
  const id = focusSuggestion.dataset.id
  const block = store.blocks[sessionState.focusId]
  if (block.children === undefined || block.children.length === 0) {
    const parentId = store.blocks[sessionState.focusId].parent
    const childIds = store.blocks[id].children
    const currentIdx = blockOrPageFromId(parentId).children.indexOf(sessionState.focusId)
    runCommand("deleteBlock",sessionState.focusId)
    const parentNode = focusBlock.parentNode
    focusBlock.remove()
    for (let i = 0; i < childIds.length; i++) {
      const childId = childIds[i]
      const idx = currentIdx + i
      const newId = runCommand("copyBlock",childId,parentId,idx)
      const e = renderBlock(parentNode,newId,idx)
      if (i === 0) {
        focusBlockEnd(e)
      }
    }
  } else
    notifyText("can't use a template inside a block that has children")
  templateList.style.display = "none"
}

const autocomplete = () => {
  const origString = store.blocks[sessionState.focusId].string
  if (editingLink.className === "tag") {
    const textNode = editingLink.childNodes[0]
    // check for the exact inverse of regex test to see if this would be a valid tag, otherwise make it a ref
    if (/[^\/a-zA-Z0-9_-]/.test(focusSuggestion.dataset.title)) {
      const string = origString.slice(0,textNode.startIdx) + "[[" + focusSuggestion.dataset.title + "]]" + origString.slice(textNode.endIdx)
      sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 4
      setFocusedBlockString(string)
    } else {
      const string = origString.slice(0,textNode.startIdx) + "#" + focusSuggestion.dataset.title + origString.slice(textNode.endIdx)
      sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 1
      setFocusedBlockString(string)
    }
  } else {
    const textNode = editingLink.children[1].childNodes[0]
    const string = origString.slice(0,textNode.startIdx) + focusSuggestion.dataset.title + origString.slice(textNode.endIdx)
    sessionState.position = textNode.startIdx + focusSuggestion.dataset.title.length + 2
    setFocusedBlockString(string)
  }
  autocompleteList.style.display = "none"
}

const indentFocusedBlock = () => {
  const bid = sessionState.focusId
  const olderSibling = focusBlock.previousSibling
  if (olderSibling && olderSibling.dataset && olderSibling.dataset.id) {
    const newParentId = olderSibling.dataset.id
    const idx = blockOrPageFromId(newParentId).children.length
    runCommand("moveBlock",bid,newParentId,idx)
    olderSibling.children[2].appendChild(focusBlock)
    getSelection().collapse(focusNode,focusOffset)
  }
}

const dedentFocusedBlock = () => {
  const bid = sessionState.focusId
  const parent = focusBlock.parentNode.parentNode
  if (parent) {
    const grandparentChildren = parent.parentNode
    const grandparent = parent.parentNode.parentNode
    const grandparentId = grandparent.dataset.id
    const cousin = parent.nextSibling
    if (grandparentId) {
      if (cousin) {
        grandparentChildren.insertBefore(focusBlock,cousin)
      } else {
        grandparentChildren.appendChild(focusBlock)
      }
      const idx = blockOrPageFromId(grandparentId).children.indexOf(bid)
      runCommand("moveBlock",bid,grandparentId,idx + 1)
      getSelection().collapse(focusNode,focusOffset)
    }
  }
}

document.addEventListener("input",(event) => {
  updateCursorInfo()
  autocompleteList.style.display = "none"
  templateList.style.display = "none"
  if (sessionState.isFocused) {

    if (focusBlockBody.innerText === " " || focusBlockBody.innerText === "") {
      runCommand("writeBlock",sessionState.focusId,"",[])
      return
    }

    // reparse block and insert cursor into correct position while typing

    let string = focusBlockBody.innerText
    store.blocks[sessionState.focusId].string = string // todo commit changes on word boundaries

    setFocusedBlockString(string)

    if (editingTitle) {
      const matchingTitles = titleExactFullTextSearch(editingTitle)
      if (matchingTitles.length > 0) {
        autocompleteList.innerHTML = ""
        autocompleteList.style.display = "block"
        const rect = editingLink.getBoundingClientRect()
        autocompleteList.style.top = rect.bottom
        autocompleteList.style.left = rect.left

        for (let i = 0; i < matchingTitles.length; i++) {
          matchingTitle = matchingTitles[i]
          const suggestion = suggestionTemplate.cloneNode(true)
          if (i === 0) suggestion.dataset.selected = "true"
          suggestion.dataset.id = matchingTitle.id

          if (matchingTitle.title) {
            suggestion.dataset.title = matchingTitle.title
            suggestion.innerText = truncateElipsis(matchingTitle.title,50)
          } else {
            suggestion.dataset.string = matchingTitle.string
            suggestion.innerText = truncateElipsis(matchingTitle.string,50)
          }
          autocompleteList.appendChild(suggestion)
        }
      }
    }

    if (editingTemplateExpander) {
      console.log("editingTemplateExpander")
      const editingTemplateText = editingTemplateExpander.innerText.substring(2)
      const matchingTemplates = searchTemplates(editingTemplateText)
      console.log(matchingTemplates)
      if (matchingTemplates.length > 0) {
        templateList.innerHTML = ""
        for (let i = 0; i < Math.min(matchingTemplates.length,10); i++) {
          const result = templateSuggestionTemplate.cloneNode(true)
          if (i === 0) {
            result.dataset.selected = "true"
          }
          result.dataset.string = matchingTemplates[i].string
          result.dataset.id = matchingTemplates[i].id
          result.innerText = truncateElipsis(matchingTemplates[i].string,50)
          templateList.appendChild(result)
        }
        templateList.style.display = "block"
        templateList.style.top = editingTemplateExpander.getBoundingClientRect().bottom
        templateList.style.left = editingTemplateExpander.getBoundingClientRect().left
      }
    }

  } else if (event.target.id === "search-input") {
    const matchingTitles = exactFullTextSearch(event.target.value)
    if (matchingTitles.length > 0) {
      searchResultList.innerHTML = ""
      for (let i = 0; i < Math.min(matchingTitles.length,10); i++) {
        const result = searchResultTemplate.cloneNode(true)
        if (i === 0) {
          result.dataset.selected = "true"
        }
        if (matchingTitles[i].title) {
          result.dataset.title = matchingTitles[i].title
          result.innerText = truncateElipsis(matchingTitles[i].title,50)
        } else {
          result.dataset.string = matchingTitles[i].string
          result.dataset.id = matchingTitles[i].id
          result.innerText = truncateElipsis(matchingTitles[i].string,50)
        }
        searchResultList.appendChild(result)
      }
      searchResultList.style.display = "block"
      searchResultList.style.top = searchInput.getBoundingClientRect().bottom
      searchResultList.style.left = searchInput.getBoundingClientRect().left
    } else {
      searchResultList.style.display = "none"
    }

  } else if (event.target.className === "page__title") {
    console.log("edit title")
    const pageId = event.target.parentNode.dataset.id
    runCommand("writePageTitle",pageId,event.target.innerText)
  }
})

const focusBlockEnd = (blockNode) => {
  const body = blockNode.children[1]
  const temp = document.createTextNode(" ")
  body.appendChild(temp)
  getSelection().collapse(temp,0)
  temp.remove()
}

const focusBlockStart = (blockNode) => {
  const body = blockNode.children[1]
  const temp = document.createTextNode(" ")
  body.insertBefore(temp,body.firstChild)
  getSelection().collapse(temp,0)
  temp.remove()
}

const globalHotkeys = {
  "hide top bar": {
    key: "b",
    control: true,
    fn: () => {
      if (topBar.style.marginTop === "0px") user.topBar = "hidden"
      else user.topBar = "visible"
      saveUser()
    }
  },
  "escape": {
    key: "Escape",fn: () => {
      autocompleteList.style.display = "none"
      templateList.style.display = "none"
    }
  },
  "upload": {
    key: "d",control: true,fn: () => {
      document.getElementById("upload-input").click()
    }
  },
  "download": { key: "s",control: true,shift: true,fn: downloadHandler },
  "save": { key: "s",control: true,fn: () => { saveWorker.postMessage(["save",store]) } },
  "toggle color theme": {
    key: "m",control: true,fn: () => {
      if (document.body.className === "light") {
        user.theme = "dark"
        saveUser()
      } else {
        user.theme = "light"
        saveUser()
      }
    }
  },
  "search": {
    key: "u",control: true,fn: () => {
      if (topBar.style.marginTop !== "0px") topBar.style.marginTop = "0px"
      searchInput.focus()
    }
  },
  "open": {
    key: "o",control: true,fn: () => {
      if (editingLink && editingLink.className === "page-ref")
        goto("pageTitle",editingLink.children[1].innerText)
      if (editingLink && editingLink.className === "tag")
        goto("pageTitle",editingLink.innerText.substring(1))
    }
  },
  "terminal": {
    key: "i",control: true,alt: true,fn: () => {
      if (terminalElement.style.display === "none") {
        terminalElement.style.display = "block"
        terminalElement.focus()
      } else {
        terminalElement.style.display = "none"
      }
    }
  }
}

document.addEventListener("keydown",(event) => {
  updateCursorInfo()

  for (let hotkeyName in globalHotkeys) {
    const hotkey = globalHotkeys[hotkeyName]
    if (event.key === hotkey.key &&
      event.shiftKey === !!hotkey.shift &&
      event.ctrlKey === !!hotkey.control &&
      event.altKey === !!hotkey.alt) {
      hotkey.fn()
      event.preventDefault()
      return
    }
  }

  if (autocompleteList.style.display !== "none") {
    if (event.key === "Tab" || event.key === "Enter") {
      autocomplete()
      event.preventDefault()
    }
    const newSelected = (event.key === "ArrowUp" && focusSuggestion.previousSibling) || (event.key === "ArrowDown" && focusSuggestion.nextSibling)
    if (newSelected) {
      newSelected.dataset.selected = "true"
      delete focusSuggestion.dataset.selected
      event.preventDefault()
    }
  } else if (templateList.style.display !== "none") {
    if (event.key === "Tab" || event.key === "Enter") {
      expandTemplate()
      event.preventDefault()
    }
    const newSelected = (event.key === "ArrowUp" && focusSuggestion.previousSibling) || (event.key === "ArrowDown" && focusSuggestion.nextSibling)
    if (newSelected) {
      newSelected.dataset.selected = "true"
      delete focusSuggestion.dataset.selected
      event.preventDefault()
    }
  } else if (sessionState.isFocused) {
    let blocks
    let newActiveBlock
    switch (event.key) {
      case "Enter":
        if (!event.shiftKey) {
          const parent = blockOrPageFromId(store.blocks[sessionState.focusId].parent)
          let idx = parent.children.indexOf(sessionState.focusId)
          if (!event.ctrlKey) {
            idx += 1
          }
          console.log(idx)
          const newBlockUid = runCommand("createBlock",store.blocks[sessionState.focusId].parent,idx)
          const newBlockElement = renderBlock(focusBlock.parentNode,newBlockUid,idx)
          newBlockElement.children[1].focus()
          event.preventDefault()
        }
        break
      case "Tab":
        if (event.shiftKey)
          dedentFocusedBlock()
        else
          indentFocusedBlock()
        event.preventDefault()
        break
      case "Backspace":
        if (sessionState.position === 0) {
          blocks = Array.from(document.querySelectorAll(".block"))
          newActiveBlock = blocks[blocks.indexOf(focusBlock) - 1]
          focusBlock.remove()
          focusBlockEnd(newActiveBlock)
          runCommand("deleteBlock",sessionState.focusId)
          event.preventDefault()
        }
        break
      case "ArrowDown":
        if (event.altKey && event.shiftKey) {
          const parentId = store.blocks[sessionState.focusId].parent
          const parentElement = focusBlock.parentNode
          const currentIdx = blockOrPageFromId(parentId).children.indexOf(sessionState.focusId)
          if (focusBlock.nextSibling) {
            runCommand("moveBlock",sessionState.focusId,parentId,currentIdx + 1)
            if (focusBlock.nextSibling.nextSibling) {
              parentElement.insertBefore(focusBlock,focusBlock.nextSibling.nextSibling)
            } else parentElement.appendChild(focusBlock)
            getSelection().collapse(focusNode,focusOffset)
            event.preventDefault()
          }
        } else if (!event.shiftKey && !event.altKey) {
          blocks = Array.from(document.querySelectorAll(".block"))
          newActiveBlock = blocks[blocks.indexOf(focusBlock) + 1]
          focusBlockStart(newActiveBlock)
          event.preventDefault()
        }
        break
      case "ArrowUp":
        if (event.altKey && event.shiftKey) {
          const parentId = store.blocks[sessionState.focusId].parent
          const parentElement = focusBlock.parentNode
          const currentIdx = blockOrPageFromId(parentId).children.indexOf(sessionState.focusId)
          if (focusBlock.previousSibling) {
            runCommand("moveBlock",sessionState.focusId,parentId,currentIdx - 1)
            parentElement.insertBefore(focusBlock,focusBlock.previousSibling)
            getSelection().collapse(focusNode,focusOffset)
            event.preventDefault()
          }
        } else if (!event.shiftKey && !event.altKey) {
          blocks = Array.from(document.querySelectorAll(".block"))
          newActiveBlock = blocks[blocks.indexOf(focusBlock) - 1]
          focusBlockEnd(newActiveBlock)
          event.preventDefault()
        }
        break
      case "ArrowLeft":
        if (event.shiftKey && event.altKey) {
          dedentFocusedBlock()
        } else if (sessionState.position === 0) {
          blocks = Array.from(document.querySelectorAll(".block"))
          newActiveBlock = blocks[blocks.indexOf(focusBlock) - 1]
          focusBlockEnd(newActiveBlock)
          event.preventDefault()
        }
        break
      case "ArrowRight":
        if (event.shiftKey && event.altKey) {
          indentFocusedBlock()
        } else if (sessionState.position === focusBlockBody.innerText.length) {
          blocks = Array.from(document.querySelectorAll(".block"))
          newActiveBlock = blocks[blocks.indexOf(focusBlock) + 1]
          if (newActiveBlock) focusBlockStart(newActiveBlock)
          event.preventDefault()
        }
        break
    }
  }

  if (
    document.activeElement &&
    document.activeElement.id === "search-input"
  ) {
    if (event.key === "Enter") {
      goto("pageTitle",event.target.value)
      event.preventDefault()
      return
    } else if (event.key === "Tab") {
      const selected = searchResultList.querySelector(`.search-result[data-selected="true"]`)
      if (selected) {
        if (selected.dataset.title) {
          goto("pageTitle",selected.dataset.title)
        } else {
          goto("block",selected.dataset.id)
        }
        return
      }
    }
  }

  if (terminalElement.style.display !== "none") {
    if (event.key === "Enter" && !event.ctrlKey && !event.shiftKey && !event.altKey) {
      const tc = terminalCommands[event.target.innerText]
      if (tc) tc()
      else eval(event.target.innerText)
      if (!event.ctrlKey) {
        terminalElement.style.display = "none"
        terminalElement.innerHTML = ""
      }
    }
  }

})

document.addEventListener("click",(event) => {

  const closestBullet = event.target.closest(".block__bullet")

  if (event.target.className === "search-result") {
    if (event.target.dataset.title) {
      goto("pageTitle",event.target.dataset.title)
    } else {
      goto("block",event.target.dataset.id)
    }
    return
  } else if (event.target.id !== "search-input") {
    searchResultList.style.display = "none"
  }

  const closestBreadcrumbPage = event.target.closest(".breadcrumb-page")
  const closestBreadcrumbBlock = event.target.closest(".breadcrumb-block")
  if (event.target.className === "template__suggestion") {
    if (focusSuggestion) focusSuggestion.dataset.selected = false
    event.target.dataset.selected = true
    focusSuggestion = event.target
    expandTemplate()
  } else if (event.target.className === "page-ref__body") {
    goto("pageTitle",event.target.innerText)
  } else if (closestBullet) {
    goto("block",closestBullet.parentNode.dataset.id)
  } else if (event.target.className === "block-ref") {
    goto("block",event.target.dataset.id)
  } else if (event.target.closest(".tag")) {
    goto("pageTitle",event.target.closest(".tag").innerText.substring(1))
  } else if (event.target.id === "download-button") {
    downloadHandler()
  } else if (event.target.id === "upload-button") {
    document.getElementById("upload-input").click()
  } else if (event.target.id === "daily-notes-button") {
    goto("dailyNotes")
  } else if (event.target.className === "autocomplete__suggestion") {
    if (focusSuggestion) focusSuggestion.dataset.selected = false
    event.target.dataset.selected = true
    autocomplete()
  } else if (event.target.className === "url") { // using spans with event handlers as links because they play nice with contenteditable
    const link = document.createElement("a")
    link.target = "_blank"
    link.href = event.target.innerText
    link.click()
  } else if (event.target.id === "help-button") {
    goto("pageTitle","Welcome to Micro Roam")
  } else if (closestBreadcrumbPage) {
    goto("pageTitle",closestBreadcrumbPage.dataset.title)
  } else if (closestBreadcrumbBlock) {
    goto("block",closestBreadcrumbBlock.dataset.id)
  }

  // this is at the bottom so that autocomplete suggestion click handler still knows where the link is. 
  // todo have better tracking of active block
  updateCursorInfo()
})

topBarHiddenHitbox.addEventListener("mouseover",() => {
  user.topBar = "visible"
  saveUser()
})

document.getElementById('upload-input').addEventListener('change',(event) => {
  const file = event.target.files[0]
  console.log(file)
  const [name,extension] = file.name.split(".")
  console.log(`name ${name} extension ${extension}`)
  if (extension === "zip") {
    file.arrayBuffer().then((buffer) => {
      const files = zipToFiles(buffer)
      console.log(files)
      if (files.length === 1 && files[0].ext === "json") {
        store = roamJsonToStore(files[0].name,files[0].text)
        fetch("./default-store.json").then(text => text.json().then(json => {
          mergeStore(json)
          theresANewStore()
        }))
      } else {
        const mds = []
        for (let file of files) {
          if (file.ext === "md") {
            mds.push(file)
          } else {
            console.log(`That zip file contained ${file.fullName}, but Micro Roam expected a .json file or multiple .md files`)
          }
        }
        console.log("parsing markdown")
        mdToStore(mds)
      }
    })
  } else if (extension === "json") {
    file.text().then((text) => {
      store = roamJsonToStore(name,text)
      fetch("./default-store.json").then(text => text.json().then(json => {
        mergeStore(json)
        theresANewStore()
      }))
    })
  } else {
    notifyText("Micro Roam only accepts a .json file, a .zip file containing 1 .json file, or a .zip file containing .md files")
  }
})


const initialDailyNotes = 5

const renderSessionState = () => {

  // clear screen
  searchResultList.style.display = "none"
  pageFrameOuter.removeEventListener("scroll",dailyNotesInfiniteScrollListener)
  pageFrame.innerHTML = ""
  searchInput.value = ""

  // render state
  switch (sessionState.pageFrame) {
    case "pageTitle":
      let existingPage = store.pagesByTitle[sessionState.pageFrameTitle]
      if (existingPage === undefined) {
        existingPage = runCommand("createPage",sessionState.pageFrameTitle)
      }
      renderPage(pageFrame,existingPage)
      break
    case "block":
      const blockFocusFrame = blockFocusFrameTemplate.cloneNode(true)
      pageFrame.appendChild(blockFocusFrame)
      renderBreadcrumb(blockFocusFrame.children[0],sessionState.pageFrameId)
      renderBlock(blockFocusFrame.children[1],sessionState.pageFrameId)
      const backRefs = store.blocks[sessionState.pageFrameId].backRefs
      if (backRefs) {
        backRefs.sort((a,b) => store.blocks[b]["edit-time"] - store.blocks[a]["edit-time"])
        const backrefsListElement = backrefListTemplate.cloneNode(true)
        blockFocusFrame.children[2].appendChild(backrefsListElement)
        for (let backref of backRefs) {
          renderBlock(backrefsListElement.children[1],backref)
        }
      }
      break
    case "dailyNotes":
      pageFrameOuter.addEventListener("scroll",dailyNotesInfiniteScrollListener)
      sessionState.oldestDate = new Date(Date.now())
      let numNotesLoaded = 0
      if (store.pagesByTitle[formatDate(sessionState.oldestDate)] === undefined) {
        runCommand("createPage",formatDate(sessionState.oldestDate))
      }
      for (let i = 0; i < 1000; i++) {
        const daysNotes = store.pagesByTitle[formatDate(sessionState.oldestDate)]
        if (daysNotes) {
          renderPage(pageFrame,daysNotes)
          pageFrame.appendChild(pageBreakTemplate.cloneNode(true))
          numNotesLoaded += 1
          if (numNotesLoaded >= initialDailyNotes) {
            break
          }
        }
        sessionState.oldestDate.setDate(
          sessionState.oldestDate.getDate() - 1
        )
      }
      if (numNotesLoaded < initialDailyNotes) pageFrame.lastChild.remove()
      break
  }

  if (sessionState.isFocused) {
    focusIdPosition()
  }

  pageFrameOuter.scrollTop = sessionState.scroll || 0
}

const gotoNoHistory = (commandName,...command) => {
  switch (commandName) {
    case "dailyNotes":
      sessionState.pageFrame = "dailyNotes"
      break
    case "pageTitle":
      sessionState.pageFrame = "pageTitle"
      sessionState.pageFrameTitle = command[0]
      break
    case "block":
      sessionState.pageFrame = "block"
      sessionState.pageFrameId = command[0]
      break
  }

  renderSessionState()
}

const goto = (...command) => {
  sessionState.scroll = pageFrameOuter.scrollTop // used to have updatecursorinfo here, think I don't need it?

  const oldSessionState = JSON.parse(JSON.stringify(sessionState))

  sessionState.scroll = 0
  gotoNoHistory(...command)
  setTimeout(() => {
    history.replaceState(oldSessionState,"Micro Roam")
    // todo use page title, in more places than just this because apparently here's not often supported
    history.pushState(sessionState,"Micro Roam")
  },0)
}

const gotoReplaceHistory = (...command) => {
  gotoNoHistory(...command)
  history.replaceState(sessionState,"Micro Roam")
}

window.addEventListener("popstate",(event) => {
  console.log(event.state)
  if (event.state) {
    sessionState = event.state
    renderSessionState()
  }
})

const focusIdPosition = () => {
  focusBlockBody = document.querySelector(`.block[data-id="${sessionState.focusId}"]>.block__body`)

  const scanElement = (element) => {
    for (let el of element.childNodes) {
      if (el.nodeName === "#text") {
        if (el.textContent && sessionState.position >= el.startIdx && sessionState.position < el.startIdx + el.textContent.length) {
          scanResult = el
          try {
            // this does the thing correctly, but then throws an error, which I catch? todo investigate
            getSelection().collapse(el,sessionState.position - el.startIdx)
            return el
          } catch (error) {
            return el
          }
        }
      } else {
        const z = scanElement(el)
        if (z) return z
      }
    }
  }
  scanElement(focusBlockBody)
}

const setFocusedBlockString = (string) => {
  focusBlockBody.innerHTML = ""
  const refTitles = renderBlockBody(focusBlockBody,string)
  focusIdPosition()
  updateCursorInfo()
  runCommand("writeBlock",sessionState.focusId,string,refTitles)
}

// todo call this less. right now it's called twice as much as necessary, costing 0.3ms per keystroke and making code ugly
const updateCursorInfo = () => {
  console.log("update cursor info")
  sessionState.scroll = pageFrameOuter.scrollTop

  focusNode = getSelection().focusNode
  focusOffset = getSelection().focusOffset

  focusSuggestion = autocompleteList.querySelector(`.autocomplete__suggestion[data-selected="true"]`) || templateList.querySelector(`.template__suggestion[data-selected="true"]`)

  if (focusNode) {
    focusBlock = focusNode.parentNode.closest(".block")
    if (focusBlock) {

      sessionState.isFocused = true
      sessionState.focusId = focusBlock.dataset.id

      if (focusNode.className === "block__body") {
        sessionState.position = focusBlock.innerText.length * (focusOffset !== 0) // todo make this less jank
      } else {
        sessionState.position = focusOffset
        if (focusNode.startIdx) sessionState.position += focusNode.startIdx
      }
      focusBlockBody = focusBlock.children[1]

      editingLink = undefined
      const pageRefs = focusBlockBody.querySelectorAll(".page-ref")
      const tags = focusBlockBody.querySelectorAll(".tag")
      for (let tag of tags) {
        if (tag.childNodes[0].endIdx >= sessionState.position && tag.childNodes[0].startIdx < sessionState.position) {
          editingLink = tag
        }
      }
      for (let ref of pageRefs) {
        if (ref.children[1].childNodes[0].endIdx >= sessionState.position && ref.children[1].childNodes[0].startIdx < sessionState.position) {
          editingLink = ref
        }
      }
      editingTitle = editingLink && ((editingLink.className === "tag" && editingLink.innerText.substring(1)) || (editingLink.className === "page-ref" && editingLink.children[1].innerText))

      editingTemplateExpander = undefined
      const templateExpanders = focusBlockBody.querySelectorAll(".template-expander")
      for (let temp of templateExpanders) {
        if (temp.childNodes[0].endIdx >= sessionState.position && temp.childNodes[0].startIdx < sessionState.position) {
          editingTemplateExpander = temp
        }
      }
    } else
      sessionState.isFocused = false

  } else
    sessionState.isFocused = false

}


// start the save worker
const saveWorker = new Worker('/worker.js')

saveWorker.postMessage(["user",user])

saveWorker.onmessage = (event) => {
  const data = event.data[1]
  const operation = event.data[0]
  if (operation === "ping") {
    console.log(`ping took ${performance.now() - pingstime}`)
  }

}


// Finally starting the program after everything's compiled
if (w) {
  theresANewStore()
} else {
  w = true
}


// const ptest = () => {
//   const t = performance.now()
//   for (let i = 0; i < 1000000; i++) {
//
//   }
//   console.log(`took ${performance.now() - t}`)
// }
// ptest()

const page = (string) => {
  console.log(store.pages[store.pagesByTitle[string]])
}

const log = () => {
  user.logging = true
  saveUser()
  saveWorker.postMessage(["user",user])
}

const nolog = () => {
  user.logging = false
  saveUser()
  saveWorker.postMessage(["user",user])
}

const test = () => {
  const testScriptNode = document.createElement("script")
  testScriptNode.src = "test.js"
  document.body.appendChild(testScriptNode)
}

const reset = () => {
  const r = indexedDB.deleteDatabase("microroam")
  localStorage.removeItem("user")
  window.location.href = window.location.href
}

const blank = () => {
  store = blankStore()
  user = blankUser
  saveUser()
  goto("dailyNotes")
}

const pr = () => {
  console.log(JSON.stringify(store))
}

let pingstime
const ping = () => {
  pingstime = performance.now()
  saveWorker.postMessage(["ping",{ hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: { hello: "hello" } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }])
}

const terminalCommands = {
  blank,reset,test,log,page,nolog,ping,pr
}
</script>
</body>