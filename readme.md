# Micro Roam

Fast note taking and sharing app inspired by Roam Research.

# Why did I make Micro Roam?

I love Roam Research. I think that sort of freeform, linked text should be the default for everything we write. However, Roam Research doesn't have the engineering quality to be that default for most people, and from my conversations with them, the team at Roam is not heading in that direction.

# The Stack

I chose my tech stack, JS and Node w/o NPM, because the language is familiar and it allows me to spend my time writing code, not reading documentation, and it can achieve reasonable performance. Tech I'm considering down the road includes more use of HTML5 Canvas, C, C++, SycllaDB, NGINX, and JAI.

# Intentional differences compared to Roam

Few/no extensions. Running user written code in your product is inherently slow and unreliable, so I am not interested in low-barrier-to-entry JavaScript extensions, and will only support CSS extensions if I find a new way to make them far more reliable.

Sharing focus. I want to share my notes, and want to make sharing and commenting good. I prioritize linking between users more than multiple users on the same account.

Performance standards. 10ms is a reasonable time to take to load a page of text. I do not have time for people who think it's okay to take longer than that.

# Features over Roam

Live markup. see links, highlights, ect while typing

10x performance

# Features missing compared to Roam

Slash autocomplete, Queries, roam/render, roam/css, image upload, page list, favorites, a some other small ones

# Benchmarks

Site load from my 2Mb graph in local indexedDB: 170ms to 450ms

Page link load: 15ms per page for my 1000 pages. Ranges from 5ms to 200ms for ordinary sized pages, but I've seen 2s for extremely large pages generated by scripts.

Note: Website performance depends on your browser, browser extensions, computer, internet connection, location, phase of the browser GC cycle (basically phase of the moon). The biggest cause of discrepency is browser extensions, which can add 0.5 seconds to load times and 50ms to all response times.

# Internals

This project is made with *System Complexity*, in mind. That means instead of writing your own code to be elegant, you write code such that the entire project, including the platform, libraries, frameworks, as a whole is as as simple as possible. Currently the dependencies are:

npm: uglify-js (this has none of its own dependencies. it's very slow, but it actually does everything I need it to)

Backend dependencies: still considering backend options. ScyllaDB, RocksDB look good.

## Data architecture

Each person's own notes, called 'blox', is a are stored in one JSON string / object. This entire object (1.5Mb for me), or diffs on that object when it changes (tbd), are sent from the server to the client. No smaller unit of notes is sent. This allows the client to do all the logic, and makes the UX as fast as possible.

When the client receives the 'blox', it creates the 'store', which contains the blox and indexing data. This takes 50-80ms. This indexing data makes the store 30% bigger than 'blox'. The indexing info exists only on the client in order to reduce the bandwidth requirements, and to elminate fragmented writes that would be required on the backend on indexes only the front end uses.

blox uses terse keys to reduce size
```
                string parent kids create-time edit-time create-user edit-user
blox: {bloc-id:{s,     p,     k:[kid-id],   ct,         et,       cu,       edit-user }}
```

I originally stored the 'store' in indexeddb because it's supposed to have more capacity / reliability than localStorage, but it's slower so now I write to localStorage and indexedDB and only read from indexedDB if the localStorage didn't work.

Session specific data, for the recording browser history, in sessionState. The current state is global and updated mutably, then copied into a seperate object when needed to remember states.

There are a large number of global variables, all (mutable ones) declared in index.html and declarations.js

user settings are stored in seperate from graph, and apply to all graphs that user views.

## Code organization

The code is arranged by when it is run, not what part of the system it's in. All the event handlers are together, renderers are together, queries are together, commands are together, ect, instead of being arranged into components which each have their own event handling, logic, ect. 

All event handling for non-permanent elements (anything without id) is done through global documend event handlers which switch on the target element. I did this because I thought it would speed up rendering (when you click a link, event handler runs once, but block renderer runs 100 times, so move code from renderer to event handler). Still might move towards a more normal structure.


## Templating

I'm using HTML `<template>`s, `cloneNode`, and `element.firstElementChild.children[1].innerText=` for templating because it's the most performant out of methids I tested (more so than string replacement or `document.createElement`). This is hard to read and overly coupled, so I may make an abstraction over this. The highest performance option (which would not be tremendously more performant than other options) is a preprocessor that reads positions of classes within templates and replaces "calls" to those classes with `element.firstElementChild.children[1]` type stuff. Query at compile time, not runtime.

## Future improvements

Handling huge block parses. Right now it works well up to something like 500 syntax elements per block. Gets synchronously laggy after that.

Make each page render (and block render?) keep track of how long it's taken and break + resume when it takes too long

Improvements to bracket auto-closing. Do it to more types of brackets, do backspace matching

When there is cross-graph linking, load graphs when they're needed before first render, then do others in 50ms chunks

# Working on right now

exporting / importing markdown files

making signup and login work and have good ui

Test what css stuff is fast, and use that. (unfortunately it doesn't look like there's tons of room to improve here :( )